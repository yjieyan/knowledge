# V8的垃圾回收机制

1.  **垃圾回收的必要性**
2.  **V8 内存分代假说**
3.  **新生代与 Scavenger 算法**
4.  **老生代与主垃圾回收器**
5.  **Orinoco：并发与并行垃圾回收**
6.  **总结与关键优化**

---

### 1. 垃圾回收的必要性

JavaScript 是一种垃圾回收语言。开发者不需要手动分配和释放内存，V8 引擎会自动管理内存生命周期。其核心任务是：

*   **分配内存**：当创建对象、字符串等时。
*   **识别垃圾**：找到那些不再被程序使用的对象。
*   **释放内存**：回收垃圾对象所占用的内存，以便再次分配。

手动管理内存（如 C++）容易导致内存泄漏或野指针问题，而自动垃圾回收则解决了这个痛点。

---

### 2. V8 内存分代假说

V8 垃圾回收策略的核心基于一个观察到的**强分代假说**：

> **绝大多数对象的生命周期都很短，通常一经创建很快就变得不可达；而那些存活时间足够长的对象，往往还能活得更久。**

基于这个假说，V8 将堆内存划分为两个主要区域：**新生代** 和 **老生代**。

*   **新生代**：存放**生存时间短**的对象。通常只支持 **1-8 MB** 的容量。垃圾回收在此发生得非常频繁，速度也很快。
*   **老生代**：存放**生存时间长**的对象或从新生代**晋升**过来的对象。容量远大于新生代。垃圾回收在此发生得较少，但耗时更长。

这种分代设计允许 V8 对不同类型的对象采用不同的、最优的回收策略。

---

### 3. 新生代与 Scavenger 算法

新生代使用一种叫做 **Scavenge** 的算法，具体实现是 **Cheney 算法**。它的核心是 **“复制”**。

#### **新生代的结构**
新生代被划分为两个相等的**半空间**：
*   **From-Space（对象区）**：新对象首先在这里被分配。
*   **To-Space（空闲区）**：在垃圾回收时扮演备份区的角色。

#### **Scavenge 过程**
1.  **分配**：所有新对象都在 **From-Space** 进行分配。
2.  **标记与复制**：当 **From-Space** 快被填满时，会触发一次 **Minor GC**。
    *   V8 会遍历 **From-Space** 中的对象，**标记**出仍然存活的对象。
    *   将这些**存活的对象**复制到 **To-Space** 中。在复制过程中，它们会被紧凑地排列在一起，消除了内存碎片。
    *   同时，V8 会更新所有指向这些被移动对象的指针。
3.  **角色翻转**：复制完成后，**To-Space** 变成新的 **From-Space**，而原来的 **From-Space** 变成新的 **To-Space**（此时已被清空）。
4.  **晋升**：如果一个对象在新生代中经历过一次 GC 后仍然存活，或者 **To-Space** 已经被使用了 25%（为了避免过早翻转），它就会被**晋升**到老生代中。

**优点**：速度极快，因为它只处理存活的对象，而不关心死亡对象。
**缺点**：只能使用一半的堆空间，存在空间上的浪费。

---

### 4. 老生代与主垃圾回收器

老生代中存放的对象更复杂、更大，且存活率高，因此不适合使用 Scavenge 算法（复制成本太高）。老生代使用 **“标记-清除-整理”** 算法。

#### **回收过程分为三个阶段**：

1.  **标记（Marking）**
    *   V8 从一组**根对象**开始遍历（如全局对象、当前函数作用域链、激活的上下文等）。
    *   从根对象出发，递归地遍历所有能访问到的对象，并将它们**标记为活动对象**。无法从根对象访问到的对象即为**垃圾**。
    *   **三色标记法**：为了高效管理标记状态，V8 使用白（未访问）、灰（已访问但子节点未访问）、黑（已访问且子节点也已访问）三种颜色来标记对象。

2.  **清除（Sweeping）**
    *   标记阶段完成后，V8 会遍历整个老生代内存。
    *   将所有未被标记为活动对象的内存区域添加到**空闲内存列表**中。这些区域现在可以被重新分配。
    *   **注意**：清除阶段只是将垃圾内存记录起来，并没有立即移动对象，因此会产生**内存碎片**。

3.  **整理（Compaction）**
    *   为了解决内存碎片问题，V8 在必要时会执行**内存整理**。
    *   它将所有存活的对象**移动**到一起，紧密地排列在内存的一端。
    *   这个过程会**消除内存碎片**，使得大块的连续内存分配成为可能，但代价是更长的停顿时间。

---

### 5. Orinoco：并发与并行垃圾回收

传统的垃圾回收会 **“停止世界”（Stop-The-World）**，即暂停 JavaScript 的执行，直到 GC 完成。这会导致页面卡顿、应用无响应。

现代的 V8（项目代号 **Orinoco**）致力于通过 **并行、增量、并发** 技术来减少主线程的停顿时间。

*   **并行**：GC 任务在主线程和几个辅助线程上**同时进行**，但此时 JavaScript 执行仍然是暂停的。这缩短了总的停顿时间。
*   **增量**：GC 任务被**分解成一系列小任务**，与 JavaScript 执行**交替进行**。而不是一次性完成一个完整的 GC。这样每次停顿的时间很短，用户几乎感知不到。
*   **并发**：GC 任务在**辅助线程上完全并发地执行**，**完全不需要停止 JavaScript 的执行**。这是最理想的方式，但实现也最复杂，因为它需要处理 JavaScript 在执行时同时修改对象图的复杂情况。

**具体应用：**
*   **新生代 GC**：通常是**并行**的。
*   **老生代标记**：现在是**并发**的。标记工作主要在后台线程进行，只有很小的停顿。
*   **老生代整理**：通常是**并行**的。

---

### 6. 总结与关键优化

1.  **分而治之**：基于**分代假说**，将堆分为新生代和老生代，对不同生命周期的对象采用最优算法。
2.  **空间换时间**：新生代的 **Scavenge** 算法用一半的空间换来了极快的回收速度。
3.  **权衡取舍**：老生代的 **标记-清除-整理** 算法在速度、空间和碎片化之间取得平衡。
4.  **用户体验优先**：通过 **并行、增量、并发** 技术，最大限度地减少垃圾回收对应用程序执行的阻塞，保证页面的流畅性。

虽然 V8 的 GC 非常智能，但不当的代码仍会使其低效：
*   **避免全局变量**：它们永远是根对象，永远不会被回收。
*   **及时解除引用**：对于不再使用的大对象（如缓存、DOM 元素引用），手动设置为 `null`。
*   **避免内存泄漏**：注意闭包、被遗忘的定时器和回调函数、分离的 DOM 节点等。

V8 的垃圾回收是一个在**空间、时间、停顿**之间不断权衡和优化的复杂系统。

## 查看 V8 的内存使用情况
