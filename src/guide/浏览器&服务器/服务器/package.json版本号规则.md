# package.json版本号规则
`package.json` 中的版本号遵循 **语义化版本控制（Semantic Versioning，简称 SemVer）** 规范。

1.  **语义化版本（SemVer）的核心概念**
2.  **版本号格式解析**
3.  **版本范围语法（依赖声明规则）**
4.  **Node.js 包管理器如何处理版本范围**
5.  **特殊版本与标签**
6.  **最佳实践总结**

---

### 1. 语义化版本（SemVer）的核心概念

SemVer 的格式为 `主版本号.次版本号.修订号`（`MAJOR.MINOR.PATCH`），其变更有明确的含义：

*   **主版本号（MAJOR）**：当你做了**不兼容的 API 修改**。
    *   例如：从 `1.x.x` 升级到 `2.0.0`，可能意味着原有的 API 被移除或重写，升级时需要仔细检查代码。
*   **次版本号（MINOR）**：当你做了**向下兼容的功能性新增**。
    *   例如：从 `1.1.0` 升级到 `1.2.0`，表示新增了功能，但原有的 API 没有被破坏。你可以安全地升级。
*   **修订号（PATCH）**：当你做了**向下兼容的问题修正**。
    *   例如：从 `1.2.0` 升级到 `1.2.1`，表示修复了 bug，没有新增任何功能。你应该尽快升级以保证稳定性。

**预发布版本**和**构建元数据**可以作为附加标签，格式为：`主版本号.次版本号.修订号-预发布标签+构建数据`，例如 `1.2.3-beta.1+20240527`。

---

### 2. 版本号格式解析

| 版本号 | 说明 | 稳定性 |
| :--- | :--- | :--- |
| `1.0.0` | 标准的正式版 | 稳定 |
| `1.2.3` | 明确的、具体的版本 | 非常稳定 |
| `0.1.0` | **初始开发版本**。此阶段任何更新都可能包含不兼容的变更。 | 极不稳定 |
| `1.2.3-beta.0` | **预发布版本**。用于测试，稳定性低于正式版。 | 不稳定 |
| `1.2.3-alpha` | 比 `beta` 更早的预发布版本。 | 非常不稳定 |

---

### 3. 版本范围语法（依赖声明规则）

这是 `package.json` 中 `dependencies` 和 `devDependencies` 里最核心的部分。它定义了你的项目**可以接受**的依赖版本范围。

#### **精确版本**

*   `"1.2.3"`：**只**安装版本 `1.2.3`。
*   **优点**：确定性最高，所有环境安装的版本完全一致。
*   **缺点**：无法自动获取重要的安全补丁和 bug 修复。

#### **比较运算符**

*   `>1.2.3`：大于 `1.2.3`
*   `>=1.2.3`：大于等于 `1.2.3`
*   `<1.2.3`：小于 `1.2.3`
*   `<=1.2.3`：小于等于 `1.2.3`

#### **连字符范围（-）**

*   `"1.2.3 - 2.3.4"`：等同于 `>=1.2.3 <=2.3.4`。

#### **通配符 / X-Range**

*   `*` 或 `""`：匹配任何版本。
*   `1.x` 或 `1.*` 或 `1`：匹配主版本为 1 的任何版本，即 `>=1.0.0 <2.0.0`。
*   `1.2.x` 或 `1.2.*`：匹配主版本为 1，次版本为 2 的任何版本，即 `>=1.2.0 <1.3.0`。

#### **波浪符范围（~）—— 保持修订号级别**

**“允许修订号变更”**。它允许**修订号**（最后一位）递增，但会锁定**主版本**和**次版本**。

*   `~1.2.3`：`>=1.2.3 <1.3.0`
*   `~1.2`：`>=1.2.0 <1.3.0` (等同于 `1.2.x`)
*   `~1`：`>=1.0.0 <2.0.0` (等同于 `1.x`)
*   `~0.2.3`：`>=0.2.3 <0.3.0` (对于 `0.x.x` 版本要特别注意)
*   `~0.2`：`>=0.2.0 <0.3.0`
*   `~0`：`>=0.0.0 <1.0.0`

**使用场景**：当你想要自动获取 bug 修复和安全补丁，但又不想冒引入不兼容变更的风险时使用。这是**最常用、最安全**的策略之一。

#### **插入符范围（^）—— 保持主版本级别**

**“允许不破坏兼容的更新”**。它允许**次版本**和**修订号**（后两位）递增，但会锁定**主版本**。

*   `^1.2.3`：`>=1.2.3 <2.0.0`
*   `^0.2.3`：`>=0.2.3 <0.3.0` (对于 `0.x.x` 版本，因为它被认为是初始开发阶段，所以行为类似 `~`)
*   `^0.0.3`：`>=0.0.3 <0.0.4` (对于 `0.0.x`，它被锁定得非常严格)
*   `^1.2.x`：`>=1.2.0 <2.0.0`
*   `^0.0.x`：`>=0.0.0 <0.1.0`

**使用场景**：当你想要自动获取新功能和 bug 修复，且相信依赖库会严格遵守 SemVer 规范（即次版本更新不会破坏兼容性）时使用。这是 **`npm install --save` 的默认行为**。

---

### 4. Node.js 包管理器如何处理版本范围

当你运行 `npm install` 时，包管理器（npm、yarn、pnpm）会执行以下操作：

1.  解析 `package.json` 中所有的依赖声明。
2.  对于每个依赖，根据其版本范围描述，查找 **registry（如 npmjs.com）** 上满足条件的**最高版本**。
3.  下载并安装该版本，同时将**确切的版本号**写入 `package-lock.json`、`yarn.lock` 或 `pnpm-lock.yaml` 文件中。

**`package-lock.json` 的作用**：它记录了当前状态下所有依赖的**确切版本**，确保了团队成员和部署环境之间安装完全一致的依赖树，从而实现了“确定性安装”。**这个文件应该被提交到版本控制系统中。**

---

### 5. 特殊版本与标签

*   **`latest`**：默认标签，指向当前最新的稳定版。
*   **`next`**：预发布版本的常用标签。

---

### 6. 最佳实践总结

1.  **理解 `^` 和 `~`**：
    *   对**应用项目**，通常使用默认的 `^`，以自动获取新功能和修复。
    *   对**库项目**，可以考虑使用 `~` 或将依赖锁定为精确版本，以给使用者带来更稳定的体验。
2.  **始终提交锁文件**：确保 `package-lock.json` 等锁文件被提交，这是保证一致性的关键。
3.  **定期更新依赖**：使用 `npm outdated` 查看过时的包，并使用 `npm update` 或 `npm install package@latest` 进行更新。定期处理安全漏洞（`npm audit`）。
4.  **谨慎对待 `0.x.x` 版本**：`0.x.x` 版本的库被视为不稳定，它们的 `^` 和 `~` 行为可能不符合预期。
5.  **生产环境部署**：始终使用 `npm ci` 命令（而不是 `npm install`）在CI/CD和生产环境中安装依赖，因为它会严格依据锁文件安装，速度更快、更可靠。
