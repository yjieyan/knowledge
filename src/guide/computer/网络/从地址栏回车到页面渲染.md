# 从地址栏回车到页面渲染

整个过程可以分为两大阶段：**网络请求阶段** 和 **浏览器渲染阶段**。


### 第一阶段：网络请求阶段

这个阶段的目标是获取到页面的 HTML 资源。

#### 1. 用户输入 & UI 线程处理
用户在地址栏输入 `https://www.example.com` 并按下回车。
*   **浏览器 UI 线程** 会判断这是一个 URL 还是搜索查询。
*   如果是 URL，则会加上协议（如 `https://`）组装成完整的 URL。

#### 2. DNS 解析 (Domain Name System)
**目标**：将域名 `www.example.com` 解析为服务器的 IP 地址，如 `192.0.2.1`。

这是一个分层查询过程：
1.  **浏览器缓存**：浏览器首先检查自身缓存中是否有该域名的 IP。
2.  **操作系统缓存**：如果浏览器缓存没有，会调用操作系统（如 `gethostbyname`）查询本地的 **hosts 文件** 和系统缓存。
3.  **路由器缓存**：请求会发往路由器，检查路由器缓存。
4.  **ISP DNS 缓存**：请求到达互联网服务提供商（ISP）的 DNS 服务器，这里通常有大量缓存。
5.  **递归查询**：如果以上都没有，ISP 的 DNS 服务器会开始递归查询：
    *   从 **根域名服务器** 开始，询问 `.com` 域名的服务器地址。
    *   然后询问 **.com 顶级域名服务器**，询问 `example.com` 的权威域名服务器地址。
    *   最后询问 **`example.com` 的权威域名服务器**，获得 `www.example.com` 的 IP 地址。
*   **DNS 预解析**：现代浏览器会通过 `<link rel="dns-prefetch">` 或分析页面中的链接，提前进行 DNS 解析，以提升性能。

#### 3. TCP 连接 (Transmission Control Protocol)
**目标**：与服务器建立可靠的传输通道。通过 **三次握手** 建立连接。

1.  **SYN**：客户端发送一个 **SYN** (Synchronize Sequence Number) 包到服务器，表示请求建立连接。
2.  **SYN-ACK**：服务器收到后，回复一个 **SYN-ACK** (Acknowledgement) 包，表示同意建立连接。
3.  **ACK**：客户端再回复一个 **ACK** 包。至此，连接建立成功，可以开始传输数据。

**为什么是三次？** 主要是为了**防止已失效的连接请求报文突然又传到了服务器**，从而产生错误。

#### 4. TLS 握手 (Transport Layer Security) - 仅 HTTPS
**目标**：建立一个安全的加密通道。对于 HTTPS 连接，在 TCP 连接建立后，需要再进行 TLS 握手。

1.  **ClientHello**：客户端向服务器发送支持的 TLS 版本、加密套件列表、一个随机数。
2.  **ServerHello**：服务器选择 TLS 版本和加密套件，并发送自己的**数字证书**和一个随机数。
3.  **验证证书**：客户端验证证书的合法性（是否由可信机构颁发、域名是否匹配、是否在有效期内）。
4.  **Premaster Secret**：客户端验证通过后，会生成另一个随机数（预主密钥），用证书中的公钥加密后发送给服务器。
5.  **生成会话密钥**：服务器用私钥解密得到预主密钥。此时，客户端和服务器都拥有了三个随机数，它们各自使用相同的算法生成相同的**会话密钥**，用于后续通信的对称加密。
6.  **握手结束**：双方交换加密后的“Finished”消息，验证握手是否成功。

#### 5. HTTP 请求/响应 (HyperText Transfer Protocol)
**目标**：通过已建立的连接，获取页面资源。

1.  **发送 HTTP 请求**：浏览器组装一个 **HTTP 请求报文**。
    ```
    GET / HTTP/1.1
    Host: www.example.com
    User-Agent: Mozilla/5.0...
    Accept: text/html,application/xhtml+xml...
    ```
2.  **服务器处理请求**：服务器接收到请求，根据路径和头部信息，找到对应的资源（或由后端应用动态生成）。
3.  **返回 HTTP 响应**：服务器返回一个 **HTTP 响应报文**。
    ```
    HTTP/1.1 200 OK
    Content-Type: text/html; charset=utf-8
    Content-Length: 1234
    Cache-Control: public, max-age=3600

    <!DOCTYPE html><html>...（这里是HTML内容）
    ```
4.  **TCP 断开连接**：对于 HTTP/1.1，默认使用 `Connection: keep-alive`，连接会保持一段时间，以便后续请求复用，避免重复握手。最终数据传送完毕后，通过 **四次挥手** 断开 TCP 连接。

---

### 第二阶段：浏览器渲染阶段

这个阶段发生在 **浏览器的渲染进程** 中。渲染进程的主线程负责解析和渲染。

#### 1. 构建 DOM 树 (Document Object Model)
**目标**：将 HTML 文本转换为浏览器能理解的 DOM 树结构。

*   **过程**：
    1.  **转换**：浏览器读取原始的 HTML 字节数据，并将其转换为指定编码（如 UTF-8）的字符串。
    2.  **令牌化**：HTML 解析器将字符串解析成一系列的 **Tokens**（如 `<html>`, `<body>` 等开始和结束标签）。
    3.  **构建节点**：将这些 Tokens 转换为 **Node** 对象。
    4.  **构建 DOM 树**：根据节点的父子关系，构建出一棵 **树形结构** 的 DOM。
*   **关键点**：
    *   解析过程是 **自上而下** 的。
    *   当遇到 `<script>` 标签（没有 `async/defer` 属性）时，**会停止 HTML 解析**，先下载并执行 JavaScript。因为 JS 可能会修改 DOM 结构。

#### 2. 构建 CSSOM 树 (CSS Object Model)
**目标**：将 CSS 样式表转换为浏览器能理解的 CSSOM 树。

*   **过程**：与 DOM 构建类似，也是从字节 -> 字符串 -> Tokens -> Nodes -> CSSOM。
*   **关键点**：
    *   CSS 解析是 **渲染阻塞** 的。浏览器必须拥有完整的 CSSOM 才能进入渲染树构建阶段，因为 CSS 规则可以相互覆盖和继承（层叠规则）。
    *   CSSOM 具有 **层级结构**，子节点会继承父节点的样式。

#### 3. 执行 JavaScript
*   如上所述，**同步的 `<script>` 标签会阻塞 DOM 构建**。
*   如果 JavaScript 试图访问尚未被解析的 DOM 元素，或者尚未构建完成的 CSSOM，可能会出错。
*   使用 `async` 或 `defer` 属性的脚本可以异步加载和执行，不阻塞解析。

#### 4. 构建渲染树 (Render Tree)
**目标**：将 DOM 和 CSSOM 合并，确定哪些元素需要被渲染以及如何渲染。

*   **过程**：渲染进程遍历 DOM 树，将 **可见的节点** 及其计算后的样式添加到渲染树中。
*   **关键点**：
    *   **不可见元素不会被包含**，例如 `display: none` 的元素。而 `visibility: hidden` 的元素仍会占据空间，所以会被包含。
    *   渲染树只包含与视觉相关的节点。

#### 5. 布局 / 重排 (Layout / Reflow)
**目标**：计算渲染树中每个节点的精确位置和大小（几何信息）。

*   **过程**：渲染进程从渲染树的根节点开始遍历，计算每个节点在视口（viewport）内的坐标。这个过程输出一棵 **布局树 (Layout Tree)**。
*   **输出**：一个详细的“蓝图”，记录了每个元素的 `x, y` 坐标和 `width, height` 尺寸。
*   **性能影响**：这是非常消耗性能的一步。任何可能改变元素几何属性的操作（如改变窗口大小、修改元素的宽高/位置）都会触发 **重排**，而重排必定会触发后续的 **重绘**。

#### 6. 绘制 / 栅格化 (Paint / Raster)
**目标**：将布局树转换为屏幕上的实际像素。

*   **过程**：
    1.  **绘制 (Paint)**：主线程遍历布局树，生成 **绘制记录 (Paint Records)**。这不是一个一个像素地画，而是一个指令列表，类似于“先画背景，再画边框，再画文本...”。
    2.  **分层 (Layerize)**：为了提升性能，主线程会将页面拆分为多个**图层 (Layers)**。某些特定的 CSS 属性（如 `will-change`、`transform`、`opacity`）会提示浏览器将其提升到独立的合成层。
    3.  **栅格化 (Raster)**：**合成线程** 将每个图层分解为多个**图块 (Tiles)**，然后将图块交由 **栅格化线程** 处理。栅格化线程使用 **GPU** 将图块转换为**位图**，并存储在 GPU 内存中。这个过程速度极快。

#### 7. 合成与显示 (Composite & Display)
**目标**：将各个图层合成为最终的页面图像并显示在屏幕上。

*   **过程**：
    1.  当所有图块都被光栅化后，**合成线程** 会收集称为 **绘制四边形 (Draw Quads)** 的信息（描述了图块在内存中的位置、在页面中的位置等）。
    2.  合成线程将这些信息组合成一个 **合成器帧 (Compositor Frame)**。
    3.  该帧通过 **IPC** 提交给浏览器进程。
    4.  浏览器进程将帧发送给 **GPU**，最终由 GPU 渲染到屏幕上。

---

### 总结与性能启示

从地址栏回车到页面渲染是一个复杂的系统工程，涉及 **网络、操作系统、浏览器内核** 等多个领域的知识。理解这个过程，我们可以得出以下关键的 **性能优化方向**：

1.  **网络层面**：DNS 预解析、减少 HTTP 请求（合并文件、雪碧图）、使用 HTTP/2、开启 Gzip 压缩、利用 CDN 和缓存。
2.  **渲染层面**：
    *   **优化关键渲染路径**：优先加载关键 CSS（内联）、异步加载非关键 CSS 和 JS（`async/defer`）。
    *   **避免强制同步布局**：不要在循环中先读样式再写样式。
    *   **减少重绘与重排**：使用 `transform` 和 `opacity` 来实现动画，它们由合成线程处理，不触发布局和绘制。
    *   **利用合成层**：对复杂动画使用 `will-change: transform;` 提升到单独图层。