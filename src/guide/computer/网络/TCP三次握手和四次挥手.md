# TCP三次握手和四次挥手
---

### 第一部分：TCP三次握手 - 建立连接

三次握手的目的是为了**建立一个双向的、可靠的TCP连接**。它确保了客户端和服务器都具备发送和接收数据的能力。

#### 详细过程

假设客户端（Client）想要与服务器（Server）建立连接。

1.  **第一次握手：SYN**
    *   **动作：** 客户端发送一个TCP报文段。
    *   **标志位：** 设置 `SYN = 1`。
    *   **序列号：** 客户端随机生成一个初始序列号 `seq = x`。
    *   **目的：** 客户端告诉服务器：“我想和你建立连接。我的初始序列号是 `x`。”
    *   **此时客户端状态：** 进入 `SYN-SENT` 状态。

2.  **第二次握手：SYN-ACK**
    *   **动作：** 服务器收到客户端的SYN报文后，如果同意连接，则回复一个报文段。
    *   **标志位：** 设置 `SYN = 1`, `ACK = 1`。
    *   **序列号：** 服务器随机生成自己的初始序列号 `seq = y`。
    *   **确认号：** `ack = x + 1`。 (表示期望收到客户端的下一个序列号，同时也确认了收到了客户端的 `seq=x`)
    *   **目的：** 服务器告诉客户端：“我收到你的连接请求了，我同意建立连接。我的初始序列号是 `y`，请确认。”
    *   **此时服务器状态：** 进入 `SYN-RCVD` 状态。

3.  **第三次握手：ACK**
    *   **动作：** 客户端收到服务器的SYN-ACK报文后，需要再次确认。
    *   **标志位：** 设置 `ACK = 1`。
    *   **序列号：** `seq = x + 1`。（因为第一次握手的SYN包消耗了一个序列号）
    *   **确认号：** `ack = y + 1`。（表示期望收到服务器的下一个序列号，同时也确认了收到了服务器的 `seq=y`）
    *   **目的：** 客户端告诉服务器：“我收到你的确认了，我们现在可以开始传输数据了。”
    *   **此时连接状态：** 服务器收到这个ACK报文后，也进入 `ESTABLISHED` 状态。至此，连接建立成功，双方可以开始数据传输。

#### 为什么是三次，而不是两次？
核心原因是**为了防止已失效的连接请求报文突然又传送到服务器，因而产生错误**。

**场景模拟：**
假设客户端发送了一个连接请求报文A，但这个报文在网络中滞留了（因为网络拥堵），客户端超时后重传了请求报文B，并与服务器正常完成了通信，关闭了连接。此时，那个失效的报文A终于到达了服务器。

*   **如果是两次握手：** 服务器收到失效的报文A，会误以为客户端又发起了新连接，于是回复SYN-ACK并进入 `ESTABLISHED` 状态，开始等待客户端发送数据。但客户端此时并没有意图建立新连接，不会理会这个确认，也不会发送数据。这就导致了：
    1.  **服务器空等**，浪费了服务器资源。
    2.  如果这种情况频繁发生，服务器可能因维护大量半开连接而耗尽资源，这被称为 **SYN Flood攻击** 的雏形。

*   **三次握手如何解决：** 在三次握手的机制下，服务器收到失效的报文A后，会回复SYN-ACK并进入 `SYN-RCVD` 状态，但它需要等待客户端的第三次ACK。由于客户端没有发起新连接，它不会发送这个ACK，因此服务器在等待超时后，会关闭这个半连接，回收资源。**第三次握手是客户端对服务器连接意图的最终确认，避免了服务器的资源浪费。**

---

### 第二部分：TCP四次挥手 - 断开连接

四次挥手的目的是为了**安全、可靠地关闭一个双向的TCP连接**。由于TCP连接是全双工的，每个方向都必须单独进行关闭。

#### 详细过程

假设客户端主动发起关闭连接。

1.  **第一次挥手：FIN**
    *   **动作：** 客户端发送一个TCP报文段。
    *   **标志位：** 设置 `FIN = 1`。
    *   **序列号：** `seq = u`（一个特定的序列号）。
    *   **目的：** 客户端告诉服务器：“我这边没有数据要发送了，我想关闭从客户端到服务器这个方向上的连接。”（即客户端不再发送数据，但还可以接收数据）
    *   **此时客户端状态：** 进入 `FIN-WAIT-1` 状态。

2.  **第二次挥手：ACK**
    *   **动作：** 服务器收到客户端的FIN报文后，立即回复一个确认报文。
    *   **标志位：** 设置 `ACK = 1`。
    *   **序列号：** `seq = v`。
    *   **确认号：** `ack = u + 1`。
    *   **目的：** 服务器告诉客户端：“我收到你的关闭请求了。”
    *   **此时状态：**
        *   客户端进入 `FIN-WAIT-2` 状态。
        *   服务器进入 `CLOSE-WAIT` 状态。此时，从客户端到服务器的连接已经关闭，但**从服务器到客户端的连接仍然存在**，服务器可能还有数据需要发送给客户端。这是一个**半关闭**状态。

3.  **第三次挥手：FIN**
    *   **动作：** 当服务器也完成了所有数据的发送后，它会发送一个FIN报文。
    *   **标志位：** 设置 `FIN = 1`。
    *   **序列号：** `seq = w`（注意，这个序列号可能与 `v` 不同，因为中间可能发送了数据）。
    *   **确认号：** `ack = u + 1`。（仍然确认客户端的初始FIN）
    *   **目的：** 服务器告诉客户端：“我这边也没有数据要发送了，我也要关闭连接了。”
    *   **此时服务器状态：** 进入 `LAST-ACK` 状态。

4.  **第四次挥手：ACK**
    *   **动作：** 客户端收到服务器的FIN报文后，发送一个确认报文。
    *   **标志位：** 设置 `ACK = 1`。
    *   **序列号：** `seq = u + 1`。
    *   **确认号：** `ack = w + 1`。
    *   **目的：** 客户端告诉服务器：“我收到你的关闭请求了。”
    *   **此时状态：**
        *   客户端进入 `TIME-WAIT` 状态，并等待 **2MSL** 的时间后，才进入 `CLOSED` 状态。
        *   服务器收到这个ACK后，立即进入 `CLOSED` 状态。

#### 为什么是四次挥手？

因为TCP连接是**全双工**的，关闭时需要两个方向独立进行。
*   当客户端发送FIN时，只表示它不再发送数据，但还可以接收数据。
*   服务器收到FIN后，可能还有数据需要处理和发送，所以它先回复一个ACK，确认客户端的关闭请求。等所有数据发送完毕后，服务器再发送自己的FIN，来关闭自己这个方向的连接。
*   因此，中间的两次挥手（ACK和FIN）**在大多数情况下不能合并**，这就导致了需要四次挥手。

#### 为什么客户端需要TIME-WAIT状态？等待2MSL？

`TIME-WAIT` 状态有两个至关重要的目的：

1.  **可靠地终止TCP连接：** 确保最后一个ACK能够到达服务器。
    *   如果客户端发送的最后一个ACK在网络中丢失，服务器会超时重传它的FIN报文。
    *   如果客户端没有维护 `TIME-WAIT` 状态而直接关闭，那么当收到重传的FIN时，它会回复一个RST报文，这会被服务器解释为一个错误。
    *   在 `TIME-WAIT` 状态下，客户端可以收到这个重传的FIN，并重新发送ACK，从而保证连接能正常关闭。

2.  **让旧的重复报文在网络中消逝：** 防止之前连接的延迟报文被新连接误接收。
    *   一个连接关闭后，可能还有属于这个连接的、在网络中滞留的报文段。
    *   `TIME-WAIT` 状态等待 **2MSL**，可以确保在创建新的同名连接（相同IP和端口）之前，所有属于旧连接的报文都已经从网络中消逝，避免了数据混淆。

**MSL** 是“最大报文段生存时间”，任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。`2MSL` 是报文来回的最大时间。

---

### 总结与类比

*   **三次握手：** 像两个人打电话。
    *   A：“喂，听得到吗？” (SYN)
    *   B：“听得到，你呢？” (SYN-ACK)
    *   A：“我也听得到，我们开始说吧。” (ACK) -> **通话建立**

*   **四次挥手：** 像两个人结束通话。
    *   A：“我说完了，要挂电话了。” (FIN)
    *   B：“好的，我知道你说完了。” (ACK) -> **A到B的通道关闭，B可能还有话说**
    *   B：“我也说完了，可以挂电话了。” (FIN)
    *   A：“好的，拜拜。” (ACK) -> **B到A的通道关闭，A等待一下确保B听到再见**
