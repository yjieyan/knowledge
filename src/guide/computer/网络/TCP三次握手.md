
---

### 一、 TCP 三次握手 (Three-way Handshake)

**目标**：在客户端和服务器之间建立一个可靠的、全双工的 TCP 连接，并同步双方的初始序列号。

**过程**（假设客户端主动打开连接）：

1.  **第一次握手 (SYN=1, seq=x)**
    *   **客户端 -> 服务器**：客户端发送一个 TCP 报文段，其中：
        *   `SYN` 标志位设置为 1，表示这是一个**连接请求**报文。
        *   随机生成一个初始序列号 `seq = x`（ISN）。
    *   **客户端状态**：从 `CLOSED` 进入 `SYN-SENT`。

2.  **第二次握手 (SYN=1, ACK=1, seq=y, ack=x+1)**
    *   **服务器 -> 客户端**：服务器收到 SYN 报文后，如果同意连接，则回复一个报文段，其中：
        *   `SYN` 和 `ACK` 标志位都设置为 1。`SYN=1` 表示这也是一个**连接请求**，`ACK=1` 表示这是一个**确认报文**。
        *   随机生成服务器端的初始序列号 `seq = y`。
        *   确认号 `ack = x + 1`，表示“我收到了你的序列号为 `x` 的报文，我期望你下一个报文的序列号是 `x+1`”。
    *   **服务器状态**：从 `LISTEN` 进入 `SYN-RCVD`。

3.  **第三次握手 (ACK=1, seq=x+1, ack=y+1)**
    *   **客户端 -> 服务器**：客户端收到服务器的 SYN-ACK 报文后，会再次发送一个确认报文，其中：
        *   `ACK` 标志位设置为 1。
        *   序列号 `seq = x + 1`（因为第一次握手消耗了一个序列号）。
        *   确认号 `ack = y + 1`，表示“我收到了你的序列号为 `y` 的报文，我期望你下一个报文的序列号是 `y+1`”。
    *   **连接状态**：
        *   **客户端状态**：从 `SYN-SENT` 进入 `ESTABLISHED`。
        *   **服务器状态**：收到此报文后，从 `SYN-RCVD` 进入 `ESTABLISHED`。

至此，连接建立成功，双方可以开始传输数据。

#### **为什么是三次，而不是两次？**

**核心原因：为了防止“已失效的连接请求报文”突然又传到了服务器，从而产生错误。**

**情景模拟：**
假设客户端发送了一个连接请求报文 A，但这个报文在网络中滞留了（因为网络拥堵），导致客户端超时重传了一个新的连接请求报文 B。报文 B 顺利到达，服务器确认，连接建立，数据传输完毕后连接关闭。

此时，那个滞留在网络中的旧报文 A 终于到达了服务器。服务器会认为这是一个新的连接请求，于是回复 SYN-ACK。如果只有两次握手：

*   服务器只要收到 SYN 并回复了 SYN-ACK，就认为连接已建立，会一直维持这个连接等待客户端发送数据。
*   但客户端根本没有发起这个新连接（它认为是旧的、已处理的请求），所以会忽略服务器的 SYN-ACK，也不会发送数据。
*   结果：**服务器会白白浪费资源，空等一个永远不会发送数据的客户端。** 这可能导致服务器因大量这种无效连接而瘫痪。

**使用三次握手如何解决：**
在两次握手的基础上，客户端需要再发送一次确认。对于那个失效的报文 A，服务器回复 SYN-ACK 后，**客户端不会向它发送第三次握手的 ACK**，因此服务器收不到确认，经过一段时间后会自动关闭这个半连接，不会一直等待。

**总结三次握手的目的：**
1.  **确认双方的发送和接收能力正常**。
2.  **同步双方的初始序列号**，为可靠传输做准备。
3.  **防止旧的重复连接初始化造成混乱**。

---

### 二、 TCP 四次挥手 (Four-way Wavehand)

**目标**：安全、可靠地关闭一个 TCP 连接。由于 TCP 连接是**全双工**的，每个方向必须单独关闭。

**过程**（假设客户端主动关闭连接）：

1.  **第一次挥手 (FIN=1, seq=u)**
    *   **客户端 -> 服务器**：客户端发送一个 TCP 报文段，其中 `FIN` 标志位设置为 1，并指定一个序列号 `seq = u`（等于客户端已传送数据的最后一个字节的序列号加 1）。
    *   **客户端状态**：从 `ESTABLISHED` 进入 `FIN-WAIT-1`。这表示客户端没有数据要发送了。

2.  **第二次挥手 (ACK=1, seq=v, ack=u+1)**
    *   **服务器 -> 客户端**：服务器收到 FIN 报文后，发送一个确认报文，其中 `ACK=1`，确认号 `ack = u + 1`，序列号 `seq = v`。
    *   **服务器状态**：从 `ESTABLISHED` 进入 `CLOSE-WAIT`。
    *   **客户端状态**：收到这个 ACK 后，从 `FIN-WAIT-1` 进入 `FIN-WAIT-2`。
    *   **此时状态**：**TCP 连接处于半关闭状态**。客户端到服务器的方向已经关闭，客户端不再发送数据，但服务器可能还有数据要发送给客户端，客户端也必须接收。

3.  **第三次挥手 (FIN=1, ACK=1, seq=w, ack=u+1)**
    *   **服务器 -> 客户端**：当服务器也没有数据要发送时，它会发送自己的 FIN 报文，其中 `FIN=1`，`ACK=1`，序列号 `seq = w`（服务器可能在上次确认后又发送了一些数据），确认号 `ack` 仍然是 `u+1`。
    *   **服务器状态**：从 `CLOSE-WAIT` 进入 `LAST-ACK`。

4.  **第四次挥手 (ACK=1, seq=u+1, ack=w+1)**
    *   **客户端 -> 服务器**：客户端收到服务器的 FIN 报文后，必须发出确认报文，其中 `ACK=1`，确认号 `ack = w + 1`，序列号 `seq = u + 1`。
    *   **客户端状态**：从 `FIN-WAIT-2` 进入 `TIME-WAIT`。客户端会等待 `2MSL` 时间。
    *   **服务器状态**：服务器收到这个 ACK 后，就进入 `CLOSED` 状态。

#### **为什么需要四次挥手？**

因为 TCP 是全双工的，关闭连接需要两个独立的单向连接的关闭。
*   第一次和第二次挥手：关闭了从 **客户端 -> 服务器** 的连接。
*   第三次和第四次挥手：关闭了从 **服务器 -> 客户端** 的连接。

在第二次和第三次挥手之间，服务器可能还在发送未传完的数据，因此不能将第二、三次挥手合并。

---

### 三、 为什么是 2MSL？

**MSL** 是 **Maximum Segment Lifetime**（报文最大生存时间）。它是任何 TCP 报文在网络中被丢弃前能存在的最长时间。这个时间是有限的，因为网络是由 TTL (Time To Live) 限制的。

当客户端发送完第四次挥手的 ACK 后，它需要进入 `TIME-WAIT` 状态，并等待 `2MSL` 的时间。

**两个主要原因：**

1.  **可靠地实现全双工连接的终止**
    *   第四次挥手的 ACK 报文有可能丢失。如果丢失，服务器在 `LAST-ACK` 状态下会因为超时而**重传**它的 FIN 报文。
    *   如果客户端不等待 `2MSL` 而直接关闭，那么当服务器重传 FIN 时，客户端会回复一个 `RST`（复位）报文，这会被服务器解释为一个错误。
    *   客户端等待 `2MSL`，可以确保如果 ACK 丢失，它有能力**再次收到服务器的 FIN 报文并重发 ACK**。这样就能让服务器正常地进入 `CLOSED` 状态。

2.  **让旧的重复报文在网络中消逝**
    *   在 `2MSL` 的等待时间内，这个连接（由双方 IP 和端口号定义）产生的所有报文都会从网络中消逝。
    *   这样，当同一个四元组（客户端IP、端口，服务器IP、端口）建立**新的连接**时，就不会受到之前连接滞留在网络中的旧报文的干扰。这避免了新旧连接数据混淆的问题。

**`TIME-WAIT` 状态的影响：**
*   主动关闭连接的一方会保持 `TIME-WAIT` 状态。
*   在高性能服务器上，如果服务器主动关闭大量短连接，会导致大量连接处于 `TIME-WAIT` 状态，消耗系统资源（如端口号）。
*   解决方案：可以通过调整内核参数（如 `net.ipv4.tcp_tw_reuse`）或让客户端（而非服务器）主动关闭连接来缓解。

### 总结

面试官，总结一下：

*   **三次握手**：为了**同步序列号、确认双方能力、防止失效请求**。少一次无法防止资源浪费，多一次则没有必要。
*   **四次挥手**：因为 TCP 是**全双工**的，每个方向的连接需要独立关闭。服务器在收到客户端的 FIN 后，可能还有数据要发送，所以不能立即回复 FIN。
*   **2MSL**：为了**确保最后一个 ACK 能到达对方**，并**让旧连接的报文在网络中消逝**，从而可靠地关闭连接并为新连接提供一个干净的网络环境。