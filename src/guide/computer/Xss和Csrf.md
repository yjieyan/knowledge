# Xss和Csrf

---

### **第一部分：XSS（跨站脚本攻击）**

#### **1. 核心原理**

XSS 的本质是：**攻击者利用网站对用户输入过滤不严的漏洞，将恶意脚本注入到网页中，使其他用户在浏览该网页时执行这些脚本。**

简单来说，就是 **“恶意脚本”** 被当作 **“正常数据”** 混入了网页。

#### **2. 攻击类型详解**

XSS 主要分为三类，理解它们的区别对于防范至关重要。

| 类型 | 存储型（持久型） | 反射型（非持久型） | DOM 型 |
| :--- | :--- | :--- | :--- |
| **恶意脚本存储位置** | **服务器数据库** | **URL** | **URL** |
| **触发方式** | 受害者浏览**正常页面** | 受害者**点击特定恶意链接** | 受害者**点击特定恶意链接** |
| **是否经过服务器** | **是**（从数据库读出） | **是**（服务器返回含脚本的页面） | **否**（纯前端漏洞） |
| **危害程度** | 高 | 中 | 中 |

**深入分析：**

*   **存储型 XSS**：
    1.  **攻击路径**：攻击者提交一条含恶意脚本的评论/昵称 -> 服务器**保存**到数据库 -> 普通用户访问查看评论的页面 -> 服务器从数据库取出评论并返回给浏览器 -> 浏览器**执行**了评论中的恶意脚本。
    2.  **场景**：论坛发帖、用户评论、用户昵称等所有用户输入并会被其他用户看到的地方。

*   **反射型 XSS**：
    1.  **攻击路径**：攻击者构造一个含恶意脚本的URL（如 `https://victim.com/search?keyword=<script>alert('xss')</script>`） -> 诱骗用户点击 -> 服务器收到请求，将 `keyword` 参数值直接拼接到HTML中返回 -> 用户的浏览器执行了返回页面中的恶意脚本。
    2.  **场景**：搜索框、错误信息页面等将用户输入直接输出到页面的地方。

*   **DOM 型 XSS**：
    1.  **攻击路径**：攻击者构造一个含恶意参数的URL（如 `https://victim.com#<img src=x onerror=alert('xss')>`） -> 诱骗用户点击 -> 用户的浏览器接收到响应，**前端 JavaScript 代码（如 `location.hash` 或 `document.write`）直接操作 DOM，将恶意参数插入到了页面中** -> 导致脚本执行。
    2.  **关键区别**：整个过程**不经过服务器**，是前端 JavaScript 代码的不安全操作导致的。

#### **3. XSS 的防范措施**

防范 XSS 的核心思想是：**永远不要信任用户输入，对所有用户输入进行“消毒”。**

1.  **输入过滤 vs 输出转义**
    *   **输入过滤**：在用户提交数据时进行过滤。这很好，但**不能完全依赖**，因为数据可能在多个地方使用，转义规则不同。
    *   **输出转义（核心手段）**：在将数据输出到不同上下文时，进行特定的转义。
        *   **HTML 上下文**：将 `<, >, &, ", '` 等字符转义为 HTML 实体（如 `<` -> `&lt;`）。这样，`<script>` 就会被显示为文本，而不是被当作标签解析。
        *   **JavaScript 上下文**：不能只用 `escapeHtml`，需要用 `\` 对特殊字符进行转义，或者更安全地，避免将用户输入直接嵌入到 `<script>` 标签中。
        *   **URL 上下文**：使用 `encodeURIComponent` 对参数进行编码。
        *   **现代前端框架（如 React, Vue, Angular）默认已经提供了 XSS 防护**，它们会在渲染动态内容时自动进行转义。但要注意使用 `v-html`/`dangerouslySetInnerHTML` 等 API 时的风险。

2.  **内容安全策略（CSP）**
    CSP 是一个**深度防御**的利器。它通过 HTTP 头 `Content-Security-Policy` 告诉浏览器只允许加载和执行来自哪些源的脚本、样式、图片等。
    *   **示例**：`Content-Security-Policy: default-src 'self'; script-src 'self' https://trusted.cdn.com;`
    *   **作用**：即使网站被注入了恶意脚本，只要该脚本的来源不在白名单内，浏览器就会**拒绝执行**它。
    *   **还能禁止内联脚本**（如 `onclick` 事件），从根本上杜绝大部分 XSS。

3.  **使用 HttpOnly Cookie**
    为敏感的 Cookie 设置 `HttpOnly` 属性。这样，JavaScript（包括恶意脚本）就无法通过 `document.cookie` 读取到这个 Cookie，从而防止攻击者窃取用户会话。

---

### **第二部分：CSRF（跨站请求伪造）**

#### **1. 核心原理**

CSRF 的本质是：**攻击者利用用户已登录的身份，在用户不知情的情况下，以用户的名义执行非本意的操作。**

简单来说，就是 **“借用”** 了用户的**身份和权限**，但 **“绕过”** 了前端逻辑。

#### **2. 攻击流程详解**

假设用户已经登录了银行网站 `bank.com`，并且会话 Cookie 仍然有效。

1.  用户被诱骗访问了攻击者的网站 `evil.com`。
2.  `evil.com` 的页面上隐藏着一个自动提交的表单（或一个 `img` 标签的 `src` 请求）：
    ```html
    <!-- 表单方式 -->
    <form action="https://bank.com/transfer" method="POST">
      <input type="hidden" name="to" value="attacker">
      <input type="hidden" name="amount" value="1000">
    </form>
    <script>document.forms[0].submit();</script>

    <!-- 图片方式 (GET请求) -->
    <img src="https://bank.com/transfer?to=attacker&amount=1000">
    ```
3.  浏览器在发送请求到 `bank.com` 时，会**自动携带**该域名下的登录 Cookie。
4.  服务器收到请求，验证 Cookie 有效，便认为是用户本人的合法操作，于是执行了转账。
5.  攻击完成，用户可能完全不知情。

#### **3. CSRF 的防范措施**

防范 CSRF 的核心思想是：**确保请求来自用户自愿操作且可信的前端页面，而不是第三方网站发起的。**

1.  **同源策略（SOP）的误区**
    首先要明确：**同源策略（SOP）不能防范 CSRF**。SOP 限制的是不同源的页面之间如何**读取**对方的资源，而 CSRF 是浏览器在**发送**请求时自动携带了 Cookie， SOP 并不禁止这种“发送”行为。

2.  **Anti-CSRF Token（最有效、最主流的方法）**
    *   **原理**：在表单或请求中，加入一个**随机的、不可预测的 Token**。这个 Token 由服务器生成，并在用户会话中存一份。当用户提交请求时，服务器会验证这个 Token 是否匹配。
    *   **为何有效**：攻击者的网站 `evil.com` 无法通过 JavaScript **读取**到用户页面中的 Token（因为 SOP 的限制），因此无法构造出合法的请求。

3.  **SameSite Cookie 属性**
    这是一个非常优雅的解决方案，从浏览器层面解决 CSRF。
    *   `SameSite=Strict`：严格模式，完全禁止第三方 Cookie。从 `evil.com` 发起的对 `bank.com` 的请求，不会发送 Cookie。
    *   `SameSite=Lax`：（默认值）宽松模式，大多数跨站请求不发送 Cookie，但一些安全的顶级导航（如 `<a>` 链接）会发送。
    *   `SameSite=None`：关闭 SameSite，但必须同时设置 `Secure` 属性（仅限 HTTPS）。

4.  **验证 Referer/Origin 头**
    检查 HTTP 请求头中的 `Referer` 或 `Origin` 字段，看请求是否来自合法的源（自己的网站）。但这种方法可能因隐私设置或浏览器兼容性问题而不可靠，通常作为辅助手段。

---

### **第三部分：XSS 与 CSRF 的对比与关联**

| 特性 | XSS | CSRF |
| :--- | :--- | :--- |
| **全称** | 跨站脚本攻击 | 跨站请求伪造 |
| **核心问题** | **内容注入**与**脚本执行** | **身份借用**与**权限滥用** |
| **攻击目标** | 获取用户数据（如 Cookie）、进行恶意操作 | 以用户名义执行特定操作（如转账、改密码） |
| **所需条件** | 网站存在输入漏洞 | 用户已登录目标网站 |
| **依赖同源策略** | **绕过/利用** 同源策略 | **依赖** 同源策略的“发送Cookie”行为 |
| **关联性** | **XSS 可以导致更严重的 CSRF**。如果网站存在 XSS，攻击者可以直接在页面内获取到 Anti-CSRF Token，从而使 CSRF 防护失效。 |

### **总结与扩展**

*   **防范 XSS**：记住 **“消毒”**（转义）、**CSP** 和 **HttpOnly Cookie**。
*   **防范 CSRF**：记住 **“Token”** 和 **“SameSite Cookie”**。
*   **安全是纵深防御**：没有一种方法是万能的。应该结合多种措施，在应用的各个层面（前端、后端、网络传输、浏览器）进行防护。
*   **现代框架的帮助**：React/Vue 等框架的默认转义、以及像 `axios` 这样的库自动携带 CSRF Token 的机制，都大大降低了开发者的安全负担，但理解其底层原理依然至关重要。