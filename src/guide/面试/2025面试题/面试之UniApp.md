# UniApp相关问题

#### uniapp调⽤⽀付
| 环节 | 核心任务 | 关键点 |
| :--- | :--- | :--- |
| **🛠️ 前置配置** | 获取商户资质、配置AppID等 | 微信/支付宝商户平台申请；在 `manifest.json` 中配置 AppID  |
| **⚙️ 服务端工作** | 创建订单、生成支付参数 | 调用支付平台API（如微信统一下单）；返回 `timeStamp`, `nonceStr`, `package`, `signType`, `paySign` 等参数  |
| **📱 前端调用** | 调用 `uni.requestPayment` | 注意：**所有支付参数应由服务端生成并返回，前端仅负责调用**，严禁硬编码  |
| **✅ 结果处理** | 验证支付结果、处理业务 | 依赖服务端异步通知 (`notify_url`) 进行最终结果确认  |


**多端适配说明**：

- **支付宝小程序**：将 `provider` 设置为 `'alipay'`，并且支付参数通常统一放在 `orderInfo` 字段中（字符串形式）。
- **App端**：无论是微信还是支付宝支付，都必须在调用 `uni.requestPayment` 时通过 `provider` 参数指定支付提供商 。此外，App端还需要进行额外的SDK配置，例如iOS需要配置Universal Links 。


1.  **参数格式与大小写**：支付参数（如 `timeStamp`, `nonceStr`, `package`）的**键名和大小写必须严格遵循平台要求**，否则会导致签名失败 。
2.  **金额单位**：在传递给服务端和支付平台时，所有金额均以**分**为单位，这是为了避免浮点数运算可能带来的精度问题 。
3.  **签名验证**：签名是支付安全的核心。**签名操作必须放在服务端完成**，绝对不要在前端暴露商户密钥或进行签名计算 。
4.  **支付结果验证**：前端 `success` 回调仅表示支付界面顺利调起并完成操作，**支付是否成功的最终判断必须依据服务端收到的异步通知** 。

#### uni-app跨端原理

**在统一的Vue.js语法规范下，通过编译时的代码转换和运行时的环境适配，将一套代码巧妙地映射到多个平台**

| 核心层面 | 核心任务 | 关键实现方式 |
| :--- | :--- | :--- |
| **🔤 语法规范统一** | 统一开发语言与接口 | 采用Vue.js作为开发规范；封装**跨端组件**与**uni.xxx API**。 |
| **🛠️ 编译时转换** | 将统一代码转换为各平台特定代码 | 通过**条件编译**处理平台差异；将Vue组件拆解为各平台所需的文件。 |
| **⚙️ 运行时适配** | 在不同平台环境中执行与渲染 | 小程序端使用**小程序版的Vue runtime**；App端通过**Webview渲染或原生(NVUE)渲染**；H5端直接运行于浏览器。 |

- 语法规范统一

    **Vue.js开发规范**：每个页面都是一个标准的`.vue`文件，数据绑定与事件处理也完全遵循Vue.js的规范。
    **跨端组件与API**：uni-app提供了一系列内置组件（如`<view>`, `<text>`）和以`uni.`为前缀的API（如`uni.request`）。这些组件和API在不同平台会被转换为对应平台的原生组件和API，无需关心底层的差异。

- 编译时转换

    **核心转换机制**：编译器会将你的Vue组件拆解并转换成目标平台所需的格式。
    **条件编译**：为了解决不同平台间的特色功能或细微差异，uni-app提供了**条件编译**。
    通过特殊的注释语法（如`#ifdef MP-WEIXIN`）实现平台的个性化定制。

- 运行时适配
    **小程序端**：uni-app的Runtime主要是一个小程序版的**Vue runtime**。它将Vue的数据响应式、生命周期、组件系统等映射到小程序的环境中，使得Vue的语法能够在小程序中正确运行。
    **App端**：App端的Runtime相对复杂，提供了两种渲染引擎：

    - **Webview渲染**：默认的渲染方式，适用于大多数常规页面。它的原理与小程序类似，渲染速度快，且支持完整的Vue语法。
    - **原生渲染（NVUE）**：对于性能要求极高的场景（如长列表、复杂动画），可以使用NVUE页面。NVUE的编译产物基于Weex引擎，能够直接调用原生组件进行渲染，从而带来接近原生的流畅体验。
    uni-app支持在同一个项目中混合使用Vue页面和NVUE页面。
  
    **H5端**：H5端的Runtime可以理解为在标准Vue项目的基础上，补充了uni-app的组件库、路由框架和`uni`对象。它直接运行在浏览器环境中，因此可以使用绝大部分浏览器特性。

- 架构特点与注意事项

    **逻辑层与渲染层分离**：在**小程序和App端**，uni-app的架构是逻辑层（JavaScript）与渲染层（视图）分离的。
    这种设计的好处是JavaScript运算不会阻塞视图渲染，使得页面动画更加流畅。
    但代价是两层之间通信会有一定的损耗，在需要高频交互（如连续滚动、跟手操作）的场景下，可能会感到不跟手。
    为此，uni-app提供了**WXS**（微信小程序）和**RenderJS**（App端）等技术，允许在视图层直接执行一些逻辑，以规避通信损耗。
    **数据更新差异**：在**App-vue页面和小程序**中，数据更新是**页面级别**的。
    这意味着如果页面中某个局部数据变化，可能会引起整个页面数据的比较和更新。
    因此，**将频繁更新的复杂区域封装成组件**是非常重要的优化手段，这样可以实现组件级别的差量更新。
    而App-nvue和H5则无此限制。

#### Uni-app分包策略
- 背景
    微信小程序之所以需要分包，主要是为了解决小程序官方限制了主包体积和总体积大小，整个小程序所有分包大小不能超过20M，单个分包体积不能超过2M。
- 核心思路
    将代码划分成不同的包，打开⼀个包中的某个 ⻚⾯，才加载这个包的代码。优化⼩程序⾸次启动的下载时间。
    主包：默认启动⻚⾯/TabBar(标签)⻚⾯，以及⼀些所有分包需要⽤到的公共资源/JS脚本
    分包：根据开发者的配置进⾏划分
    a. 使⽤ subpackages 进⾏分包路径声明 ，subpackages 配置路径外的⽬录会被打包到主包中
    b. tabBar ⾥配置的路径必须放在主包⾥
    c. 不同的分包之间的资源不能相互引⽤，但都可引⽤主包中的资源
- 分包的好处
    * 提⾼⾸⻚加载速度
    * 优化性能
    * 分包预下载
- 制定合理的分包策略
    ⼩程序包拆分为主包和⼦包，其中主包包含了⼩程序的⾸⻚和⼀些常⽤基础功能模块，⽽⼦包则包含了其他功能模块和⻚⾯。
    主包在⽤⼾第⼀次打开⼩程序时会被下载和加载，⽽⼦包则根据需要来动态下载和加载。
    * 根据功能模块拆分 ：将⼩程序的功能模块拆分成不同的⼦包。⽐如：tabbar 模块、⽤⼾模块、推送模块等等。
    * 根据资源引⽤拆分 ：⾃定义组件、JS ⽂件、静态资源仅被⼀个分包使⽤时则把它划为同⼀个分包中，如果是公共的资源被各个分包使⽤，则将其划为主包
    * 分包预下载配置 ：通过分包预下载机制，在⽤⼾需要时能够快速加载，配置 preloadRule 后，在进⼊⼩程序某个⻚⾯时，由框架⾃动预下载可能需要的分包，提升进⼊后续分包⻚⾯时的启动速度，减少⽤⼾等待时间，提升⽤⼾体验

#### 谈谈你对uni-app的理解
uni-app是⼀个使⽤Vue.js开发所有前端应⽤的框架，开发者编写⼀套代码，可以发布到IOS、Android、Web（响应式）、以及各种⼩程序、快应⽤等多个平台。
uniapp真正做到⼀套代码多端发⾏，⽀持原⽣代码混写和原⽣sdk集成。
运⾏体验更好。
组件、api与微信⼩程序⼀致，兼容 Weex 原⽣渲染。
通⽤技术栈，学习成本更低。
Vue的语法，微信⼩程序的api，对于前端开发⼈员来说更容易上⼿。
开放⽣态，组件更丰富。
⽀持通过npm安装第三⽅包；⽀持微信⼩程序⾃定义组件及sdk；
兼容mpvue 组件及项⽬；
app端⽀持与原⽣混合编码；
* uni中如何为不同的平台设置不同的代码？
通过条件注释来为不同平台设置不同的代码：
条件注释的作⽤：实现跨端兼容
使⽤⽅法：以 #ifdef 或 #ifndef 加平台代值开头，以 #endif 结尾
#ifdef：if defined 如果是xx平台则运⾏代码块 #ifndef：if not defined 如果不是xx平台才运⾏代码块
- H5 H5
- MP-WEIXIN 微信⼩程序
- APP-PLUS app
- MP 所有⼩程序

#### uniapp中封装接⼝请求相较于微信⼩程序有什么要注意的
uniapp和微信⼩程序都提供了⽹络请求API（uni.request() 和 wx.request()），但 uniapp 为了实现跨端兼容，需要注意⽹络请求跨域问题，微信⼩程序不⽤考虑多端兼容，也不会出现跨域问题。
uniapp中的跨域问题依然可以通过在 vue.config.js 中配置Proxy代理解决；
```json
devServer⸺> proxy⸺> changeOrigin: true, //是否跨域
```
#### uni-app 在⾮h5端上运⾏为什么要在架构上分为逻辑层和视图层？

  1. **安全性 🔒**
这是**首要原因**。
在传统的Web开发中，JavaScript可以直接操作DOM，这带来了巨大的安全风险（如XSS攻击、恶意跳转、获取敏感信息等）。
小程序/uni-app作为平台，承载了大量第三方应用，必须保证宿主环境（如微信）的安全。通过：
- **禁止逻辑层直接操作DOM**，从根本上切断了恶意脚本修改页面、盗取用户信息的途径。
- **提供一套可控的API**（如`uni.navigateTo`, `uni.request`），所有对系统能力的调用都必须经过官方API的审核和管控。

  2. **性能与体验 ⚡**
- **避免JS执行阻塞渲染**：在复杂Web应用中，大量的JS计算（如数据处理）会阻塞UI线程，导致页面卡顿。
将两者分离到不同的线程，即使逻辑层在进行复杂计算，视图层依然可以保持流畅的滚动和动画。
- **提升页面切换体验**：可以**预先初始化多个Webview作为视图层**。
  当切换页面时，实际上是在不同的Webview之间切换，这比单页应用（SPA）的DOM切换要快得多，体验更接近原生App。

  1. **管控与规范性 📋**
- **数据驱动视图**：强制开发者使用数据驱动的方式开发（类似于Vue/React的思维方式）。
你只需要关心数据的变更，由框架负责将数据同步到视图层并更新。这使得代码更规范、更易于维护。
- **技术栈统一**：平台可以强制统一开发规范和技术栈，保证了应用的质量和一致性，也降低了开发者的学习成本。


#### 从云端加载插件时，插件版本无法锁定，可能导致项目在不同基座版本中表现不一致
将插件下载到本地并从本地加载。
#### scroll-view 的横向滚动在 Android 上无效
为子元素添加样式 display: inline-block，并为容器添加 white-space: nowrap
#### iOS 输入框聚焦后底部留白
监听键盘弹出事件并动态调整页面布局
```js
window.visualViewport.addEventListener('resize', (e) => {
 const keyboardHeight = window.innerHeight - e.target.height;
 document.body.style.paddingBottom = `${keyboardHeight}px`;
});
```
#### 通过 URL 传递过多参数时，页面重新编译可能会出现白屏错误
使用 uni.setStorageSync 存储数据，避免直接通过 URL 传递