# 常见排序算法的时间复杂度、空间复杂度

## 复杂度总览表

| 排序算法 | 平均时间复杂度 | 最好情况 | 最坏情况 | 空间复杂度 | 稳定性 | 排序方式 |
|---------|--------------|---------|---------|-----------|--------|---------|
| **冒泡排序** | O(n²) | O(n) | O(n²) | O(1) | 稳定 | 内部 |
| **选择排序** | O(n²) | O(n²) | O(n²) | O(1) | 不稳定 | 内部 |
| **插入排序** | O(n²) | O(n) | O(n²) | O(1) | 稳定 | 内部 |
| **希尔排序** | O(n log n) | O(n log² n) | O(n²) | O(1) | 不稳定 | 内部 |
| **归并排序** | O(n log n) | O(n log n) | O(n log n) | O(n) | 稳定 | 外部 |
| **快速排序** | O(n log n) | O(n log n) | O(n²) | O(log n) | 不稳定 | 内部 |
| **堆排序** | O(n log n) | O(n log n) | O(n log n) | O(1) | 不稳定 | 内部 |
| **计数排序** | O(n + k) | O(n + k) | O(n + k) | O(k) | 稳定 | 外部 |
| **桶排序** | O(n + k) | O(n + k) | O(n²) | O(n + k) | 稳定 | 外部 |
| **基数排序** | O(n × k) | O(n × k) | O(n × k) | O(n + k) | 稳定 | 外部 |

---

## 详细解释

### 1. 简单排序算法（O(n²)）

#### **冒泡排序 (Bubble Sort)**
```javascript
function bubbleSort(arr) {
    for (let i = 0; i < arr.length; i++) {
        for (let j = 0; j < arr.length - 1 - i; j++) {
            if (arr[j] > arr[j + 1]) {
                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
            }
        }
    }
    return arr;
}
```
- **时间复杂度**：平均O(n²)，最好O(n)（已排序时），最坏O(n²)
- **空间复杂度**：O(1) - 原地排序
- **稳定性**：稳定（相等元素不交换）

#### **选择排序 (Selection Sort)**
```javascript
function selectionSort(arr) {
    for (let i = 0; i < arr.length; i++) {
        let minIndex = i;
        for (let j = i + 1; j < arr.length; j++) {
            if (arr[j] < arr[minIndex]) minIndex = j;
        }
        [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];
    }
    return arr;
}
```
- **时间复杂度**：始终O(n²)
- **空间复杂度**：O(1)
- **稳定性**：不稳定（可能改变相等元素的相对位置）

#### **插入排序 (Insertion Sort)**
```javascript
function insertionSort(arr) {
    for (let i = 1; i < arr.length; i++) {
        let current = arr[i];
        let j = i - 1;
        while (j >= 0 && arr[j] > current) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = current;
    }
    return arr;
}
```
- **时间复杂度**：平均O(n²)，最好O(n)（已排序时），最坏O(n²)
- **空间复杂度**：O(1)
- **稳定性**：稳定

---

### 2. 高效排序算法（O(n log n)）

#### **快速排序 (Quick Sort)**
```javascript
function quickSort(arr) {
    if (arr.length <= 1) return arr;
    
    const pivot = arr[Math.floor(arr.length / 2)];
    const left = [], right = [], equal = [];
    
    for (let num of arr) {
        if (num < pivot) left.push(num);
        else if (num > pivot) right.push(num);
        else equal.push(num);
    }
    
    return [...quickSort(left), ...equal, ...quickSort(right)];
}
```
- **时间复杂度**：平均O(n log n)，最好O(n log n)，最坏O(n²)（选择糟糕的基准时）
- **空间复杂度**：O(log n) - 递归调用栈
- **稳定性**：不稳定

#### **归并排序 (Merge Sort)**
```javascript
function mergeSort(arr) {
    if (arr.length <= 1) return arr;
    
    const mid = Math.floor(arr.length / 2);
    const left = mergeSort(arr.slice(0, mid));
    const right = mergeSort(arr.slice(mid));
    
    return merge(left, right);
}

function merge(left, right) {
    const result = [];
    let i = 0, j = 0;
    
    while (i < left.length && j < right.length) {
        if (left[i] <= right[j]) {
            result.push(left[i++]);
        } else {
            result.push(right[j++]);
        }
    }
    
    return result.concat(left.slice(i)).concat(right.slice(j));
}
```
- **时间复杂度**：始终O(n log n)
- **空间复杂度**：O(n) - 需要额外数组
- **稳定性**：稳定

#### **堆排序 (Heap Sort)**
```javascript
function heapSort(arr) {
    // 构建最大堆
    for (let i = Math.floor(arr.length / 2) - 1; i >= 0; i--) {
        heapify(arr, arr.length, i);
    }
    
    // 一个个取出元素
    for (let i = arr.length - 1; i > 0; i--) {
        [arr[0], arr[i]] = [arr[i], arr[0]];
        heapify(arr, i, 0);
    }
    return arr;
}

function heapify(arr, n, i) {
    let largest = i;
    const left = 2 * i + 1;
    const right = 2 * i + 2;
    
    if (left < n && arr[left] > arr[largest]) largest = left;
    if (right < n && arr[right] > arr[largest]) largest = right;
    
    if (largest !== i) {
        [arr[i], arr[largest]] = [arr[largest], arr[i]];
        heapify(arr, n, largest);
    }
}
```
- **时间复杂度**：始终O(n log n)
- **空间复杂度**：O(1)
- **稳定性**：不稳定

---

### 3. 线性排序算法（O(n)）

#### **计数排序 (Counting Sort)**
```javascript
function countingSort(arr) {
    if (arr.length === 0) return arr;
    
    const max = Math.max(...arr);
    const count = new Array(max + 1).fill(0);
    const output = new Array(arr.length);
    
    // 计数
    for (let num of arr) count[num]++;
    
    // 累加
    for (let i = 1; i <= max; i++) count[i] += count[i - 1];
    
    // 输出
    for (let i = arr.length - 1; i >= 0; i--) {
        output[count[arr[i]] - 1] = arr[i];
        count[arr[i]]--;
    }
    
    return output;
}
```
- **时间复杂度**：O(n + k)，其中k是数据范围
- **空间复杂度**：O(k)
- **适用场景**：数据范围不大且为整数

#### **基数排序 (Radix Sort)**
```javascript
function radixSort(arr) {
    const max = Math.max(...arr);
    
    // 按每一位进行计数排序
    for (let exp = 1; Math.floor(max / exp) > 0; exp *= 10) {
        countingSortByDigit(arr, exp);
    }
    return arr;
}

function countingSortByDigit(arr, exp) {
    const output = new Array(arr.length);
    const count = new Array(10).fill(0);
    
    // 计数
    for (let i = 0; i < arr.length; i++) {
        const digit = Math.floor(arr[i] / exp) % 10;
        count[digit]++;
    }
    
    // 累加
    for (let i = 1; i < 10; i++) count[i] += count[i - 1];
    
    // 输出
    for (let i = arr.length - 1; i >= 0; i--) {
        const digit = Math.floor(arr[i] / exp) % 10;
        output[count[digit] - 1] = arr[i];
        count[digit]--;
    }
    
    // 拷贝回原数组
    for (let i = 0; i < arr.length; i++) arr[i] = output[i];
}
```
- **时间复杂度**：O(n × k)，其中k是最大数字的位数
- **空间复杂度**：O(n + k)

---

## 选择指南

### 根据数据规模选择：
- **小规模数据 (n < 50)**：插入排序（简单高效）
- **中等规模数据**：快速排序（通常最快）
- **大规模数据**：归并排序（稳定O(n log n)）
- **内存受限**：堆排序（空间复杂度O(1)）

### 根据数据特性选择：
- **基本有序**：插入排序（接近O(n)）
- **数据范围小**：计数排序、桶排序（可达到O(n)）
- **需要稳定性**：归并排序、插入排序
- **链表结构**：归并排序

### 实际应用场景：
- **JavaScript Array.sort()**：不同浏览器实现不同，通常是快速排序或归并排序的变体
- **数据库排序**：外部归并排序（处理磁盘数据）
- **优先级队列**：堆排序
