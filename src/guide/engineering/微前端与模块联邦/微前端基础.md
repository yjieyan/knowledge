# 微前端基础

微前端是一种类似于微服务架构的**前端应用架构**。

它的核心思想是将一个庞大的单体前端应用，拆分成多个**独立开发、独立部署、技术栈无关**的松耦合应用，然后通过某种机制将它们组合成一个完整的产品。

---

### 一、 为什么需要微前端？核心价值

当一个单体前端应用（例如由 AngularJS 1.x 或 React 15 构建）演进多年后，通常会遇到以下痛点：

1.  **巨石应用**：代码库庞大，构建和部署缓慢，任何小修改都需要全量发布。
2.  **技术栈陈旧/锁定**：很难升级或引入新的技术栈（如从 Vue 2 升级到 Vue 3），历史包袱重。
3.  **团队协作低效**：多个团队在同一个代码库上工作，容易产生冲突，职责边界模糊。
4.  **独立交付困难**：一个团队的发布可能会阻塞其他团队的发布。

**微前端的核心价值就是解决上述问题，实现：**
*   **增量升级**：允许你逐步重构、升级应用的某个部分，而不是“重写整个应用”。
*   **技术栈无关**：不同团队可以根据业务需求或自身情况，选择合适的技术栈（React, Vue, Angular, Svelte...）。
*   **独立开发与部署**：每个微应用都可以由独立的团队独立开发、测试和部署，真正做到持续交付。
*   **应用自治**：每个微应用都是自包含的，拥有自己的生命周期和状态管理。

---

### 二、 核心概念与架构

一个典型的微前端架构包含以下部分：

*   **基座应用**：也称为 **主应用** 或 **容器应用**。它是整个应用的 Shell，负责：
    *   应用的注册、加载和卸载。
    *   提供公共依赖（如 UI 组件库、工具函数）。
    *   管理全局路由和状态。
    *   渲染通用的布局（如导航栏、侧边栏）。

*   **微应用**：也称为 **子应用**。它们是独立的前端应用，代表一个特定的业务功能或页面。
    *   例如：用户中心微应用、商品管理微应用、订单流程微应用。
    *   它们拥有**独立的代码库、独立的开发流程和独立的部署流水线**。

---

### 三、 核心实现方案与原理

微前端的核心挑战是 **“如何将多个独立的应用在运行时组合在一起”**。主要有以下几种方案：

#### 1. 构建时组合 (编译时集成)

*   **原理**：将各个微应用以 **NPM 包** 的形式发布，在主应用中通过 `npm install` 引入，然后一起打包构建。
*   **优点**：技术简单，没有运行时开销。
*   **缺点**：
    *   耦合紧密，任何一个微应用更新，都需要主应用重新构建和部署。
    *   无法做到独立部署，失去了微前端的核心优势。
*   **评价**：这更像是“多包单体”，**不算是真正的微前端**。

#### 2. 运行时组合 (主流方案)

这才是微前端的精髓，核心是 **“在浏览器中动态加载和运行微应用”**。

*   **方案A：iframe**
    *   **原理**：最原始的方案，每个微应用运行在一个独立的 `<iframe>` 中。
    *   **优点**：**天然的沙盒隔离**（JS、CSS 完全隔离），技术简单。
    *   **缺点**：
        *   用户体验差：路由状态无法同步、全局状态共享困难、页面刷新 iframe 状态丢失。
        *   性能开销：每个 iframe 都是一套完整的浏览器上下文，内存消耗大。
        *   SEO 不友好。
    *   **评价**：适用于需要**强隔离**的简单嵌入场景，但不是构建现代 SPA 的首选。

*   **方案B：Web Components 自定义元素**
    *   **原理**：每个微应用打包成一个 **Custom Element**（如 `<micro-app-user></micro-app-user>`）。主应用只需引入这个自定义元素，无需关心其内部实现。
    *   **优点**：浏览器原生支持，技术栈无关性最好，天然的样式和 DOM 隔离。
    *   **缺点**：
        *   生态和工具链不成熟。
        *   需要微应用本身支持打包为 Web Components，改造成本可能较高。
        *   共享依赖、路由管理需要额外设计。

*   **方案C：JavaScript Entry + 模块联邦 (当前最主流和先进的方案)**
    这是 **single-spa** 和 **Module Federation** 采用的模式。
    *   **原理**：
        1.  每个微应用**不打包成 HTML，而是暴露一个 JavaScript 入口文件**（如 `app.js`）。
        2.  主应用在运行时，通过 **`<script>` 标签** 或 **`SystemJS`** 动态加载这个入口文件。
        3.  入口文件会暴露出一组生命周期钩子函数（如 `bootstrap`, `mount`, `unmount`）。
        4.  主应用根据当前路由，匹配到对应的微应用，然后调用其 `mount` 方法，将微应用挂载到指定的 DOM 容器中；离开时调用 `unmount` 方法进行清理。
    *   **关键技术**：
        *   **`single-spa`**：一个实现了上述生命周期管理的框架。
        *   **`qiankun`**：基于 `single-spa` 的封装，提供了更完善的解决方案（如样式隔离、JS 沙箱、资源预加载）。
        *   **Webpack 5 Module Federation (模块联邦)**：允许一个 JavaScript 应用在运行时从另一个应用动态加载代码，并共享依赖。这是目前最强大的微前端解决方案，可以实现应用级别的代码共享和依赖去重。

---

### 四、 关键技术挑战与解决方案

1.  **样式隔离**
    *   **问题**：不同微应用的 CSS 可能会相互污染。
    *   **解决方案**：
        *   **CSS Modules / Scoped CSS**：在构建时处理，但无法完全避免全局样式。
        *   **Shadow DOM**：最彻底的隔离方案，但兼容性和第三方库支持有问题。
        *   **动态样式表**：`qiankun` 采用的方案，在应用挂载时加载其样式表，卸载时移除。
        *   **CSS 命名前缀**：约定每个微应用使用唯一的前缀。

2.  **JavaScript 沙箱**
    *   **问题**：多个微应用运行在同一个页面中，会污染全局对象（如 `window`）。
    *   **解决方案**：
        *   **Proxy 沙箱**：`qiankun` 使用 `Proxy` 为每个微应用创建一个假的 `window` 对象，对其的读写操作不会影响到真实的全局对象。这是目前最完善的方案。

3.  **公共依赖管理**
    *   **问题**：如何避免 React、Vue 等库被重复加载？
    *   **解决方案**：
        *   **Webpack Externals**：在主应用中通过 `<script>` 标签引入，并配置 `externals`，微应用直接使用主应用的库。
        *   **Module Federation**：这是最佳方案，它允许明确地共享依赖，并智能地处理版本冲突。

4.  **路由与状态管理**
    *   **路由**：主应用负责一级路由，根据 URL 决定加载哪个微应用。微应用负责自己内部的路由。
    *   **状态**：主应用和微应用之间可以通过 **Custom Events**、**Redux** 或 **发布订阅模式** 进行通信，但应保持通信最小化，避免紧密耦合。

---

### 五、 优缺点总结

**优点：**
*   **技术栈无关**
*   **独立开发、独立部署**
*   **增量迁移和升级**
*   **团队自治**

**缺点：**
*   **复杂度提升**：部署、监控、调试的复杂度成倍增加。
*   **性能开销**：运行时动态加载会带来额外的网络请求和解析开销。
*   **治理难度大**：需要统一的技术规范、CI/CD 流程和监控体系。
*   **技术成熟度**：虽然发展迅速，但最佳实践仍在演进中。

### 总结

微前端不是银弹，而是一种**架构决策**。它适用于**大型、长生命周期的企业级 Web 应用**，特别是需要多个团队协作、并希望保持技术栈灵活性的场景。对于小型项目或初创公司，引入微前端带来的复杂度可能远大于其收益。

**技术选型建议**：
*   新项目或技术栈统一：考虑 **Module Federation**。
*   需要对旧系统进行渐进式重构：**`qiankun`** 是一个非常成熟和稳定的选择。
*   需要最强隔离且交互简单：**`iframe`** 仍然是一个可选项。
