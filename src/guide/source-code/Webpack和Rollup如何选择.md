# Webpack和Rollup如何选择
**选择哪一个，不是比谁更好，而是看谁更适合。**

1.  **核心定位与设计哲学**
2.  **打包模型与输出结果**
3.  **生态系统与功能特性**
4.  ** Tree-shaking 能力**
5.  **开发体验与热更新**
6.  **总结与选型建议**

---

### 1. 核心定位与设计哲学

这是最根本的区别，决定了两者的所有特性差异。

*   **Webpack：一个 “应用程序打包器”**
    *   **哲学**：**万物皆模块**。它的首要目标是为复杂的大型**应用程序（Application）** 构建一个完整的运行环境。
    *   **核心关切**：如何将你项目中各种类型的资源（JS、CSS、图片、字体等）都视为模块，并通过各种 Loader 和 Plugin 进行处理，最终打包成一个或多个适合在浏览器中运行的 **bundle**。
    *   **心智模型**：我的是一个完整的、有入口文件的 **App**。

*   **Rollup：一个 “JavaScript 库打包器”**
    *   **哲学**：专注于 **ES Module** 的打包，旨在构建出**结构更扁平、效率更高、体积更小**的库或框架。
    *   **核心关切**：如何将你编写的多个 ES Module 模块，高效地合并成一个或几个文件，并充分利用 ESM 的静态分析特性进行优化。
    *   **心智模型**：我的是一个可以被他人引用的 **Library**。

---

### 2. 打包模型与输出结果

不同的定位导致了截然不同的打包策略。

*   **Webpack：**
    *   **打包模型**：使用自己的 **模块化运行时**。它将每个模块包裹在一个函数中，并实现了一套自己的 `require`/`define` 系统（即 `__webpack_require__`）来处理模块间的导入导出。这带来了极大的灵活性，可以支持 CommonJS、AMD、ES Module 等多种模块规范。
    *   **输出结果**：bundle 中包含大量的**胶水代码（boilerplate）** 和运行时环境。例如，你会看到 `webpackBootstrap` 这样的代码块。
    *   **代码分割**：对代码分割（Code Splitting）和异步加载（如 `import()`）有**原生且强大**的支持，这是为应用开发量身定做的。

*   **Rollup：**
    *   **打包模型**：**作用域提升（Scope Hoisting）**。它会将所有模块的代码尽可能地“拍平”，合并到一个作用域中，然后通过重命名变量来消除函数声明和导入导出。这极大地减少了代码量并提升了运行时的执行速度。
    *   **输出结果**：输出非常**干净、可读**的代码，几乎就像你亲手编写的一样。它生成的 bundle 几乎没有运行时开销。
    *   **代码分割**：早期不支持，现在虽然支持，但其成熟度和灵活性仍不如 Webpack。

---

### 3. 生态系统与功能特性

*   **Webpack：**
    *   **生态庞大**：拥有极其丰富的 **Loader** 和 **Plugin** 生态系统，几乎可以处理任何类型的资源（CSS, SCSS, Less, 图片, SVG, 字体等）。`style-loader`, `css-loader`, `file-loader`, `HtmlWebpackPlugin` 等已成为事实标准。
    *   **功能全面**：开箱即用地支持热模块替换（HMR），这对于应用开发体验至关重要。
    *   **配置灵活**：功能强大的同时，也意味着配置可能相对复杂（虽然 Webpack 5 和 CLI 工具在简化配置）。

*   **Rollup：**
    *   **生态聚焦**：其插件生态更专注于 JS 相关的任务。对于非 JS 资源，需要配合更多、更专门的插件，且成熟度可能不如 Webpack。
    *   **更简洁**：配置通常比 Webpack 更简单、更直观。
    *   **功能纯粹**：它专注于打包，像 HMR 这样的功能需要借助其他工具（如 Vite）来实现。

---

### 4. Tree-shaking 

两者都支持 Tree-shaking（消除死代码），但由于设计初衷不同，效果有差异。

*   **Rollup： Tree-shaking 的先行者和标杆**
    *   由于其基于 ES Module 进行静态分析，并且拥有作用域提升，它的 Tree-shaking 非常高效和彻底。它能准确地识别出哪些导出被使用，哪些没有被使用。
    *   **结果**：打包出来的库体积更小。

*   **Webpack：**
    *   从 Webpack 2 开始支持 Tree-shaking，并且在后来的版本中不断优化，现在其能力已经非常强大。
    *   但在某些复杂场景下，由于其打包模型的复杂性，可能不如 Rollup 那样彻底。不过对于绝大多数应用场景，其 Tree-shaking 效果已经足够好。

---

### 5. 开发体验与热更新

*   **Webpack：**
    *   **开发服务器**：`webpack-dev-server` 提供了非常成熟的开发环境，集成 HMR，修改代码后能无缝更新，保持应用状态，体验极佳。
    *   **为应用开发优化**：整个工具链都是围绕提升开发效率构建的。

*   **Rollup：**
    *   早期需要配合 `rollup-plugin-serve` 和 `rollup-plugin-livereload` 实现简单的实时重载，但体验不如 HMR。
    *   **现代解决方案**：现在，我们通常不直接使用 Rollup 作为开发服务器。而是使用 **Vite**，它在开发环境下基于 **ESM 和 Rollup**，提供了远超 Webpack 的启动速度和 HMR 体验。可以说，Vite 弥补了 Rollup 在开发体验上的短板。

---

### 总结与选型建议

| 特性 | Webpack | Rollup |
| :--- | :--- | :--- |
| **核心定位** | **应用程序（App）** | **库（Library）** |
| **打包模型** | 模块化运行时，包裹函数 | **作用域提升**，代码拍平 |
| **输出代码** | 包含运行时胶水代码，体积较大 | **干净、紧凑**，几乎无运行时开销 |
| **代码分割** | **原生、强大** | 支持，但不如 Webpack 成熟 |
| **HMR** | **原生、强大** | 需借助其他工具（如 Vite） |
| **生态** | **庞大、全面**，处理各种资源 | **聚焦**，主要在 JS 领域 |
| **Tree-shaking** | 很好 | **极好** |
| **配置** | 相对复杂 | 相对简单 |

#### **如何选择？**

**1. 选择 Webpack，如果：**

*   **你在构建一个完整的 Web 应用程序**，特别是单页面应用（SPA）。
*   你需要处理大量的**静态资源**（CSS， 图片， 字体等）。
*   你对**代码分割**和**异步加载**有强烈的需求。
*   你非常依赖**热模块替换（HMR）** 来提升开发体验。
*   你的项目混合使用了多种模块规范（CommonJS 和 ESM）。

**典型场景：** React/Vue/Angular 企业级中后台管理系统、复杂的 C 端 Web App。

**2. 选择 Rollup，如果：**

*   **你在构建一个 JavaScript 库或框架**，希望发布到 npm。
*   **代码体积和性能是你的首要考虑因素**。
*   你希望输出的代码尽可能**干净、可读**。
*   你的代码库主要使用 ES Module 编写。

**典型场景：** React、Vue、Vite、Svelte、D3、Three.js 等众多知名库都使用 Rollup 构建。

**3. 现代混合模式：**

*   **使用 Vite**：Vite 在开发环境下使用 **ESM** 提供极速启动，在生产环境下使用 **Rollup** 进行构建。它结合了 Rollup 的高效和优秀的开发体验，是构建现代应用的绝佳选择。如果你的应用项目是新技术栈，可以优先考虑 Vite。
*   **大型项目混合使用**：有些大型项目会同时使用两者。例如，**使用 Rollup 将核心库打包**，然后**在应用层使用 Webpack 或 Vite** 将库与应用代码一起构建。React 团队就曾用 Rollup 打包 React 本身，而用 Webpack 打包官方示例。

*   如果输出物是**一个要给用户直接使用的、功能完整的「产品」**，我倾向于选择 **Webpack 或 Vite**。
*   如果输出物是**一个要被其他项目引用的「零件」或「工具」**，我倾向于选择 **Rollup**。
