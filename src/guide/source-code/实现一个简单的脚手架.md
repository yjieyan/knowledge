# 实现一个简单的脚手架

---

## 1. 脚手架核心概念

**脚手架是什么？**
- 用于快速生成项目模板的工具
- 通过命令行交互定制项目配置
- 自动创建项目结构和文件

**典型工作流程：**
1. 用户运行脚手架命令
2. 询问用户项目配置
3. 根据选择下载或复制模板
4. 渲染模板文件
5. 执行安装命令

---

## 2. 项目结构设计

首先创建项目结构：

```
my-cli/
├── bin/
│   └── cli.js              # 命令行入口
├── lib/
│   ├── index.js            # 核心逻辑
│   ├── create.js           # 创建项目逻辑
│   ├── download.js         # 模板下载
│   └── generator.js        # 文件生成
├── templates/              # 本地模板
│   ├── vue-template/
│   ├── react-template/
│   └── node-template/
├── package.json
└── README.md
```

---

## 3. 核心实现

### 3.1 命令行入口 (bin/cli.js)

```javascript
#!/usr/bin/env node

const { program } = require('commander');
const create = require('../lib/create');
const pkg = require('../package.json');

// 定义命令行
program
  .version(pkg.version)
  .usage('<command> [options]');

// create 命令
program
  .command('create <project-name>')
  .description('创建一个新项目')
  .option('-t, --template <template>', '选择模板 (vue/react/node)')
  .option('-f, --force', '强制覆盖已存在目录')
  .action((name, options) => {
    create(name, options);
  });

// 解析命令行参数
program.parse(process.argv);

// 如果没有输入命令，显示帮助
if (!process.argv.slice(2).length) {
  program.outputHelp();
}
```

**package.json 配置：**
```json
{
  "name": "my-cli",
  "version": "1.0.0",
  "description": "一个简单的项目脚手架",
  "bin": {
    "my-cli": "./bin/cli.js"
  },
  "files": [
    "bin",
    "lib",
    "templates"
  ]
}
```

### 3.2 核心创建逻辑 (lib/create.js)

```javascript
const fs = require('fs');
const path = require('path');
const inquirer = require('inquirer');
const chalk = require('chalk');
const download = require('./download');
const generator = require('./generator');

async function create(projectName, options) {
  // 获取当前工作目录
  const cwd = process.cwd();
  // 项目目录
  const targetDir = path.join(cwd, projectName);

  // 检查目录是否存在
  if (fs.existsSync(targetDir)) {
    if (options.force) {
      // 强制删除已存在目录
      fs.rmSync(targetDir, { recursive: true, force: true });
      console.log(chalk.yellow(`删除已存在目录: ${projectName}`));
    } else {
      // 询问用户是否覆盖
      const { action } = await inquirer.prompt([
        {
          name: 'action',
          type: 'list',
          message: `目录 ${chalk.cyan(projectName)} 已存在，请选择操作:`,
          choices: [
            { name: '覆盖', value: 'overwrite' },
            { name: '取消', value: false }
          ]
        }
      ]);

      if (!action) {
        return;
      } else if (action === 'overwrite') {
        console.log(chalk.yellow(`\n删除目录 ${projectName}...`));
        fs.rmSync(targetDir, { recursive: true, force: true });
      }
    }
  }

  // 收集项目信息
  const answers = await collectProjectInfo(projectName, options);
  
  // 创建项目目录
  fs.mkdirSync(targetDir);
  
  console.log(chalk.cyan('\n开始创建项目...'));
  
  try {
    // 下载模板
    const templateDir = await downloadTemplate(answers.template);
    
    // 生成项目文件
    await generator.generate(projectName, templateDir, answers);
    
    // 显示成功信息
    showSuccessMessage(projectName, answers);
    
  } catch (error) {
    console.error(chalk.red('创建项目失败:'), error);
    // 清理失败的项目目录
    if (fs.existsSync(targetDir)) {
      fs.rmSync(targetDir, { recursive: true });
    }
    process.exit(1);
  }
}

// 收集项目信息
async function collectProjectInfo(projectName, options) {
  const questions = [];
  
  // 如果没有指定模板，询问用户
  if (!options.template) {
    questions.push({
      type: 'list',
      name: 'template',
      message: '请选择项目模板:',
      choices: [
        { name: 'Vue 项目', value: 'vue' },
        { name: 'React 项目', value: 'react' },
        { name: 'Node.js 项目', value: 'node' }
      ]
    });
  }
  
  // 公共问题
  questions.push(
    {
      type: 'input',
      name: 'description',
      message: '项目描述:',
      default: `A ${options.template || 'new'} project`
    },
    {
      type: 'input',
      name: 'author',
      message: '作者:',
      default: process.env.USER || 'anonymous'
    },
    {
      type: 'list',
      name: 'packageManager',
      message: '选择包管理器:',
      choices: [
        { name: 'npm', value: 'npm' },
        { name: 'yarn', value: 'yarn' },
        { name: 'pnpm', value: 'pnpm' }
      ]
    }
  );
  
  const answers = await inquirer.prompt(questions);
  
  // 合并选项
  return {
    projectName,
    template: options.template || answers.template,
    description: answers.description,
    author: answers.author,
    packageManager: answers.packageManager,
    version: '1.0.0'
  };
}

// 下载模板
async function downloadTemplate(templateName) {
  const templateMap = {
    vue: 'direct:https://github.com/vuejs-templates/webpack-simple.git',
    react: 'direct:https://github.com/facebook/create-react-app.git',
    node: 'local:node-template' // 使用本地模板
  };
  
  const templateUrl = templateMap[templateName];
  
  if (!templateUrl) {
    throw new Error(`不支持的模板: ${templateName}`);
  }
  
  return await download(templateUrl, templateName);
}

// 显示成功信息
function showSuccessMessage(projectName, answers) {
  console.log(chalk.green(`\n✅ 项目 ${projectName} 创建成功！\n`));
  console.log(chalk.white('接下来执行:'));
  console.log(chalk.cyan(`  cd ${projectName}`));
  console.log(chalk.cyan(`  ${answers.packageManager} install`));
  console.log(chalk.cyan(`  ${answers.packageManager} run dev\n`));
  
  console.log(chalk.white('Happy coding! 🎉'));
}

module.exports = create;
```

### 3.3 模板下载逻辑 (lib/download.js)

```javascript
const fs = require('fs');
const path = require('path');
const os = require('os');
const download = require('download-git-repo');
const chalk = require('chalk');

/**
 * 下载模板
 * @param {string} repo 仓库地址
 * @param {string} templateName 模板名称
 * @returns {Promise<string>} 模板目录路径
 */
function downloadTemplate(repo, templateName) {
  return new Promise((resolve, reject) => {
    // 临时目录
    const tmpdir = path.join(os.tmpdir(), 'my-cli-templates');
    const templateDir = path.join(tmpdir, templateName);
    
    // 如果是本地模板
    if (repo.startsWith('local:')) {
      const localTemplateName = repo.replace('local:', '');
      const localTemplateDir = path.join(__dirname, '../templates', localTemplateName);
      
      if (!fs.existsSync(localTemplateDir)) {
        reject(new Error(`本地模板不存在: ${localTemplateName}`));
        return;
      }
      
      console.log(chalk.cyan(`使用本地模板: ${localTemplateName}`));
      resolve(localTemplateDir);
      return;
    }
    
    // 下载远程模板
    console.log(chalk.cyan(`下载模板: ${templateName}`));
    
    download(repo, templateDir, { clone: true }, (err) => {
      if (err) {
        reject(err);
        return;
      }
      
      console.log(chalk.green('✅ 模板下载成功'));
      resolve(templateDir);
    });
  });
}

module.exports = downloadTemplate;
```

### 3.4 文件生成器 (lib/generator.js)

```javascript
const fs = require('fs');
const path = require('path');
const ejs = require('ejs');
const chalk = require('chalk');

class Generator {
  /**
   * 生成项目文件
   * @param {string} projectName 项目名称
   * @param {string} templateDir 模板目录
   * @param {object} answers 用户答案
   */
  async generate(projectName, templateDir, answers) {
    const targetDir = path.join(process.cwd(), projectName);
    
    // 读取模板文件
    const files = this.readTemplateFiles(templateDir);
    
    console.log(chalk.cyan('生成项目文件...'));
    
    // 处理每个文件
    for (const file of files) {
      await this.processFile(file, templateDir, targetDir, answers);
    }
    
    // 生成 package.json
    await this.generatePackageJson(targetDir, answers);
  }
  
  /**
   * 读取模板目录中的所有文件
   */
  readTemplateFiles(templateDir) {
    const files = [];
    
    function traverse(dir) {
      const items = fs.readdirSync(dir);
      
      for (const item of items) {
        const fullPath = path.join(dir, item);
        const stat = fs.statSync(fullPath);
        
        // 忽略 node_modules 和 .git 目录
        if (item === 'node_modules' || item === '.git') {
          continue;
        }
        
        if (stat.isDirectory()) {
          traverse(fullPath);
        } else {
          files.push(fullPath);
        }
      }
    }
    
    traverse(templateDir);
    return files;
  }
  
  /**
   * 处理单个文件
   */
  async processFile(filePath, templateDir, targetDir, data) {
    // 计算相对路径
    const relativePath = path.relative(templateDir, filePath);
    const targetPath = path.join(targetDir, relativePath);
    
    // 确保目标目录存在
    const targetDirname = path.dirname(targetPath);
    if (!fs.existsSync(targetDirname)) {
      fs.mkdirSync(targetDirname, { recursive: true });
    }
    
    // 读取文件内容
    let content = fs.readFileSync(filePath, 'utf8');
    
    // 如果是 EJS 模板，进行渲染
    if (path.extname(filePath) === '.ejs') {
      const realTargetPath = targetPath.replace(/\.ejs$/, '');
      try {
        content = await ejs.render(content, data, {
          async: true
        });
        fs.writeFileSync(realTargetPath, content, 'utf8');
        console.log(chalk.green('  create ') + relativePath.replace(/\.ejs$/, ''));
      } catch (error) {
        console.log(chalk.red('  error  ') + relativePath);
        throw error;
      }
    } else {
      // 直接复制文件
      fs.writeFileSync(targetPath, content, 'utf8');
      console.log(chalk.green('  create ') + relativePath);
    }
  }
  
  /**
   * 生成 package.json
   */
  async generatePackageJson(targetDir, answers) {
    const packageJsonPath = path.join(targetDir, 'package.json');
    
    let packageJson = {
      name: answers.projectName,
      version: answers.version,
      description: answers.description,
      author: answers.author,
      scripts: {},
      dependencies: {},
      devDependencies: {}
    };
    
    // 根据模板类型添加不同的配置
    switch (answers.template) {
      case 'vue':
        packageJson = {
          ...packageJson,
          main: "src/main.js",
          scripts: {
            "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
            "build": "node build/build.js"
          },
          dependencies: {
            "vue": "^2.6.14"
          },
          devDependencies: {
            "webpack": "^4.46.0",
            "webpack-dev-server": "^3.11.3"
          }
        };
        break;
        
      case 'react':
        packageJson = {
          ...packageJson,
          main: "src/index.js",
          scripts: {
            "dev": "react-scripts start",
            "build": "react-scripts build",
            "test": "react-scripts test"
          },
          dependencies: {
            "react": "^17.0.2",
            "react-dom": "^17.0.2"
          },
          devDependencies: {
            "react-scripts": "4.0.3"
          }
        };
        break;
        
      case 'node':
        packageJson = {
          ...packageJson,
          main: "index.js",
          scripts: {
            "start": "node index.js",
            "dev": "nodemon index.js"
          },
          dependencies: {},
          devDependencies: {
            "nodemon": "^2.0.15"
          }
        };
        break;
    }
    
    fs.writeFileSync(
      packageJsonPath, 
      JSON.stringify(packageJson, null, 2), 
      'utf8'
    );
    
    console.log(chalk.green('  create ') + 'package.json');
  }
}

module.exports = new Generator();
```

---

## 4. 本地模板示例

### 4.1 Node.js 模板 (templates/node-template/)

**package.json.ejs:**
```json
{
  "name": "<%= projectName %>",
  "version": "<%= version %>",
  "description": "<%= description %>",
  "main": "index.js",
  "scripts": {
    "start": "node index.js",
    "dev": "nodemon index.js"
  },
  "author": "<%= author %>",
  "license": "MIT"
}
```

**index.js:**
```javascript
const http = require('http');

const server = http.createServer((req, res) => {
  res.writeHead(200, { 'Content-Type': 'text/plain' });
  res.end('Hello from <%= projectName %>!\n');
});

const PORT = process.env.PORT || 3000;
server.listen(PORT, () => {
  console.log(`Server running at http://localhost:${PORT}/`);
});
```

**README.md.ejs:**
```markdown
# <%= projectName %>

<%= description %>

## 开发

```bash
npm run dev
```

## 生产

```bash
npm start
```
```

---

## 5. 依赖安装和发布

### 5.1 安装依赖

```bash
npm init -y
npm install commander inquirer chalk download-git-repo ejs
```

### 5.2 完整的 package.json

```json
{
  "name": "my-cli",
  "version": "1.0.0",
  "description": "一个简单的项目脚手架",
  "main": "lib/index.js",
  "bin": {
    "my-cli": "./bin/cli.js"
  },
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": ["cli", "scaffold"],
  "author": "Your Name",
  "license": "MIT",
  "dependencies": {
    "chalk": "^4.1.2",
    "commander": "^8.3.0",
    "download-git-repo": "^3.0.2",
    "ejs": "^3.1.6",
    "inquirer": "^8.2.0"
  },
  "files": [
    "bin",
    "lib",
    "templates"
  ]
}
```

### 5.3 本地测试

```bash
# 全局链接进行测试
npm link

# 测试命令
my-cli create my-project
my-cli create my-vue-project --template vue
my-cli create my-react-project --template react --force
```

### 5.4 发布到 npm

```bash
# 登录 npm
npm login

# 发布
npm publish

# 用户安装使用
npm install -g my-cli
my-cli create my-app
```

---

## 6. 功能扩展

### 6.1 添加更多模板选项

```javascript
// 在 create.js 中扩展模板选择
const templateChoices = [
  { name: 'Vue 2 + Webpack', value: 'vue2' },
  { name: 'Vue 3 + Vite', value: 'vue3' },
  { name: 'React + Webpack', value: 'react' },
  { name: 'React + Vite', value: 'react-vite' },
  { name: 'Node.js Express', value: 'node-express' },
  { name: 'TypeScript Library', value: 'ts-lib' }
];
```

### 6.2 添加自动安装依赖功能

```javascript
// 在 create.js 的 showSuccessMessage 后添加
const { spawn } = require('child_process');

async function autoInstall(projectName, packageManager) {
  console.log(chalk.cyan('\n正在安装依赖...'));
  
  return new Promise((resolve, reject) => {
    const child = spawn(packageManager, ['install'], {
      cwd: path.join(process.cwd(), projectName),
      stdio: 'inherit'
    });
    
    child.on('close', (code) => {
      if (code === 0) {
        resolve();
      } else {
        reject(new Error(`安装失败，退出码: ${code}`));
      }
    });
  });
}
```

### 6.3 添加 Git 初始化

```javascript
// 添加 Git 初始化功能
const { execSync } = require('child_process');

function initGit(projectDir) {
  try {
    execSync('git init', { cwd: projectDir, stdio: 'ignore' });
    execSync('git add .', { cwd: projectDir, stdio: 'ignore' });
    execSync('git commit -m "Initial commit"', { cwd: projectDir, stdio: 'ignore' });
    console.log(chalk.green('✅ Git 仓库初始化完成'));
  } catch (error) {
    console.log(chalk.yellow('⚠️  Git 初始化跳过'));
  }
}
```

---

## 7. 总结

这个简单的脚手架实现了以下核心功能：

1. **命令行交互**：使用 commander 和 inquirer
2. **模板管理**：支持本地和远程模板
3. **文件生成**：使用 EJS 模板引擎渲染文件
4. **用户配置**：收集项目信息并应用到模板中
5. **错误处理**：完善的错误处理和用户提示

**进一步优化方向：**
- 添加更多模板选项
- 支持插件系统
- 添加自动依赖安装
- 集成代码检查工具
- 添加更新检查功能
