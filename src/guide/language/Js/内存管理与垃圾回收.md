# 内存管理与垃圾回收

---

### 1. 内存生命周期

不管什么编程语言，内存生命周期都遵循以下模式：

1. **分配内存**：当声明变量、函数、对象时，系统自动分配内存
2. **使用内存**：对内存进行读写操作
3. **释放内存**：当内存不再需要时，将其释放

**JavaScript 的特殊性：** 第1步和第3步对开发者是**透明**的，由 JavaScript 引擎自动完成。

```javascript
// 1. 内存分配
const number = 123;          // 为数值分配内存
const string = "hello";      // 为字符串分配内存
const object = {             // 为对象及其属性分配内存
  name: "John",
  age: 30
};
const array = [1, null, "hi"]; // 为数组及其元素分配内存

function sum(a, b) {         // 为函数分配内存
  return a + b;
}

// 2. 内存使用
const result = number * 2;   // 读取内存中的值
object.name = "Jane";        // 写入内存

// 3. 内存释放 - 由垃圾回收器自动完成
```

---

### 2. 内存管理的关键概念

#### 2.1 栈内存 vs 堆内存

```javascript
// 栈内存 - 存储原始类型和引用地址
const name = "Alice";        // 字符串，栈内存
const age = 25;              // 数字，栈内存
const isStudent = true;      // 布尔值，栈内存

// 堆内存 - 存储对象、数组、函数等引用类型
const person = {             // 对象存储在堆内存，person变量存储的是引用地址
  name: "Bob",
  age: 30
};

const scores = [95, 87, 92]; // 数组存储在堆内存

function calculate() {       // 函数存储在堆内存
  return 100;
}
```

**内存结构示意图：**
```
栈内存 (Stack)          堆内存 (Heap)
┌─────────────┐        ┌─────────────┐
│ name        │ ────── │ "Alice"     │
│ age = 25    │        │             │
│ isStudent   │        │ {Object}    │ ← person 引用
│ person ───────┐      │ name: "Bob" │
│ scores ──────│┐     │ age: 30     │
│ calculate ───││┐    │             │
└─────────────┘ ││    │ [95,87,92]  │ ← scores 引用
                ││    │             │
                ││    │ function()  │ ← calculate 引用
                ││    └─────────────┘
                ││
                │└─────────────┘
                └───────────────┘
```

#### 2.2 可达性概念

垃圾回收的核心概念是"可达性"：**从根对象出发，能够访问到的对象就是可达的，否则就是不可达的。**

**根对象包括：**
- 全局对象（浏览器中的 `window`，Node.js 中的 `global`）
- 当前函数的局部变量和参数
- 嵌套调用链中的变量
- 其他...

```javascript
// 可达性示例
let user = {
  name: "John",
  age: 30
};

// user 对象是可达的（从全局变量可访问）

user = null; 
// 现在 { name: "John", age: 30 } 变成不可达，将被垃圾回收
```

---

### 3. 垃圾回收算法

现代 JavaScript 引擎主要使用**标记-清除算法**，并辅以其他优化技术。

#### 3.1 标记-清除算法

这是最基础的垃圾回收算法，分为两个阶段：

**阶段一：标记**
从根对象开始，遍历所有可访问的对象，并标记为"可达"

**阶段二：清除**
遍历堆中所有对象，清除没有被标记的对象

```javascript
// 标记-清除过程示例
function createObjects() {
  const obj1 = { name: "obj1" };  // 在函数内部创建，函数执行后可能不可达
  const obj2 = { name: "obj2" };
  
  obj1.ref = obj2;                // obj1 引用 obj2
  obj2.ref = obj1;                // obj2 引用 obj1 - 形成循环引用
  
  return obj1;
}

let globalObj = createObjects();  // obj1 现在是可达的（被全局变量引用）
                                  // obj2 也是可达的（通过 obj1.ref）

globalObj = null;                 // 现在 obj1 和 obj2 都不可达，将被回收
```

**注意：** 现代垃圾回收器可以处理循环引用！

#### 3.2 引用计数算法（已淘汰）

这是早期的垃圾回收算法，现在已基本不再使用。

```javascript
// 引用计数示例
let a = { name: "A" };  // 对象A的引用计数 = 1
let b = a;              // 对象A的引用计数 = 2

a = null;               // 对象A的引用计数 = 1
b = null;               // 对象A的引用计数 = 0 → 可以被回收
```

**引用计数的问题：**
```javascript
// 循环引用问题
function problem() {
  let objA = { name: "A" };  // objA 引用计数 = 1
  let objB = { name: "B" };  // objB 引用计数 = 1
  
  objA.ref = objB;          // objB 引用计数 = 2
  objB.ref = objA;          // objA 引用计数 = 2
  
  // 函数执行结束，但引用计数都不为0，内存泄漏！
}
problem();
```

#### 3.3 现代优化：分代收集

V8 引擎将堆内存分为两个"代"：

- **新生代**：存放新创建的对象
  - 区域小，垃圾回收频繁
  - 使用 **Scavenge 算法**（复制算法）
  
- **老生代**：存放存活时间较长的对象
  - 区域大，垃圾回收较少
  - 使用 **标记-清除/标记-整理算法**

```javascript
// 对象在分代中的生命周期
function lifeCycle() {
  const tempObj = { temp: true };    // 新对象 → 新生代
  const persistentObj = { data: "important" };
  
  // 模拟对象长期存活
  for (let i = 0; i < 100000; i++) {
    // 大量操作...
  }
  
  // persistentObj 如果存活足够久，会被移动到老生代
  return persistentObj;
}
```

#### 3.4 现代优化：增量标记

为了减少垃圾回收造成的页面卡顿，V8 使用增量标记：

- 将标记过程分解为多个小步骤
- 与 JavaScript 执行交替进行
- 避免长时间的"全停顿"

---

### 4. 常见内存泄漏场景及解决方案

#### 4.1 意外的全局变量

```javascript
// ❌ 错误：意外的全局变量
function createGlobal() {
  leakedVar = "I'm leaked";  // 没有 var/let/const，成为全局变量
  this.accidentalGlobal = "Oops"; // 在非严格模式下，this 指向 window
}

// ✅ 解决方案
function safeFunction() {
  'use strict';              // 使用严格模式
  let localVar = "I'm safe"; // 明确声明
}
```

#### 4.2 被遗忘的定时器和回调

```javascript
// ❌ 错误：未清理的定时器
function startPolling() {
  setInterval(() => {
    fetchData().then(processData);
  }, 1000);
}

// ✅ 解决方案：保存引用并适时清理
class DataPoller {
  constructor() {
    this.intervalId = null;
  }
  
  start() {
    this.intervalId = setInterval(() => {
      fetchData().then(processData);
    }, 1000);
  }
  
  stop() {
    if (this.intervalId) {
      clearInterval(this.intervalId);
      this.intervalId = null;
    }
  }
}
```

#### 4.3 DOM 引用泄漏

```javascript
// ❌ 错误：保留对已移除DOM元素的引用
const elements = {
  button: document.getElementById('myButton'),
  container: document.getElementById('container')
};

// 从DOM中移除元素，但JavaScript仍持有引用
document.body.removeChild(document.getElementById('container'));

// elements.container 仍然引用着DOM元素，无法被垃圾回收

// ✅ 解决方案：适时释放引用
function cleanUp() {
  // 移除DOM元素
  const container = document.getElementById('container');
  container.parentNode.removeChild(container);
  
  // 释放JavaScript引用
  elements.container = null;
}
```

#### 4.4 闭包滥用

```javascript
// ❌ 错误：不必要的闭包保留大对象
function createHeavyClosure() {
  const largeData = new Array(1000000).fill("data");
  
  return function() {
    console.log("This function doesn't need largeData, but holds it!");
  };
}

// ✅ 解决方案：避免闭包捕获不必要的数据
function createLightClosure() {
  const largeData = new Array(1000000).fill("data");
  
  // 处理数据，然后释放
  const processed = processData(largeData);
  
  return function() {
    console.log(processed.summary); // 只保留需要的数据
  };
}
```

---

### 5. 内存优化最佳实践

#### 5.1 对象池模式

```javascript
// 对象池：避免频繁创建销毁对象
class ObjectPool {
  constructor(createFn, resetFn) {
    this.createFn = createFn;
    this.resetFn = resetFn;
    this.pool = [];
  }
  
  acquire() {
    return this.pool.length > 0 ? this.pool.pop() : this.createFn();
  }
  
  release(obj) {
    this.resetFn(obj);
    this.pool.push(obj);
  }
}

// 使用示例：向量对象池
const vectorPool = new ObjectPool(
  () => ({ x: 0, y: 0 }),           // 创建函数
  (vec) => { vec.x = 0; vec.y = 0; } // 重置函数
);

// 使用对象池而不是频繁创建新对象
const vec1 = vectorPool.acquire();
vec1.x = 10; vec1.y = 20;
// 使用完毕...
vectorPool.release(vec1);
```

#### 5.2 避免内存峰值

```javascript
// ❌ 错误：一次性处理大量数据
function processAllData(data) {
  const results = data.map(item => heavyProcessing(item)); // 可能内存溢出
  return results;
}

// ✅ 解决方案：分块处理
async function processInChunks(data, chunkSize = 1000) {
  const results = [];
  
  for (let i = 0; i < data.length; i += chunkSize) {
    const chunk = data.slice(i, i + chunkSize);
    const chunkResults = chunk.map(item => heavyProcessing(item));
    results.push(...chunkResults);
    
    // 给垃圾回收器机会
    await new Promise(resolve => setTimeout(resolve, 0));
  }
  
  return results;
}
```

#### 5.3 及时释放引用

```javascript
class DataManager {
  constructor() {
    this.cache = new Map();
    this.listeners = new Set();
  }
  
  addData(key, data) {
    this.cache.set(key, data);
  }
  
  getData(key) {
    return this.cache.get(key);
  }
  
  removeData(key) {
    this.cache.delete(key); // 及时删除不再需要的数据
  }
  
  addListener(listener) {
    this.listeners.add(listener);
  }
  
  removeListener(listener) {
    this.listeners.delete(listener); // 及时移除监听器
  }
  
  // 清理方法
  dispose() {
    this.cache.clear();
    this.listeners.clear();
  }
}
```

---

### 6. 内存监控和调试

#### 6.1 Chrome DevTools 内存分析

```javascript
// 手动触发垃圾回收（在DevTools中）
console.log("Before GC");
// 在DevTools Memory面板点击垃圾回收图标
console.log("After GC");

// 内存使用情况监控
const memory = performance.memory;
console.log(`Used: ${(memory.usedJSHeapSize / 1048576).toFixed(2)} MB`);
console.log(`Total: ${(memory.totalJSHeapSize / 1048576).toFixed(2)} MB`);
console.log(`Limit: ${(memory.jsHeapSizeLimit / 1048576).toFixed(2)} MB`);
```

#### 6.2 内存泄漏检测模式

```javascript
// 创建和清理测试
function testMemoryLeak() {
  const initialMemory = performance.memory.usedJSHeapSize;
  
  // 创建大量对象
  const objects = [];
  for (let i = 0; i < 100000; i++) {
    objects.push({ id: i, data: new Array(100).fill('x') });
  }
  
  // 强制垃圾回收
  if (global.gc) {
    global.gc();
  }
  
  const finalMemory = performance.memory.usedJSHeapSize;
  console.log(`Memory delta: ${(finalMemory - initialMemory) / 1048576} MB`);
}

// 在Node.js中需要添加 --expose-gc 标志
```

---

### 总结

1. **自动管理**：内存分配和释放由引擎自动完成
2. **垃圾回收原理**：基于可达性分析，主要使用标记-清除算法
3. **现代优化**：分代收集、增量标记减少停顿
4. **内存泄漏防范**：
   - 避免意外的全局变量
   - 及时清理定时器和事件监听器
   - 释放不必要的 DOM 引用
   - 谨慎使用闭包
5. **优化策略**：
   - 使用对象池减少内存分配
   - 分块处理大数据集
   - 及时释放对象引用
