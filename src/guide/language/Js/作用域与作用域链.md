# 作用域与作用域链

---

### 第一部分：作用域

作用域决定了代码中变量、函数和对象的**可访问性**和**生命周期**。换句话说，它定义了一套规则，来管理引擎如何在当前作用域以及嵌套的作用域中根据标识符名称进行变量查找。

#### 1. 词法作用域

JavaScript 采用的作用域是 **词法作用域**，也称为**静态作用域**。

*   **核心特征：** 作用域在**代码编写时**（函数定义时）就已经确定了，而不是在代码运行时。
*   **查找规则：** 作用域的层级关系取决于代码在源码中的位置，而不是函数的调用位置或调用方式。

```javascript
const globalVar = 'global';

function outer() {
    const outerVar = 'outer';

    function inner() {
        const innerVar = 'inner';
        console.log(innerVar);   // 'inner' (当前作用域)
        console.log(outerVar);   // 'outer' (父级作用域)
        console.log(globalVar);  // 'global' (全局作用域)
    }
    inner();

    // console.log(innerVar); // ❌ ReferenceError: innerVar is not defined
}
outer();
```
在这个例子中，`inner` 函数在*定义时*就确定了它的作用域链：`inner -> outer -> global`。无论 `inner` 函数在何处被调用，它都能访问到 `outerVar` 和 `globalVar`。

#### 2. 作用域的类型

**a) 全局作用域**
*   在代码的任何地方都可以访问。
*   在浏览器中，全局作用域是 `window` 对象。
*   在最外层声明的变量和函数属于全局作用域。

```javascript
const globalVariable = 'I am global';
function globalFunction() {
    console.log('I am global');
}
// 在浏览器中
console.log(window.globalVariable); // 'I am global'
```

**b) 函数作用域**
*   在函数内部声明的变量、参数、函数，只能在函数内部访问。
*   由 `var` 声明的变量是函数作用域。

```javascript
function myFunction() {
    var localVar = 'I am local';
    if (true) {
        var stillLocal = 'I am still accessible'; // 因为 var 是函数作用域
    }
    console.log(stillLocal); // 'I am still accessible'
}
// console.log(localVar); // ❌ ReferenceError
```

**c) 块级作用域**
*   由一对花括号 `{}` 界定的范围。例如 `if`, `for`, `while` 语句，以及单独的 `{}`。
*   由 `let` 和 `const` 声明的变量是块级作用域。

```javascript
function blockExample() {
    if (true) {
        let blockScoped = 'I am block scoped';
        const alsoBlockScoped = 'Me too';
    }
    // console.log(blockScoped); // ❌ ReferenceError
    // console.log(alsoBlockScoped); // ❌ ReferenceError
}
```

---

### 第二部分：作用域链

作用域链是 JavaScript 实现词法作用域的具体机制。

#### 1. 什么是作用域链？

当在某个作用域内访问一个变量时，JavaScript 引擎会沿着一条链来查找这个变量，这条链就是**作用域链**。

*   **组成：** 当前执行上下文的变量对象 + 所有父级执行上下文的变量对象。
*   **方向：** 从内到外。一旦找到第一个匹配的标识符就会停止搜索。
*   **终点：** 全局作用域。如果全局作用域中仍未找到，则会抛出 `ReferenceError`。

#### 2. 作用域链的创建过程

作用域链在**函数定义时**就被创建并确定了，它基于函数被声明的位置。

```javascript
const a = 1;
function outer() {
    const b = 2;
    function inner() {
        const c = 3;
        console.log(a + b + c); // 6
    }
    return inner;
}

const innerFunc = outer();
innerFunc(); // 输出 6
```

**让我们分析 `inner` 函数的作用域链是如何形成的：**

1.  **定义时：** 当 `inner` 函数被定义在 `outer` 函数内部时，它的**内部属性 `[[Scope]]`** 就被确定了，它保存着 `outer` 函数的作用域链。
2.  **调用时：** 当 `innerFunc()` 被调用时（它指向 `inner` 函数）：
    *   创建 `inner` 函数的执行上下文。
    *   复制 `[[Scope]]` 属性来初始化其作用域链。
    *   将自身的活动对象（包含变量 `c`）推送到作用域链的**前端**。

最终，`inner` 函数执行时的作用域链为：
`[inner的变量对象] -> [outer的变量对象] -> [全局变量对象]`

查找 `a + b + c` 的过程：
1.  在 `inner` 的变量对象中查找 `a`, `b`, `c` -> 找到 `c=3`。
2.  未找到 `a`, `b`，沿着作用域链向上，在 `outer` 的变量对象中查找 -> 找到 `b=2`。
3.  仍未找到 `a`，继续向上，在全局变量对象中查找 -> 找到 `a=1`。
4.  计算 `1 + 2 + 3 = 6`。

---

### 第三部分：关键概念辨析

#### 1. 词法作用域 vs 动态作用域

| 特性 | 词法作用域 | 动态作用域 |
| :--- | :--- | :--- |
| **决定时机** | **函数定义时** | **函数调用时** |
| **关注点** | 函数在**何处声明** | 函数从**何处调用** |
| **语言代表** | **JavaScript**, C, C++ | Bash, Perl (部分模式) |

**JavaScript 词法作用域示例：**
```javascript
const value = 'global';

function foo() {
    console.log(value);
}

function bar() {
    const value = 'local';
    foo(); // 调用 foo
}

bar(); // 输出 'global'，而不是 'local'
```
解释：`foo` 在定义时，它的作用域链就已经确定了，包含全局作用域。所以当它查找 `value` 时，找到的是全局的 `value`，而不是调用它的地方 `bar` 中的 `value`。

#### 2. 作用域链 vs 原型链

| 特性 | 作用域链 | 原型链 |
| :--- | :--- | :--- |
| **目的** | **变量和函数的查找** | **对象属性的查找** |
| **适用对象** | 函数、执行上下文 | 对象实例 |
| **组成** | 变量对象/活动对象 | 原型对象 |
| **终点** | 全局作用域 -> `null` | `Object.prototype` -> `null` |

```javascript
// 作用域链
const a = 1;
function test() {
    console.log(a); // 通过作用域链查找变量 a
}

// 原型链
const obj = {};
console.log(obj.toString()); // 通过原型链查找方法 toString
// obj -> Object.prototype -> null
```

---

### 第四部分：实践意义与总结

**作用域和作用域链的重要性体现在：**

1.  **闭包的基础：** 闭包就是函数能够记住并访问其词法作用域，即使该函数在其作用域之外执行。这完全依赖于作用域链的机制。
2.  **变量命名与冲突解决：** 理解作用域可以避免变量命名冲突，合理设计代码结构。
3.  **内存管理：** 当函数执行完毕后，如果其作用域链上的某个变量不再被任何地方引用（例如没有被闭包引用），那么这个变量就会被垃圾回收。
4.  **性能优化：** 引擎在查找变量时，作用域链的层级越深，查找速度越慢。因此，应尽量避免过多的全局变量查找和过深的作用域嵌套。

### 总结

*   **作用域** 是一套关于**变量可见性**的规则，它在代码书写时（词法阶段）就已经确定。
*   **作用域链** 是实现这套规则的具体**机制**。它是一个由变量对象组成的链表，保证了函数在执行时能够有序地访问其定义时所处环境中的变量。

**作用域是“规则”，作用域链是“实现规则的路径”。** 。