# 柯里化函数

---

### 1. 核心定义

**柯里化** 是一种将使用**多个参数**的一个函数，转换成一系列使用**一个参数**的函数的技术。

柯里化会**固定一个函数的一些参数，然后产生另一个更小元（参数更少）的函数**。

**元：** 指的是函数的参数个数。比如一个接受两个参数的函数是二元函数。

---

### 2. 直观示例：从普通函数到柯里化函数

假设我们有一个简单的加法函数：

```javascript
// 普通函数
function add(a, b, c) {
  return a + b + c;
}
console.log(add(1, 2, 3)); // 6
```

它的柯里化版本看起来会是这样的：

```javascript
// 柯里化后的函数
function curriedAdd(a) {
  return function(b) {
    return function(c) {
      return a + b + c;
    };
  };
}

// 调用方式发生了变化
console.log(curriedAdd(1)(2)(3)); // 6

// 柯里化的魔力：可以分步调用，并“记住”之前的参数
const add1 = curriedAdd(1);     // 记住 a=1，返回一个等待 b 的函数
const add1And2 = add1(2);       // 记住 b=2，返回一个等待 c 的函数
const result = add1And2(3);     // 传入 c=3，计算并返回 1+2+3=6
console.log(result); // 6
```

**核心观察：**
*   调用柯里化函数时，每次只传递一个（或一部分）参数。
*   每次调用都会返回一个新的函数，这个新函数记住了之前传入的所有参数，并等待剩余的参数。
*   直到所有参数都被提供，最终结果才会被计算出来。

---

### 3. 实现一个通用的柯里化工具函数

**基础版本实现：**

```javascript
function curry(fn) {
  // 返回一个新的柯里化函数
  return function curried(...args) {
    // 判断当前传入的参数个数是否大于或等于原函数的参数个数
    if (args.length >= fn.length) {
      // 如果是，说明参数已经足够，直接调用原函数并返回结果
      return fn.apply(this, args);
    } else {
      // 如果否，说明参数还不够，需要返回一个新的函数来等待剩余参数
      return function(...nextArgs) {
        // 递归调用 curried，将之前收集的参数和新的参数合并
        return curried.apply(this, args.concat(nextArgs));
      };
    }
  };
}
```

**使用示例：**

```javascript
// 目标函数
function sum(a, b, c) {
  return a + b + c;
}

// 柯里化它
const curriedSum = curry(sum);

// 多种调用方式
console.log(curriedSum(1, 2, 3)); // 6，一次性调用
console.log(curriedSum(1)(2, 3)); // 6，混合调用
console.log(curriedSum(1)(2)(3)); // 6，经典柯里化调用

// 创建有用的中间函数
const addTwo = curriedSum(1)(1); // 固定了前两个参数为1
console.log(addTwo(5)); // 7 (1+1+5)
```

**实现原理深度解析：**
1.  `curry` 函数接收一个需要被柯里化的函数 `fn`。
2.  它返回一个新的函数 `curried`。
3.  当调用 `curried` 时，它会检查传入的参数 `args` 的个数。
4.  **关键逻辑：** `args.length >= fn.length`
    *   `fn.length` 是函数定义时的**形参个数**。
    *   如果传入的参数够了，就直接执行原函数 `fn`。
    *   如果不够，就返回一个新的函数，这个新函数会**递归地调用 `curried`**，并将之前收集的参数 `args` 和新的参数 `nextArgs` 合并起来。
5.  这个过程会一直持续，直到参数数量满足要求，最终计算出结果。

---

### 4. 柯里化的高级变体：支持占位符

有时我们可能希望先跳过某些参数，在后续调用中再提供。我们可以实现一个支持占位符的柯里化函数。

```javascript
function curryWithPlaceholder(fn) {
  return function curried(...args) {
    // 检查参数是否足够，并且没有占位符
    const complete = args.length >= fn.length && !args.slice(0, fn.length).includes(curryWithPlaceholder.placeholder);
    
    if (complete) {
      return fn.apply(this, args);
    } else {
      return function(...nextArgs) {
        // 合并参数：用 nextArgs 中的真实参数替换 args 中的占位符
        const mergedArgs = [];
        let argsIndex = 0;
        let nextArgsIndex = 0;
        
        // 遍历原始参数列表
        while (argsIndex < args.length && mergedArgs.length < fn.length) {
          if (args[argsIndex] === curryWithPlaceholder.placeholder && nextArgsIndex < nextArgs.length) {
            // 如果是占位符，并且还有新参数，就用新参数替换
            mergedArgs.push(nextArgs[nextArgsIndex]);
            nextArgsIndex++;
          } else {
            // 否则，保留原参数
            mergedArgs.push(args[argsIndex]);
          }
          argsIndex++;
        }
        
        // 如果还有剩余的新参数，追加到后面
        while (nextArgsIndex < nextArgs.length && mergedArgs.length < fn.length) {
          mergedArgs.push(nextArgs[nextArgsIndex]);
          nextArgsIndex++;
        }
        
        return curried.apply(this, mergedArgs);
      };
    }
  };
}

// 定义占位符
curryWithPlaceholder.placeholder = Symbol('placeholder');
const _ = curryWithPlaceholder.placeholder;

// 使用示例
function log(level, message, source) {
  console.log(`[${level}] ${source}: ${message}`);
}

const curriedLog = curryWithPlaceholder(log);

const logInfo = curriedLog('INFO'); // 固定 level
const logFromFrontend = curriedLog(_, _, 'Frontend'); // 固定 source，跳过前两个参数

logInfo('User logged in', 'Auth'); // [INFO] Auth: User logged in
logFromFrontend('ERROR', 'API call failed'); // [ERROR] Frontend: API call failed
```

---

### 5. 柯里化的应用场景与优势

1.  **参数复用（创建专用函数）：**
    ```javascript
    // 一个普通的匹配URL正则的函数
    function match(regExp, str) {
      return str.match(regExp);
    }
    
    // 柯里化后
    const curryMatch = curry(match);
    const hasNumber = curryMatch(/\d+/g); // 创建一个专门检查数字的函数
    const hasLetter = curryMatch(/[a-zA-Z]+/g); // 创建一个专门检查字母的函数
    
    console.log(hasNumber('abc123')); // ['123']
    console.log(hasLetter('123'));    // null
    ```

2.  **延迟执行/运行：**
    柯里化函数在接收到所有参数之前，不会真正执行计算。这为控制执行时机提供了灵活性。

3.  **函数组合的前置条件：**
    在函数式编程中，我们经常将多个小函数组合成一个大函数。柯里化使得每个小函数的输入输出格式非常统一（一个输入，一个输出），极大地便利了组合。
    ```javascript
    const compose = (f, g) => x => f(g(x));
    const curriedAdd = curry((a, b) => a + b);
    const curriedMultiply = curry((a, b) => a * b);
    
    const addThenMultiply = compose(curriedMultiply(10), curriedAdd(5));
    console.log(addThenMultiply(3)); // (3+5) * 10 = 80
    ```

4.  **提高代码的声明性和可读性：**
    ```javascript
    // 不柯里化
    ['1', '2', '3'].map(str => parseInt(str, 10));
    
    // 使用柯里化后
    const curriedParseInt = curry(parseInt);
    const parseDecimal = curriedParseInt(_, 10); // 固定进制为10
    ['1', '2', '3'].map(parseDecimal); // 代码更声明式，意图更清晰
    ```

---

### 总结

柯里化是一种强大的函数转换技术，它通过**拆分参数**和**返回新函数**的方式，将一个多参数函数转化为一系列单参数函数。

*   **核心价值：** 参数复用、创建更专用的函数、便于函数组合。
*   **实现关键：** 比较已收集的参数长度与原函数形参长度，通过递归返回新函数来持续收集参数。
*   **与现代JS的关系：** 虽然我们可以手动实现柯里化，但在实际项目中，像Lodash的 `_.curry` 这样的工具函数更为常用和可靠。然而，理解其原理对于掌握函数式编程思想至关重要。
