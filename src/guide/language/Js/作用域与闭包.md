# 作用域与闭包
---

### 第一部分：作用域

作用域决定了代码中变量和函数的**可访问性**和**生命周期**。

#### 1. 词法作用域

JavaScript 采用的是**词法作用域**，也称为静态作用域。

*   **定义：** 变量的作用域在**代码编写阶段**（函数定义时）就已经确定了，而不是在运行时。
*   **规则：** 内部作用域可以访问外部作用域的变量，但外部作用域不能访问内部作用域的变量。查找变量时，会从当前作用域开始，逐级向上级作用域查找。

```javascript
const globalVar = 'global';

function outer() {
    const outerVar = 'outer';

    function inner() {
        const innerVar = 'inner';
        console.log(innerVar);   // 'inner' (当前作用域)
        console.log(outerVar);   // 'outer' (父级作用域)
        console.log(globalVar);  // 'global' (全局作用域)
    }
    inner();

    // console.log(innerVar); // ❌ ReferenceError: innerVar is not defined
}
outer();
```
在这个例子中，`inner` 函数在*定义时*就确定了它可以访问 `outerVar` 和 `globalVar`，无论它在哪里被调用。

#### 2. 作用域链

当在某个作用域内访问一个变量时，JavaScript 引擎会沿着一条链来查找这个变量，这条链就是**作用域链**。

*   **组成：** 当前执行上下文的变量对象 + 所有父级执行上下文的变量对象。
*   **方向：** 从内到外。一旦找到第一个匹配的变量就会停止搜索。

#### 3. 块级作用域

ES6 引入了 `let` 和 `const` 关键字，带来了块级作用域。

*   **定义：** 由一对花括号 `{}` 界定的范围。例如 `if`, `for`, `while` 语句内部。
*   **与 `var` 的区别：**
    *   `var` 是函数作用域，在整个函数内部都可见。
    *   `let/const` 是块级作用域，只在定义它的 `{}` 内可见。

```javascript
// 使用 var
for (var i = 0; i < 3; i++) {
    // ...
}
console.log(i); // 3 (变量 i 泄露到了全局或函数作用域)

// 使用 let
for (let j = 0; j < 3; j++) {
    // ...
}
console.log(j); // ❌ ReferenceError: j is not defined
```

---

### 第二部分：闭包

闭包是作用域概念的直接产物和最高体现。

#### 1. 闭包的定义

**闭包是指一个函数能够记住并访问其词法作用域，即使该函数在其词法作用域之外执行。**

**简单来说：函数 A 返回了一个函数 B，函数 B 引用了函数 A 内部的变量。当函数 A 执行完毕后，由于函数 B 仍然持有对函数 A 内部变量的引用，这些变量不会被销毁，函数 B 就是一个闭包。**

#### 2. 闭包的产生与原理

**产生条件：**
1.  存在函数的嵌套。
2.  内部函数引用了外部函数的数据（变量、参数）。
3.  内部函数在其外部函数之外被调用。

**原理：** 根据词法作用域的规则，内部函数在定义时就确定了它有权访问的外部函数的作用域。当外部函数执行完毕后，其执行上下文会从调用栈中弹出，但由于内部函数（闭包）仍然保持着对那个作用域的引用，这个作用域（及其变量）不会被垃圾回收器回收，从而形成了一个“持久”的、私有的数据存储空间。

```javascript
function createCounter() {
  let count = 0; // count 是 createCounter 的局部变量

  // 返回一个闭包函数
  return function() {
    count++;    // 内部函数引用了外部变量 count
    return count;
  };
}

// 即使 createCounter 已经执行完毕，count 变量依然“活着”
const counter = createCounter();
console.log(counter()); // 1
console.log(counter()); // 2
console.log(counter()); // 3
```

**深度解析 `createCounter` 例子：**
1.  调用 `createCounter()`，创建执行上下文，其中包含变量 `count = 0`。
2.  它返回内部函数，该函数持有对 `count` 的引用。
3.  `createCounter` 执行完毕，其执行上下文理论上应被销毁。但由于返回的内部函数（被 `counter` 引用）仍然需要访问 `count`，JavaScript 引擎会**保持 `count` 所在的作用域存活**。
4.  每次调用 `counter()`，它操作的都是同一个 `count` 变量。

---

### 第三部分：作用域与闭包的关联与区别

| 特性 | 作用域 | 闭包 |
| :--- | :--- | :--- |
| **定义** | 变量和函数的可访问范围。 | 函数**保持**对其**词法作用域**访问的能力。 |
| **确定时机** | 代码编写时（词法作用域）。 | 函数被**定义**时。 |
| **核心关系** | 闭包是**基于词法作用域**产生的。没有词法作用域，就没有闭包。 | 闭包是作用域规则的**一种体现和应用**。 |
| **生命周期** | 通常，函数执行完毕，其局部作用域就被销毁。 | 即使外部函数执行完毕，其作用域**依然被闭包保留**，直到闭包本身不再被引用。 |

**一句话总结：作用域是“规则”，闭包是“能力”。作用域规定了哪里可以访问变量，而闭包则允许函数突破作用域链的生命周期限制，“记住”并访问它被定义时的环境。**

---

### 第四部分：闭包的经典应用场景

1.  **数据封装与私有变量：** 模拟其他语言的私有成员。
    ```javascript
    function createBankAccount(initialBalance) {
      let balance = initialBalance; // 私有变量，外部无法直接访问

      return {
        deposit: function(amount) {
          balance += amount;
          return balance;
        },
        withdraw: function(amount) {
          if (amount <= balance) {
            balance -= amount;
            return balance;
          } else {
            return "Insufficient funds";
          }
        },
        getBalance: function() {
          return balance;
        }
      };
    }

    const account = createBankAccount(100);
    console.log(account.getBalance()); // 100
    account.deposit(50);
    console.log(account.getBalance()); // 150
    // console.log(balance); // ❌ ReferenceError: balance is not defined
    ```

2.  **回调函数与异步编程：** 在定时器、事件监听器、Ajax请求中，回调函数常常形成闭包，以访问定义时的环境。
    ```javascript
    function sayHelloLater(name) {
      // 回调函数形成了一个闭包，记住了 `name`
      setTimeout(function() {
        console.log('Hello, ' + name);
      }, 1000);
    }
    sayHelloLater('Alice'); // 一秒后输出 "Hello, Alice"
    ```

3.  **函数柯里化与部分应用：** 预先固定一些参数。
    ```javascript
    function multiply(a, b) {
      return a * b;
    }
    // 创建一个闭包，固定第一个参数为 2
    const double = multiply.bind(null, 2);
    console.log(double(5)); // 10
    ```

4.  **模块模式：** 现代ES6模块出现之前，利用闭包创建模块是主流方式。
    ```javascript
    const MyModule = (function() {
      let privateVar = 0;

      function privateFunction() {
        return privateVar;
      }

      return {
        publicMethod: function() {
          privateVar++;
          return privateFunction();
        }
      };
    })();

    console.log(MyModule.publicMethod()); // 1
    ```

---

### 总结
1.  **内存泄漏：** 如果不需用的闭包仍被引用，其保留的作用域就无法被回收，可能导致内存占用过高。解决方法是及时解除对闭包的引用（如 `null`）。
2.  **性能考量：** 闭包会比其他函数占用更多内存，因为需要存储整个作用域链。但在大多数情况下，这种开销是可以接受的。

作用域和闭包是 JavaScript 中密不可分的两个概念。
*   **作用域** 是一套关于变量可见性的规则，它在代码书写时就已经确定。
*   **闭包** 是 JavaScript 遵守词法作用域规则的必然结果。它让函数拥有了“记忆”，能够访问其定义时的作用域，即使该作用域已经执行结束。
