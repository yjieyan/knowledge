# 防抖与节流
防抖和节流是两种的**性能优化技术**，它们用于控制函数在高频事件中的执行频率，避免过多的资源消耗。虽然目标相似，但它们的应用场景和原理有本质区别。

---

### 1. 核心概念与要解决的问题

**共同背景：** 在浏览器中，某些事件（如 `resize`, `scroll`, `input`, `mousemove`）的触发频率非常高，远超过实际需要的处理频率。如果每次事件触发都执行相应的回调函数，可能会导致严重的性能问题（如页面卡顿、资源浪费）。

**核心思想：** 通过限制函数调用的频率来优化性能。

---

### 2. 防抖

#### 定义

**防抖** 的核心思想是：在事件被触发后，等待一段固定的时间再执行函数。如果在这段固定时间内事件又被触发，则**取消之前的等待，重新开始计时**。

**简单比喻：** 就像电梯的自动门。有人进电梯后，电梯门开始等待（比如5秒）。如果在这5秒内又有人要进来，电梯门会重新等待5秒。直到连续5秒都没有新的人进来，电梯门才会关闭。

#### 实现原理

1.  设置一个定时器。
2.  每次事件触发时，都清除之前的定时器，并设置一个新的定时器。
3.  只有在最后一次事件触发后，等待时间结束，函数才会被执行。

#### 代码实现

**基础版本：**
```javascript
function debounce(func, wait) {
  let timeoutId;
  
  return function(...args) {
    // 清除之前的定时器
    clearTimeout(timeoutId);
    
    // 设置新的定时器
    timeoutId = setTimeout(() => {
      func.apply(this, args);
    }, wait);
  };
}
```

**带立即执行选项的版本：**
```javascript
function debounce(func, wait, immediate = false) {
  let timeoutId;
  
  return function(...args) {
    const context = this;
    
    const later = function() {
      timeoutId = null;
      if (!immediate) {
        func.apply(context, args);
      }
    };
    
    const callNow = immediate && !timeoutId;
    
    clearTimeout(timeoutId);
    timeoutId = setTimeout(later, wait);
    
    if (callNow) {
      func.apply(context, args);
    }
  };
}
```

#### 应用场景

1.  **搜索框输入建议：** 用户在输入过程中不需要实时请求，而是在用户停止输入一段时间后再发起请求。
2.  **窗口大小调整：** 在用户拖拽调整窗口大小时，不需要实时计算布局，而是在调整结束后再计算。
3.  **表单验证：** 在用户输入完成后，再进行验证，而不是每输入一个字符就验证。

**示例：**
```javascript
const searchInput = document.getElementById('search');

const fetchSearchResults = debounce(function(query) {
  // 模拟API请求
  console.log(`Searching for: ${query}`);
  // fetch(`/api/search?q=${query}`).then(...);
}, 500);

searchInput.addEventListener('input', (e) => {
  fetchSearchResults(e.target.value);
});
```

---

### 3. 节流

#### 定义

**节流** 的核心思想是：在一段时间内，函数**最多执行一次**。无论这段时间内事件触发了多少次，函数都会按照固定的时间间隔执行。

**简单比喻：** 就像游戏中的技能冷却时间。你按下一个技能键后，技能立即释放，然后进入冷却时间。在冷却时间内，无论你怎么按这个键，技能都不会再次释放。

#### 实现原理

1.  记录上一次函数执行的时间戳。
2.  每次事件触发时，检查当前时间与上次执行时间的差值是否大于设定的时间间隔。
3.  如果大于，则执行函数并更新上次执行时间；如果小于，则忽略这次触发。

#### 代码实现

**时间戳版本：**
```javascript
function throttle(func, wait) {
  let lastTime = 0;
  
  return function(...args) {
    const now = Date.now();
    
    if (now - lastTime >= wait) {
      func.apply(this, args);
      lastTime = now;
    }
  };
}
```

**定时器版本：**
```javascript
function throttle(func, wait) {
  let timeoutId = null;
  
  return function(...args) {
    if (!timeoutId) {
      timeoutId = setTimeout(() => {
        func.apply(this, args);
        timeoutId = null;
      }, wait);
    }
  };
}
```

**更精确的版本（结合两者）：**
```javascript
function throttle(func, wait) {
  let timeoutId = null;
  let lastTime = 0;
  
  return function(...args) {
    const now = Date.now();
    const remaining = wait - (now - lastTime);
    
    if (remaining <= 0 || remaining > wait) {
      if (timeoutId) {
        clearTimeout(timeoutId);
        timeoutId = null;
      }
      func.apply(this, args);
      lastTime = now;
    } else if (!timeoutId) {
      timeoutId = setTimeout(() => {
        lastTime = Date.now();
        timeoutId = null;
        func.apply(this, args);
      }, remaining);
    }
  };
}
```

#### 应用场景

1.  **页面滚动加载更多：** 在用户滚动页面时，定期检查是否应该加载更多内容。
2.  **鼠标移动事件：** 如拖拽、绘制等高频率操作。
3.  **游戏中的按键处理：** 确保角色移动等操作有合理的频率。
4.  **限制API请求频率：** 防止用户过快点击按钮发送重复请求。

**示例：**
```javascript
const handleScroll = throttle(function() {
  const scrollTop = window.pageYOffset;
  const windowHeight = window.innerHeight;
  const documentHeight = document.documentElement.scrollHeight;
  
  if (scrollTop + windowHeight >= documentHeight - 100) {
    console.log('Loading more content...');
    // loadMoreContent();
  }
}, 200);

window.addEventListener('scroll', handleScroll);
```

---

### 4. 防抖与节流的对比总结

| 特性 | 防抖 | 节流 |
| :--- | :--- | :--- |
| **核心思想** | **"最后一个人说了算"** | **"固定频率执行"** |
| **执行时机** | 事件停止触发后，等待一段时间执行 | 按照固定的时间间隔执行 |
| **重置机制** | 每次新事件都会重置计时器 | 不会重置，严格按照时间间隔 |
| **执行次数** | 只执行最后一次 | 周期性执行 |
| **适用场景** | 搜索建议、窗口调整、输入验证 | 滚动加载、鼠标移动、游戏操作 |

---

### 5. 可视化理解

让我们通过时间线来理解两者的区别：

```
事件触发:    A  B  C    D  E  F  G        H
时间线:    |--|--|--|--|--|--|--|--|--|--|

防抖 (等待时间 = 2单位):
执行:                      C         G         H
解释: A触发→等待→B触发(重置)→C触发(重置)→等待结束→执行C
      D触发→等待→E触发(重置)→F触发(重置)→G触发(重置)→等待结束→执行G
      H触发→等待结束→执行H

节流 (间隔时间 = 2单位):
执行:       A          C          E          G          H
解释: A立即执行→B被忽略→C在间隔后执行→D被忽略→E在间隔后执行→F被忽略→G在间隔后执行→H在间隔后执行
```

---

### 6. 在现代前端框架中的使用

**React Hooks 示例：**

```javascript
import { useCallback, useRef } from 'react';

// 防抖 Hook
function useDebounce(callback, delay) {
  const timeoutRef = useRef();
  
  return useCallback((...args) => {
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
    }
    
    timeoutRef.current = setTimeout(() => {
      callback(...args);
    }, delay);
  }, [callback, delay]);
}

// 节流 Hook  
function useThrottle(callback, delay) {
  const lastExecuted = useRef(0);
  
  return useCallback((...args) => {
    const now = Date.now();
    
    if (now - lastExecuted.current >= delay) {
      callback(...args);
      lastExecuted.current = now;
    }
  }, [callback, delay]);
}
```

### 总结

*   **防抖** 关注的是 **"最后一次"**，适合**结果型**场景（如搜索建议）。
*   **节流** 关注的是 **"固定频率"**，适合**过程型**场景（如滚动加载）。
