# 数据类型检测

---

### 1. `typeof` 操作符

**`typeof` 是最常用的类型检测手段，但它存在一些著名的缺陷。**

#### 基本用法：
```javascript
console.log(typeof 42);           // "number"
console.log(typeof 'hello');      // "string"
console.log(typeof true);         // "boolean"
console.log(typeof undefined);    // "undefined"
console.log(typeof function(){}); // "function"
console.log(typeof Symbol());     // "symbol"
console.log(typeof 123n);         // "bigint"
```

#### 著名的缺陷：
```javascript
// 1. null 的检测问题
console.log(typeof null);         // "object" (历史遗留bug)

// 2. 数组的检测问题  
console.log(typeof []);           // "object"
console.log(typeof {});           // "object"

// 3. 包装对象的问题
console.log(typeof new String('hello'));  // "object"
console.log(typeof String('hello'));      // "string"
```

#### 总结：
- **适用：** 基本类型（除 `null`）、`function`、`undefined`
- **不适用：** `null`、数组、普通对象、包装对象等（都返回 `"object"`）

---

### 2. `instanceof` 操作符

**`instanceof` 用于检测构造函数的 `prototype` 属性是否出现在对象的原型链上。**

#### 基本用法：
```javascript
console.log([] instanceof Array);           // true
console.log({} instanceof Object);          // true
console.log(function(){} instanceof Function); // true
console.log(new Date() instanceof Date);    // true

// 自定义构造函数
function Person(name) { this.name = name; }
const john = new Person('John');
console.log(john instanceof Person);        // true
```

#### 局限性：
```javascript
// 1. 基本类型无法检测
console.log('hello' instanceof String);     // false
console.log(42 instanceof Number);          // false

// 2. 跨窗口/iframe 问题
const iframe = document.createElement('iframe');
document.body.appendChild(iframe);
const iframeArray = iframe.contentWindow.Array;
const arr = new iframeArray();
console.log(arr instanceof Array);          // false (不同执行环境)
console.log(Array.isArray(arr));            // true

// 3. 原型链被修改的情况
const obj = {};
console.log(obj instanceof Object);         // true
Object.setPrototypeOf(obj, null);
console.log(obj instanceof Object);         // false
```

#### 总结：
- **适用：** 对象类型检测、自定义构造函数实例检测
- **不适用：** 基本类型、跨执行环境检测

---

### 3. `Object.prototype.toString.call()` - **最可靠的检测方法**

**这是 JavaScript 中最准确、最可靠的类型检测方法。**

#### 基本原理：
每个对象都有一个 `toString` 方法，当这个方法被直接调用时，会返回 `[object Type]` 格式的字符串，其中 `Type` 是对象的内部类型。

#### 基本用法：
```javascript
console.log(Object.prototype.toString.call(42));           // "[object Number]"
console.log(Object.prototype.toString.call('hello'));      // "[object String]"
console.log(Object.prototype.toString.call(true));         // "[object Boolean]"
console.log(Object.prototype.toString.call(null));         // "[object Null]"
console.log(Object.prototype.toString.call(undefined));    // "[object Undefined]"
console.log(Object.prototype.toString.call([]));           // "[object Array]"
console.log(Object.prototype.toString.call({}));           // "[object Object]"
console.log(Object.prototype.toString.call(function(){})); // "[object Function]"
console.log(Object.prototype.toString.call(Symbol()));     // "[object Symbol]"
console.log(Object.prototype.toString.call(123n));         // "[object BigInt]"
console.log(Object.prototype.toString.call(new Date()));   // "[object Date]"
console.log(Object.prototype.toString.call(/regex/));      // "[object RegExp]"
console.log(Object.prototype.toString.call(new Error()));  // "[object Error]"
console.log(Object.prototype.toString.call(Math));         // "[object Math]" (内置对象)
console.log(Object.prototype.toString.call(JSON));         // "[object JSON]" (内置对象)
```

#### 封装成实用函数：
```javascript
function getType(value) {
  return Object.prototype.toString.call(value).slice(8, -1).toLowerCase();
}

console.log(getType(42));        // "number"
console.log(getType('hello'));   // "string" 
console.log(getType([]));        // "array"
console.log(getType(null));      // "null"
console.log(getType(undefined)); // "undefined"
console.log(getType(/regex/));   // "regexp"
```

#### 为什么这是最可靠的方法？
1. **准确区分所有内置类型**
2. **不受跨执行环境影响**
3. **不受原型链修改影响**
4. **能检测 `null` 和 `undefined`**

---

### 4. 专门的检测方法

#### `Array.isArray()` - 检测数组
```javascript
console.log(Array.isArray([]));           // true
console.log(Array.isArray({}));           // false
console.log(Array.isArray('array'));      // false

// 解决 instanceof 的跨窗口问题
const iframe = document.createElement('iframe');
document.body.appendChild(iframe);
const iframeArray = iframe.contentWindow.Array;
const arr = new iframeArray();
console.log(Array.isArray(arr));          // true
console.log(arr instanceof Array);        // false
```

#### `Number.isNaN()` vs `isNaN()` - 检测 NaN
```javascript
// 全局的 isNaN 会先尝试转换为数字
console.log(isNaN('123'));        // false (字符串'123'转换为数字123，不是NaN)
console.log(isNaN('hello'));      // true (字符串'hello'转换为数字是NaN)
console.log(isNaN(undefined));    // true

// Number.isNaN 不会进行类型转换
console.log(Number.isNaN('123'));     // false (字符串，不是NaN)
console.log(Number.isNaN('hello'));   // false (字符串，不是NaN)  
console.log(Number.isNaN(NaN));       // true (只有真正的NaN才返回true)
```

---

### 5. 其他有用的检测方法

#### 检测 `null` 或 `undefined`
```javascript
// 宽松相等（推荐）
console.log(value == null);  // true if value is null or undefined

// 严格分别检测
console.log(value === null);
console.log(value === undefined);
```

#### 检测纯对象（plain object）
```javascript
function isPlainObject(obj) {
  return Object.prototype.toString.call(obj) === '[object Object]' &&
         Object.getPrototypeOf(obj) === Object.prototype;
}

console.log(isPlainObject({}));           // true
console.log(isPlainObject([]));           // false
console.log(isPlainObject(new Date()));   // false
console.log(isPlainObject(null));         // false
```

#### 检测函数
```javascript
function isFunction(value) {
  return typeof value === 'function' || 
         Object.prototype.toString.call(value) === '[object Function]';
}

console.log(isFunction(function(){}));    // true
console.log(isFunction(() => {}));        // true
console.log(isFunction(class {}));        // true
console.log(isFunction({}));              // false
```

---

### 6. 现代 JavaScript 的补充

#### `typeof` 对 ES6+ 的支持
```javascript
// ES6 Symbol
console.log(typeof Symbol());     // "symbol"

// ES2020 BigInt  
console.log(typeof 123n);         // "bigint"
```

#### 可选链操作符与类型检测结合
```javascript
// 安全的属性访问和类型检测
function safeCheck(obj) {
  return obj?.method?.();  // 如果obj或obj.method为null/undefined，返回undefined
}

const result = someAPI.getData?.().then?.(handleData);
```

---

### 7. 综合工具函数

在实际项目中，可以封装一个全面的类型检测工具：

```javascript
class TypeChecker {
  static getType(value) {
    return Object.prototype.toString.call(value).slice(8, -1).toLowerCase();
  }
  
  static isNumber(value) {
    return typeof value === 'number' && !isNaN(value);
  }
  
  static isString(value) {
    return typeof value === 'string';
  }
  
  static isBoolean(value) {
    return typeof value === 'boolean';
  }
  
  static isArray(value) {
    return Array.isArray(value);
  }
  
  static isObject(value) {
    return value !== null && typeof value === 'object' && !Array.isArray(value);
  }
  
  static isFunction(value) {
    return typeof value === 'function';
  }
  
  static isNull(value) {
    return value === null;
  }
  
  static isUndefined(value) {
    return value === undefined;
  }
  
  static isNil(value) {
    return value == null; // null or undefined
  }
  
  static isEmpty(value) {
    if (this.isNil(value)) return true;
    if (this.isArray(value) || this.isString(value)) return value.length === 0;
    if (this.isObject(value)) return Object.keys(value).length === 0;
    return false;
  }
}

// 使用示例
console.log(TypeChecker.getType([]));              // "array"
console.log(TypeChecker.isNumber(42));             // true
console.log(TypeChecker.isNumber('42'));           // false
console.log(TypeChecker.isEmpty([]));              // true
console.log(TypeChecker.isEmpty({}));              // true
console.log(TypeChecker.isEmpty(''));              // true
console.log(TypeChecker.isEmpty(null));            // true
```

---

### 总结与选择指南

| 检测方法 | 优点 | 缺点 | 适用场景 |
|---------|------|------|----------|
| **`typeof`** | 简单、快速 | 无法区分`null`、数组、对象 | 基本类型、函数检测 |
| **`instanceof`** | 检测构造函数关系 | 跨环境问题、不适用基本类型 | 自定义类型、内置对象实例 |
| **`Object.prototype.toString.call()`** | **最准确、最全面** | 语法稍复杂 | **需要精确类型检测时** |
| **`Array.isArray()`** | 专门检测数组、解决跨环境问题 | 仅限数组检测 | 数组检测 |
| **`Number.isNaN()`** | 准确检测NaN | 仅限NaN检测 | NaN检测 |

**最佳实践建议：**
1. **日常使用：** `typeof` 用于基本类型，`Array.isArray()` 用于数组
2. **精确检测：** `Object.prototype.toString.call()` 
3. **自定义类型：** `instanceof` 
4. **安全检测：** 结合可选链操作符 `?.`
