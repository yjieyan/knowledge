# 错误处理

---

### 1. 前端错误的分类

理解错误类型是有效处理它们的前提。

#### a) 运行时错误
代码在执行过程中发生的错误。

*   **`SyntaxError`（语法错误）：** 代码不符合 JavaScript 语法规范，通常在代码解析阶段就会报错，无法被 `try...catch` 捕获。
    ```javascript
    // 编译阶段就会失败
    const a = ; // Uncaught SyntaxError: Unexpected token ';'
    ```

*   **`ReferenceError`（引用错误）：** 访问未声明的变量。
    ```javascript
    console.log(undefinedVariable); // Uncaught ReferenceError: undefinedVariable is not defined
    ```

*   **`TypeError`（类型错误）：** 变量或参数不是预期类型。
    ```javascript
    const foo = null;
    foo.bar(); // Uncaught TypeError: Cannot read properties of null (reading 'bar')
    ```

*   **`RangeError`（范围错误）：** 数值变量或参数超出其有效范围。
    ```javascript
    const arr = new Array(-1); // Uncaught RangeError: Invalid array length
    ```

*   **`URIError`（[URI](./URI.md)错误）：** 给 `encodeURI()` 或 `decodeURI()` 传递了无效参数。
    ```javascript
    decodeURIComponent('%'); // Uncaught URIError: URI malformed
    ```

#### b) 资源加载错误
图片、脚本、样式表等外部资源加载失败。
```html
<img src="nonexistent-image.jpg" onerror="handleImageError(this)">
<script src="non-existent-script.js"></script>
```

#### c) 网络请求错误
AJAX / Fetch 请求失败，如 4xx, 5xx 状态码、超时、跨域问题等。
```javascript
fetch('/api/data')
  .then(response => {
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }
    return response.json();
  })
  .catch(error => console.error('Fetch failed:', error));
```

#### d) 异步错误
在 `setTimeout`, `Promise`, 事件回调等异步上下文中抛出的错误，如果不额外处理，外层的 `try...catch` 无法捕获。
```javascript
// ❌ 无法被外部的 try-catch 捕获
try {
  setTimeout(() => {
    throw new Error('Async error!');
  }, 1000);
} catch (error) {
  console.log('This will not run:', error);
}

// ✅ 正确的做法是在异步函数内部处理
setTimeout(() => {
  try {
    throw new Error('Async error!');
  } catch (error) {
    console.log('Caught inside:', error);
  }
}, 1000);
```

#### e) Promise 拒绝
Promise 被 `reject` 但没有被 `.catch()` 处理。
```javascript
// 会导致 UnhandledPromiseRejectionWarning
someAsyncFunction().then(result => {
  throw new Error('Something went wrong in then');
});
```

---

### 2. 错误处理机制

#### a) `try...catch...finally` - 同步错误的守护者
这是处理同步错误最基本、最直接的方式。

```javascript
function riskyOperation(data) {
  try {
    // 可能会抛出错误的代码
    const parsed = JSON.parse(data);
    if (!parsed.name) {
      throw new Error('Name is required'); // 主动抛出错误
    }
    return parsed;
  } catch (error) {
    // 错误处理
    console.error('Operation failed:', error.message);
    
    // 可以选择恢复、重试、或上报错误
    return { name: 'Default Name' }; // 恢复策略
  } finally {
    // 无论是否发生错误都会执行
    console.log('Operation attempted');
  }
}
```

#### b) `Promise.catch()` 和 `async/await` - 异步错误的解决方案

**Promise 链：**
```javascript
fetch('/api/data')
  .then(validateResponse)
  .then(processData)
  .catch(error => {
    // 捕获前面所有 then 中抛出的错误
    console.error('Promise chain failed:', error);
    showUserError('Failed to load data');
  });
```

**async/await（推荐）：** 让异步代码拥有同步的错误处理体验。
```javascript
async function fetchUserData(userId) {
  try {
    const response = await fetch(`/api/users/${userId}`);
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }
    const user = await response.json();
    return user;
  } catch (error) {
    console.error('Failed to fetch user:', error);
    // 可以根据错误类型进行不同的处理
    if (error.message.includes('404')) {
      showUserError('User not found');
    } else if (error.message.includes('500')) {
      showUserError('Server error, please try later');
    } else {
      showUserError('Network error, please check your connection');
    }
  }
}
```

#### c) 全局错误监听 - 最后的防线

对于未捕获的错误，需要设置全局监听器作为最后的保障。

**全局错误事件：**
```javascript
// 捕获常规运行时错误
window.addEventListener('error', (event) => {
  console.error('Global error caught:', event.error);
  
  // 错误上报
  reportErrorToServer({
    type: 'Runtime Error',
    message: event.error?.message || event.message,
    filename: event.filename,
    lineno: event.lineno,
    colno: event.colno,
    stack: event.error?.stack
  });
  
  // 阻止浏览器默认的错误提示（慎用）
  // event.preventDefault();
});

// 捕获未处理的 Promise 拒绝
window.addEventListener('unhandledrejection', (event) => {
  console.error('Unhandled promise rejection:', event.reason);
  
  reportErrorToServer({
    type: 'Unhandled Promise Rejection',
    reason: event.reason?.message || event.reason
  });
  
  // 阻止浏览器默认的警告
  event.preventDefault();
});
```

**资源加载错误监听：**
```javascript
// 通过事件代理监听资源加载错误
document.addEventListener('error', (event) => {
  const target = event.target;
  if (target.tagName === 'IMG' || target.tagName === 'SCRIPT' || target.tagName === 'LINK') {
    console.error('Resource failed to load:', target.src || target.href);
    reportErrorToServer({
      type: 'Resource Error',
      tagName: target.tagName,
      url: target.src || target.href
    });
  }
}, true); // 使用捕获阶段
```

---

### 3. 自定义错误类 - 更精细的错误管理

创建自定义错误类可以让错误处理更加语义化和结构化。

```javascript
class NetworkError extends Error {
  constructor(message, statusCode, url) {
    super(message);
    this.name = 'NetworkError';
    this.statusCode = statusCode;
    this.url = url;
    this.timestamp = new Date().toISOString();
  }
}

class ValidationError extends Error {
  constructor(message, field, value) {
    super(message);
    this.name = 'ValidationError';
    this.field = field;
    this.value = value;
  }
}

// 使用示例
async function apiCall() {
  try {
    const response = await fetch('/api/data');
    if (!response.ok) {
      throw new NetworkError('API request failed', response.status, '/api/data');
    }
    const data = await response.json();
    
    if (!data.valid) {
      throw new ValidationError('Invalid data format', 'valid', data.valid);
    }
    
    return data;
  } catch (error) {
    if (error instanceof NetworkError) {
      // 处理网络错误
      showNetworkError(error.statusCode);
    } else if (error instanceof ValidationError) {
      // 处理验证错误
      highlightInvalidField(error.field);
    } else {
      // 处理其他未知错误
      reportUnexpectedError(error);
    }
  }
}
```

---

### 4. 错误上报与监控

在生产环境中，需要将错误信息上报到服务器进行分析。

#### 基础错误上报：
```javascript
function reportErrorToServer(errorInfo) {
  const payload = {
    ...errorInfo,
    userAgent: navigator.userAgent,
    url: window.location.href,
    timestamp: new Date().toISOString(),
    userId: getCurrentUserId() // 如果有的话
  };

  // 使用 navigator.sendBeacon 在页面卸载时也能可靠发送
  if (navigator.sendBeacon) {
    const blob = new Blob([JSON.stringify(payload)], { type: 'application/json' });
    navigator.sendBeacon('/api/error-log', blob);
  } else {
    // 回退方案
    fetch('/api/error-log', {
      method: 'POST',
      body: JSON.stringify(payload),
      headers: { 'Content-Type': 'application/json' },
      keepalive: true // 确保请求在页面关闭后也能完成
    });
  }
}
```

#### 集成专业监控服务：
*   **Sentry:** 功能强大的错误监控平台
    ```javascript
    import * as Sentry from '@sentry/browser';
    
    Sentry.init({
      dsn: 'YOUR_DSN_HERE',
      environment: process.env.NODE_ENV,
    });
    
    // 手动捕获错误
    try {
      riskyOperation();
    } catch (error) {
      Sentry.captureException(error);
    }
    ```
*   **其他方案：** Datadog, LogRocket, Bugsnag

---

### 5. 总结

1.  **防御性编程：** 对输入数据进行验证，对可能失败的操作进行预判。
2.  **具体明确的错误信息：** 错误信息应该帮助开发者快速定位问题。
3.  **适度的错误恢复：** 在适当的时候提供降级方案，而不是让整个应用崩溃。
4.  **用户友好的错误提示：** 不要将技术性的错误堆栈展示给普通用户。
5.  **分级处理：**
    *   **UI层面：** 给用户友好的提示
    *   **业务层面：** 记录日志，尝试恢复或降级
    *   **系统层面：** 上报到监控系统
6.  **测试错误场景：** 单元测试和集成测试中应该包含错误路径的测试。


一个完善的前端错误处理体系应该包含：
*   **预防：** 代码规范、类型检查（TypeScript）、输入验证
*   **捕获：** `try...catch`、Promise catch、全局错误监听
*   **分类：** 自定义错误类、错误类型识别
*   **处理：** 用户提示、自动恢复、降级方案
*   **上报：** 错误日志、监控平台集成
*   **分析：** 错误趋势分析、根源定位、持续改进
