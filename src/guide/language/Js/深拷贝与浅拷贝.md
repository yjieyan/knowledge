# 深拷贝与浅拷贝

---

### 1. 核心概念与区别

#### 浅拷贝

**定义：** 创建一个新对象，新对象只复制原始对象的第一层属性。如果属性是基本类型，则拷贝其值；如果属性是引用类型，则拷贝其**内存地址**。

**结果：** 新旧对象**共享**同一块引用类型数据的内存地址。修改其中一个对象的引用类型属性，会影响到另一个对象。

**类比：** 你有一把钥匙（引用），浅拷贝就是复制了这把钥匙。你们俩用各自的钥匙都能打开同一扇门（对象），一个人把门里的东西换了，另一个人看到的就是被换过的。

#### 深拷贝

**定义：** 创建一个新对象，并递归地复制原始对象的所有层级，包括所有嵌套的对象和数组。新旧对象完全独立，**不共享**任何引用。

**结果：** 修改新对象的任何属性（无论第几层），都不会影响原始对象。

**类比：** 你有一栋房子（对象），深拷贝就是按照原样完全重建一栋一模一样的房子，包括里面的所有家具和摆设。你在新房子里做任何改动，都不会影响原来的房子。

---

### 2. 代码示例

让我们通过一个具体的例子来感受两者的区别：

```javascript
const originalObj = {
  name: 'Alice',
  age: 25,
  hobbies: ['reading', 'coding'], // 引用类型
  address: {                     // 引用类型
    city: 'Beijing',
    street: 'Wangfujing'
  }
};

// ----------------- 浅拷贝 -----------------
const shallowCopy = Object.assign({}, originalObj);

// ----------------- 深拷贝 -----------------
// 方法一：JSON方法（有局限性，后面会讲）
const deepCopy = JSON.parse(JSON.stringify(originalObj));

// 修改测试
shallowCopy.name = 'Bob'; // 修改第一层基本类型
shallowCopy.hobbies.push('gaming'); // 修改第二层引用类型
shallowCopy.address.city = 'Shanghai'; // 修改第二层引用类型

deepCopy.hobbies.push('hiking');

console.log('Original Object:', originalObj);
console.log('Shallow Copy:', shallowCopy);
console.log('Deep Copy:', deepCopy);
```

**输出结果分析：**

```javascript
// 原始对象被浅拷贝影响了！
Original Object: {
  name: 'Alice',        // ✅ 未改变 (第一层基本类型)
  age: 25,
  hobbies: [ 'reading', 'coding', 'gaming' ], // ❌ 被改变了！(共享同一数组)
  address: { city: 'Shanghai', street: 'Wangfujing' } // ❌ 被改变了！(共享同一对象)
}

Shallow Copy: {
  name: 'Bob',          // ✅ 已改变
  age: 25,
  hobbies: [ 'reading', 'coding', 'gaming' ], // ✅ 已改变
  address: { city: 'Shanghai', street: 'Wangfujing' } // ✅ 已改变
}

// 深拷贝完全独立
Deep Copy: {
  name: 'Alice',
  age: 25,
  hobbies: [ 'reading', 'coding', 'hiking' ], // ✅ 独立改变
  address: { city: 'Beijing', street: 'Wangfujing' } // ✅ 完全不受影响
}
```

---

### 3. 实现方式

#### 浅拷贝的实现

1.  **`Object.assign()`**
    ```javascript
    const copy = Object.assign({}, original);
    ```

2.  **展开运算符 `...`**
    ```javascript
    const copy = { ...original };
    ```

3.  **`Array.prototype.slice()`** (针对数组)
    ```javascript
    const copyArray = originalArray.slice();
    ```

4.  **`Array.from()`** (针对数组)
    ```javascript
    const copyArray = Array.from(originalArray);
    ```

#### 深拷贝的实现

1.  **`JSON.parse(JSON.stringify())`** (最常用但问题最多)
    ```javascript
    const deepCopy = JSON.parse(JSON.stringify(original));
    ```
    **局限性：**
    *   无法拷贝 **`undefined`**、**`function`**、**`Symbol`** 值
    *   无法处理 **循环引用**（会报错）
    *   会丢弃 **`Date`** 对象（转为字符串），**`RegExp`**、**`Error`** 对象等
    *   会忽略 **原型链**

2.  **手动递归实现** 
    ```javascript
    function deepClone(source, hash = new WeakMap()) {
      // 处理基本类型和 null/undefined
      if (source === null || typeof source !== 'object') {
        return source;
      }
      
      // 处理 Date 对象
      if (source instanceof Date) {
        return new Date(source);
      }
      
      // 处理 Array 对象
      if (source instanceof Array) {
        return source.map(item => deepClone(item, hash));
      }
      
      // 处理 RegExp 对象
      if (source instanceof RegExp) {
        return new RegExp(source);
      }
      
      // 处理普通对象
      if (source instanceof Object) {
        // 检查循环引用
        if (hash.has(source)) {
          return hash.get(source);
        }
        
        const target = {};
        hash.set(source, target);
        
        for (let key in source) {
          if (source.hasOwnProperty(key)) {
            target[key] = deepClone(source[key], hash);
          }
        }
        
        return target;
      }
      
      // 其他情况直接返回
      return source;
    }
    ```

3.  **使用第三方库**
    *   **Lodash: `_.cloneDeep()`**
      ```javascript
      import _ from 'lodash';
      const deepCopy = _.cloneDeep(original);
      ```
    *   **jQuery: `$.extend(true, {}, obj)`**

---

### 4. 循环引用问题及解决方案

循环引用是指对象属性间接或直接地引用自身。

```javascript
const obj = { name: 'Alice' };
obj.self = obj; // 循环引用

// JSON方法会报错
// JSON.parse(JSON.stringify(obj)); // TypeError: Converting circular structure to JSON

// 手动实现的深拷贝需要处理这种情况
```

**解决方案：** 使用 `WeakMap` 来存储已经拷贝过的对象。
*   在递归拷贝前，先检查 `WeakMap` 中是否已经存在该对象的引用。
*   如果存在，直接返回存储的值。
*   如果不存在，则进行拷贝，并在 `WeakMap` 中记录。

上面的手动递归实现已经包含了循环引用的处理。

---

### 5. 性能考虑

*   **浅拷贝** 性能最好，因为它只复制一层。
*   **`JSON` 方法** 性能中等，但对于复杂对象，序列化和反序列化开销较大。
*   **递归深拷贝** 性能最差，特别是对于深度嵌套的大对象，但功能最完整。
*   **`structuredClone()`** (现代浏览器内置) 性能较好，且支持更多数据类型。

```javascript
// 现代浏览器的全局方法
const deepCopy = structuredClone(original);
```

---

### 6. 实践建议与总结

| 场景 | 推荐方法 | 原因 |
| :--- | :--- | :--- |
| **只需要第一层复制** | 浅拷贝 (`...`, `Object.assign`) | 性能最佳 |
| **简单数据对象的完全复制** | `JSON.parse(JSON.stringify())` | 简单快捷，兼容性好 |
| **复杂对象（含函数、循环引用等）** | `_.cloneDeep()` 或 手动递归实现 | 功能完整，可靠 |
| **现代浏览器环境** | `structuredClone()` | 原生支持，性能好 |

**总结：**

*   **浅拷贝** 只复制第一层，引用类型属性**共享内存**。
*   **深拷贝** 递归复制所有层级，创建**完全独立**的对象副本。
*   选择拷贝方式时，需要根据**数据结构复杂性**、**性能要求**和**运行环境**来权衡。
*   在实际项目中，对于复杂的深拷贝需求，推荐使用成熟的第三方库如 Lodash 的 `_.cloneDeep`。
