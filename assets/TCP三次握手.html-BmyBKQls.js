import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,f as r,o as n}from"./app-h0wwf_Tf.js";const s={};function c(l,o){return n(),t("div",null,[...o[0]||(o[0]=[r('<hr><h3 id="一、-tcp-三次握手-three-way-handshake" tabindex="-1"><a class="header-anchor" href="#一、-tcp-三次握手-three-way-handshake"><span>一、 TCP 三次握手 (Three-way Handshake)</span></a></h3><p><strong>目标</strong>：在客户端和服务器之间建立一个可靠的、全双工的 TCP 连接，并同步双方的初始序列号。</p><p><strong>过程</strong>（假设客户端主动打开连接）：</p><ol><li><p><strong>第一次握手 (SYN=1, seq=x)</strong></p><ul><li><strong>客户端 -&gt; 服务器</strong>：客户端发送一个 TCP 报文段，其中： <ul><li><code>SYN</code> 标志位设置为 1，表示这是一个<strong>连接请求</strong>报文。</li><li>随机生成一个初始序列号 <code>seq = x</code>（ISN）。</li></ul></li><li><strong>客户端状态</strong>：从 <code>CLOSED</code> 进入 <code>SYN-SENT</code>。</li></ul></li><li><p><strong>第二次握手 (SYN=1, ACK=1, seq=y, ack=x+1)</strong></p><ul><li><strong>服务器 -&gt; 客户端</strong>：服务器收到 SYN 报文后，如果同意连接，则回复一个报文段，其中： <ul><li><code>SYN</code> 和 <code>ACK</code> 标志位都设置为 1。<code>SYN=1</code> 表示这也是一个<strong>连接请求</strong>，<code>ACK=1</code> 表示这是一个<strong>确认报文</strong>。</li><li>随机生成服务器端的初始序列号 <code>seq = y</code>。</li><li>确认号 <code>ack = x + 1</code>，表示“我收到了你的序列号为 <code>x</code> 的报文，我期望你下一个报文的序列号是 <code>x+1</code>”。</li></ul></li><li><strong>服务器状态</strong>：从 <code>LISTEN</code> 进入 <code>SYN-RCVD</code>。</li></ul></li><li><p><strong>第三次握手 (ACK=1, seq=x+1, ack=y+1)</strong></p><ul><li><strong>客户端 -&gt; 服务器</strong>：客户端收到服务器的 SYN-ACK 报文后，会再次发送一个确认报文，其中： <ul><li><code>ACK</code> 标志位设置为 1。</li><li>序列号 <code>seq = x + 1</code>（因为第一次握手消耗了一个序列号）。</li><li>确认号 <code>ack = y + 1</code>，表示“我收到了你的序列号为 <code>y</code> 的报文，我期望你下一个报文的序列号是 <code>y+1</code>”。</li></ul></li><li><strong>连接状态</strong>： <ul><li><strong>客户端状态</strong>：从 <code>SYN-SENT</code> 进入 <code>ESTABLISHED</code>。</li><li><strong>服务器状态</strong>：收到此报文后，从 <code>SYN-RCVD</code> 进入 <code>ESTABLISHED</code>。</li></ul></li></ul></li></ol><p>至此，连接建立成功，双方可以开始传输数据。</p><h4 id="为什么是三次-而不是两次" tabindex="-1"><a class="header-anchor" href="#为什么是三次-而不是两次"><span><strong>为什么是三次，而不是两次？</strong></span></a></h4><p><strong>核心原因：为了防止“已失效的连接请求报文”突然又传到了服务器，从而产生错误。</strong></p><p><strong>情景模拟：</strong><br> 假设客户端发送了一个连接请求报文 A，但这个报文在网络中滞留了（因为网络拥堵），导致客户端超时重传了一个新的连接请求报文 B。报文 B 顺利到达，服务器确认，连接建立，数据传输完毕后连接关闭。</p><p>此时，那个滞留在网络中的旧报文 A 终于到达了服务器。服务器会认为这是一个新的连接请求，于是回复 SYN-ACK。如果只有两次握手：</p><ul><li>服务器只要收到 SYN 并回复了 SYN-ACK，就认为连接已建立，会一直维持这个连接等待客户端发送数据。</li><li>但客户端根本没有发起这个新连接（它认为是旧的、已处理的请求），所以会忽略服务器的 SYN-ACK，也不会发送数据。</li><li>结果：<strong>服务器会白白浪费资源，空等一个永远不会发送数据的客户端。</strong> 这可能导致服务器因大量这种无效连接而瘫痪。</li></ul><p><strong>使用三次握手如何解决：</strong><br> 在两次握手的基础上，客户端需要再发送一次确认。对于那个失效的报文 A，服务器回复 SYN-ACK 后，<strong>客户端不会向它发送第三次握手的 ACK</strong>，因此服务器收不到确认，经过一段时间后会自动关闭这个半连接，不会一直等待。</p><p><strong>总结三次握手的目的：</strong></p><ol><li><strong>确认双方的发送和接收能力正常</strong>。</li><li><strong>同步双方的初始序列号</strong>，为可靠传输做准备。</li><li><strong>防止旧的重复连接初始化造成混乱</strong>。</li></ol><hr><h3 id="二、-tcp-四次挥手-four-way-wavehand" tabindex="-1"><a class="header-anchor" href="#二、-tcp-四次挥手-four-way-wavehand"><span>二、 TCP 四次挥手 (Four-way Wavehand)</span></a></h3><p><strong>目标</strong>：安全、可靠地关闭一个 TCP 连接。由于 TCP 连接是<strong>全双工</strong>的，每个方向必须单独关闭。</p><p><strong>过程</strong>（假设客户端主动关闭连接）：</p><ol><li><p><strong>第一次挥手 (FIN=1, seq=u)</strong></p><ul><li><strong>客户端 -&gt; 服务器</strong>：客户端发送一个 TCP 报文段，其中 <code>FIN</code> 标志位设置为 1，并指定一个序列号 <code>seq = u</code>（等于客户端已传送数据的最后一个字节的序列号加 1）。</li><li><strong>客户端状态</strong>：从 <code>ESTABLISHED</code> 进入 <code>FIN-WAIT-1</code>。这表示客户端没有数据要发送了。</li></ul></li><li><p><strong>第二次挥手 (ACK=1, seq=v, ack=u+1)</strong></p><ul><li><strong>服务器 -&gt; 客户端</strong>：服务器收到 FIN 报文后，发送一个确认报文，其中 <code>ACK=1</code>，确认号 <code>ack = u + 1</code>，序列号 <code>seq = v</code>。</li><li><strong>服务器状态</strong>：从 <code>ESTABLISHED</code> 进入 <code>CLOSE-WAIT</code>。</li><li><strong>客户端状态</strong>：收到这个 ACK 后，从 <code>FIN-WAIT-1</code> 进入 <code>FIN-WAIT-2</code>。</li><li><strong>此时状态</strong>：<strong>TCP 连接处于半关闭状态</strong>。客户端到服务器的方向已经关闭，客户端不再发送数据，但服务器可能还有数据要发送给客户端，客户端也必须接收。</li></ul></li><li><p><strong>第三次挥手 (FIN=1, ACK=1, seq=w, ack=u+1)</strong></p><ul><li><strong>服务器 -&gt; 客户端</strong>：当服务器也没有数据要发送时，它会发送自己的 FIN 报文，其中 <code>FIN=1</code>，<code>ACK=1</code>，序列号 <code>seq = w</code>（服务器可能在上次确认后又发送了一些数据），确认号 <code>ack</code> 仍然是 <code>u+1</code>。</li><li><strong>服务器状态</strong>：从 <code>CLOSE-WAIT</code> 进入 <code>LAST-ACK</code>。</li></ul></li><li><p><strong>第四次挥手 (ACK=1, seq=u+1, ack=w+1)</strong></p><ul><li><strong>客户端 -&gt; 服务器</strong>：客户端收到服务器的 FIN 报文后，必须发出确认报文，其中 <code>ACK=1</code>，确认号 <code>ack = w + 1</code>，序列号 <code>seq = u + 1</code>。</li><li><strong>客户端状态</strong>：从 <code>FIN-WAIT-2</code> 进入 <code>TIME-WAIT</code>。客户端会等待 <code>2MSL</code> 时间。</li><li><strong>服务器状态</strong>：服务器收到这个 ACK 后，就进入 <code>CLOSED</code> 状态。</li></ul></li></ol><h4 id="为什么需要四次挥手" tabindex="-1"><a class="header-anchor" href="#为什么需要四次挥手"><span><strong>为什么需要四次挥手？</strong></span></a></h4><p>因为 TCP 是全双工的，关闭连接需要两个独立的单向连接的关闭。</p><ul><li>第一次和第二次挥手：关闭了从 <strong>客户端 -&gt; 服务器</strong> 的连接。</li><li>第三次和第四次挥手：关闭了从 <strong>服务器 -&gt; 客户端</strong> 的连接。</li></ul><p>在第二次和第三次挥手之间，服务器可能还在发送未传完的数据，因此不能将第二、三次挥手合并。</p><hr><h3 id="三、-为什么是-2msl" tabindex="-1"><a class="header-anchor" href="#三、-为什么是-2msl"><span>三、 为什么是 2MSL？</span></a></h3><p><strong>MSL</strong> 是 <strong>Maximum Segment Lifetime</strong>（报文最大生存时间）。它是任何 TCP 报文在网络中被丢弃前能存在的最长时间。这个时间是有限的，因为网络是由 TTL (Time To Live) 限制的。</p><p>当客户端发送完第四次挥手的 ACK 后，它需要进入 <code>TIME-WAIT</code> 状态，并等待 <code>2MSL</code> 的时间。</p><p><strong>两个主要原因：</strong></p><ol><li><p><strong>可靠地实现全双工连接的终止</strong></p><ul><li>第四次挥手的 ACK 报文有可能丢失。如果丢失，服务器在 <code>LAST-ACK</code> 状态下会因为超时而<strong>重传</strong>它的 FIN 报文。</li><li>如果客户端不等待 <code>2MSL</code> 而直接关闭，那么当服务器重传 FIN 时，客户端会回复一个 <code>RST</code>（复位）报文，这会被服务器解释为一个错误。</li><li>客户端等待 <code>2MSL</code>，可以确保如果 ACK 丢失，它有能力<strong>再次收到服务器的 FIN 报文并重发 ACK</strong>。这样就能让服务器正常地进入 <code>CLOSED</code> 状态。</li></ul></li><li><p><strong>让旧的重复报文在网络中消逝</strong></p><ul><li>在 <code>2MSL</code> 的等待时间内，这个连接（由双方 IP 和端口号定义）产生的所有报文都会从网络中消逝。</li><li>这样，当同一个四元组（客户端IP、端口，服务器IP、端口）建立<strong>新的连接</strong>时，就不会受到之前连接滞留在网络中的旧报文的干扰。这避免了新旧连接数据混淆的问题。</li></ul></li></ol><p><strong><code>TIME-WAIT</code> 状态的影响：</strong></p><ul><li>主动关闭连接的一方会保持 <code>TIME-WAIT</code> 状态。</li><li>在高性能服务器上，如果服务器主动关闭大量短连接，会导致大量连接处于 <code>TIME-WAIT</code> 状态，消耗系统资源（如端口号）。</li><li>解决方案：可以通过调整内核参数（如 <code>net.ipv4.tcp_tw_reuse</code>）或让客户端（而非服务器）主动关闭连接来缓解。</li></ul><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><ul><li><strong>三次握手</strong>：为了<strong>同步序列号、确认双方能力、防止失效请求</strong>。少一次无法防止资源浪费，多一次则没有必要。</li><li><strong>四次挥手</strong>：因为 TCP 是<strong>全双工</strong>的，每个方向的连接需要独立关闭。服务器在收到客户端的 FIN 后，可能还有数据要发送，所以不能立即回复 FIN。</li><li><strong>2MSL</strong>：为了<strong>确保最后一个 ACK 能到达对方</strong>，并<strong>让旧连接的报文在网络中消逝</strong>，从而可靠地关闭连接并为新连接提供一个干净的网络环境。</li></ul>',33)])])}const g=e(s,[["render",c]]),a=JSON.parse('{"path":"/guide/computer/%E7%BD%91%E7%BB%9C/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.html","title":"","lang":"zh-CN","frontmatter":{"description":"一、 TCP 三次握手 (Three-way Handshake) 目标：在客户端和服务器之间建立一个可靠的、全双工的 TCP 连接，并同步双方的初始序列号。 过程（假设客户端主动打开连接）： 第一次握手 (SYN=1, seq=x) 客户端 -> 服务器：客户端发送一个 TCP 报文段，其中： SYN 标志位设置为 1，表示这是一个连接请求报文。 随...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-10-18T03:59:38.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"yjieyan\\",\\"url\\":\\"https://yjieyan.github.io/knowledge\\"}]}"],["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/knowledge/guide/computer/%E7%BD%91%E7%BB%9C/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.html"}],["meta",{"property":"og:site_name","content":"博客"}],["meta",{"property":"og:description","content":"一、 TCP 三次握手 (Three-way Handshake) 目标：在客户端和服务器之间建立一个可靠的、全双工的 TCP 连接，并同步双方的初始序列号。 过程（假设客户端主动打开连接）： 第一次握手 (SYN=1, seq=x) 客户端 -> 服务器：客户端发送一个 TCP 报文段，其中： SYN 标志位设置为 1，表示这是一个连接请求报文。 随..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-10-18T03:59:38.000Z"}],["meta",{"property":"article:modified_time","content":"2025-10-18T03:59:38.000Z"}]]},"git":{"createdTime":1760716761000,"updatedTime":1760759978000,"contributors":[{"name":"yjy","username":"yjy","email":"2192242196@qq.com","commits":2,"url":"https://github.com/yjy"}]},"readingTime":{"minutes":7.18,"words":2153},"filePathRelative":"guide/computer/网络/TCP三次握手.md","autoDesc":true}');export{g as comp,a as data};
