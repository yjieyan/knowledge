import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,a as e,o as a}from"./app-DtG3coGW.js";const n={};function l(h,s){return a(),t("div",null,[...s[0]||(s[0]=[e(`<h1 id="浏览器和nodejs事件循环的区别" tabindex="-1"><a class="header-anchor" href="#浏览器和nodejs事件循环的区别"><span>浏览器和nodejs事件循环的区别</span></a></h1><ol><li><strong>共同基础：什么是事件循环？</strong></li><li><strong>浏览器中的事件循环</strong></li><li><strong>Node.js 中的事件循环</strong></li><li><strong>核心差异对比</strong></li><li><strong>Node.js 新版与旧版的差异</strong></li><li><strong>总结与流程图对比</strong></li></ol><hr><h3 id="_1-共同基础-什么是事件循环" tabindex="-1"><a class="header-anchor" href="#_1-共同基础-什么是事件循环"><span>1. 共同基础：什么是事件循环？</span></a></h3><p>事件循环是 JavaScript 实现<strong>非阻塞 I/O</strong> 和<strong>异步编程</strong>的基石。</p><p>它的核心机制是：</p><ul><li><strong>单线程</strong>：JavaScript 主线程是单线程的，意味着同一时间只能执行一个任务。</li><li><strong>任务队列</strong>：异步操作（如 <code>setTimeout</code>、<code>fetch</code>、<code>fs.readFile</code>）在完成后，会将它们的回调函数放入相应的任务队列中等待。</li><li><strong>循环机制</strong>：事件循环会不断地检查调用栈（Call Stack）是否为空。当调用栈为空时，它就从任务队列中取出一个任务并将其推入调用栈执行。</li></ul><p>这个“不断检查-取出-执行”的过程，就是事件循环。</p><hr><h3 id="_2-浏览器中的事件循环" tabindex="-1"><a class="header-anchor" href="#_2-浏览器中的事件循环"><span>2. 浏览器中的事件循环</span></a></h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop" target="_blank" rel="noopener noreferrer">浏览器事件循环</a><br> 浏览器的事件循环由 <strong>HTML5 规范</strong>定义。它将异步任务分为两大类：<strong>宏任务</strong> 和 <strong>微任务</strong>。</p><h4 id="任务队列-task-queues" tabindex="-1"><a class="header-anchor" href="#任务队列-task-queues"><span><strong>任务队列（Task Queues）</strong></span></a></h4><ul><li><p><strong>宏任务</strong>：可以理解为每个“轮次”的事件循环只执行一个宏任务。</p><ul><li><strong>来源</strong>：<code>setTimeout</code>、<code>setInterval</code>、<code>setImmediate</code> (非标准)、I/O、UI 渲染、<code>requestAnimationFrame</code>、主要的用户交互事件（如 <code>click</code>）。</li><li><strong>注意</strong>：实际上浏览器可能维护了多个宏任务队列（如交互队列、延时队列），但规范要求同源的同类型任务必须在同一队列。</li></ul></li><li><p><strong>微任务</strong>：在每个宏任务执行结束后、下一个宏任务开始前，必须清空当前所有的微任务。</p><ul><li><strong>来源</strong>：<code>Promise.then()</code> / <code>Promise.catch()</code> / <code>Promise.finally()</code>、<code>queueMicrotask()</code>、<code>MutationObserver</code>。</li><li><strong>特点</strong>：微任务队列具有<strong>最高优先级</strong>，在当前宏任务后立即执行，且会一直执行直到微任务队列为空。</li></ul></li></ul><h4 id="浏览器事件循环流程" tabindex="-1"><a class="header-anchor" href="#浏览器事件循环流程"><span><strong>浏览器事件循环流程</strong></span></a></h4><ol><li>执行一个<strong>宏任务</strong>（如 <code>script</code> 整体代码）。</li><li>执行过程中遇到异步代码，根据类型分发到对应的队列。</li><li>当前宏任务执行完毕。</li><li>检查<strong>微任务队列</strong>，依次执行所有微任务，直到队列清空。</li><li>（可选）进行 <strong>UI 渲染</strong>（浏览器会根据策略决定是否渲染，通常每秒 60 次）。</li><li>从<strong>宏任务队列</strong>中取出下一个宏任务，开始新的一轮循环。</li></ol><p><strong>关键点：微任务在渲染之前执行。</strong></p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-javascript"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;script start&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 宏任务 1</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setTimeout</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">  console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;setTimeout&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 宏任务 2 的回调</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Promise</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">resolve</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">().</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">then</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">  console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;promise1&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 微任务 1</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}).</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">then</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">  console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;promise2&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 微任务 2</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;script end&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 宏任务 1 继续</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 输出顺序：</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// &#39;script start&#39;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// &#39;script end&#39;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// &#39;promise1&#39;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// &#39;promise2&#39;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// &#39;setTimeout&#39;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="_3-node-js-中的事件循环" tabindex="-1"><a class="header-anchor" href="#_3-node-js-中的事件循环"><span>3. Node.js 中的事件循环</span></a></h3><p>Node.js 的事件循环由 <strong>libuv 库</strong>实现，它更为复杂，将事件循环分成了<strong>多个阶段</strong>。每个阶段都有一个 <strong>FIFO（先进先出）</strong> 的回调队列。</p><h4 id="事件循环的六个阶段" tabindex="-1"><a class="header-anchor" href="#事件循环的六个阶段"><span><strong>事件循环的六个阶段</strong></span></a></h4><ol><li><strong>timers 阶段</strong>：执行 <code>setTimeout()</code> 和 <code>setInterval()</code> 的回调。</li><li><strong>pending callbacks 阶段</strong>：执行延迟到下一个循环迭代的 I/O 回调（如操作系统错误）。</li><li><strong>idle, prepare 阶段</strong>：仅内部使用。</li><li><strong>poll 阶段</strong>：检索新的 I/O 事件；执行与 I/O 相关的回调（除了 close callbacks, timers, <code>setImmediate</code>）；Node 可能会在此阶段阻塞。</li><li><strong>check 阶段</strong>：执行 <code>setImmediate()</code> 的回调。</li><li><strong>close callbacks 阶段</strong>：执行一些关闭的回调（如 <code>socket.on(&#39;close&#39;, ...)</code>）。</li></ol><h4 id="node-js-事件循环流程-简化" tabindex="-1"><a class="header-anchor" href="#node-js-事件循环流程-简化"><span><strong>Node.js 事件循环流程（简化）</strong></span></a></h4><ol><li>进入 timers 阶段，检查是否有到期的 timer，有则执行其回调。</li><li>进入 poll 阶段： <ul><li>如果 poll 队列不为空，则同步执行队列里的回调，直到队列清空或达到系统限制。</li><li>如果 poll 队列为空： <ul><li>如果代码中设置了 <code>setImmediate</code>，则结束 poll 阶段，进入 check 阶段。</li><li>如果没有 <code>setImmediate</code>，则会等待新的 I/O 事件到来，并在此处阻塞。</li></ul></li></ul></li><li>进入 check 阶段，执行所有 <code>setImmediate</code> 的回调。</li><li>进入 close callbacks 阶段，执行 &#39;close&#39; 事件回调。</li><li>开始新一轮循环。</li></ol><h4 id="node-js-中的微任务" tabindex="-1"><a class="header-anchor" href="#node-js-中的微任务"><span><strong>Node.js 中的微任务</strong></span></a></h4><p>在 Node.js 中，<strong>微任务</strong>（主要是 Promise 和 <code>process.nextTick</code>）不属于以上任何一个阶段。它们拥有<strong>更高的优先级</strong>，会在<strong>事件循环切换阶段之间</strong>被执行。</p><ul><li><code>process.nextTick</code> 的优先级甚至<strong>高于 Promise</strong>，它拥有一个独立的 <code>nextTickQueue</code>。</li><li>在<strong>每一个阶段结束后</strong>，在进入下一个阶段之前，事件循环会先清空两个微任务队列： <ol><li>先清空 <code>nextTickQueue</code>。</li><li>再清空 <code>microtask Queue</code>（Promise）。</li></ol></li></ul><hr><h3 id="_4-核心差异对比" tabindex="-1"><a class="header-anchor" href="#_4-核心差异对比"><span>4. 核心差异对比</span></a></h3><table><thead><tr><th style="text-align:left;">特性</th><th style="text-align:left;">浏览器</th><th style="text-align:left;">Node.js</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>规范/实现</strong></td><td style="text-align:left;">遵循 <strong>WHATWG HTML</strong> 规范</td><td style="text-align:left;">基于 <strong>libuv</strong> 库实现</td></tr><tr><td style="text-align:left;"><strong>结构</strong></td><td style="text-align:left;"><strong>宏任务队列 + 微任务队列</strong></td><td style="text-align:left;"><strong>多阶段（Phase）</strong>，每个阶段对应一个宏任务队列</td></tr><tr><td style="text-align:left;"><strong>宏任务举例</strong></td><td style="text-align:left;"><code>setTimeout</code>, <code>setInterval</code>, I/O, UI 渲染, 事件</td><td style="text-align:left;"><code>setTimeout</code>, <code>setInterval</code>, I/O, <code>setImmediate</code></td></tr><tr><td style="text-align:left;"><strong>微任务举例</strong></td><td style="text-align:left;"><code>Promise.then</code>, <code>queueMicrotask</code>, <code>MutationObserver</code></td><td style="text-align:left;"><code>Promise.then</code>, <code>queueMicrotask</code>, <strong><code>process.nextTick</code></strong></td></tr><tr><td style="text-align:left;"><strong>微任务执行时机</strong></td><td style="text-align:left;">在<strong>每一个宏任务</strong>执行完毕后</td><td style="text-align:left;">在<strong>事件循环的每一个阶段切换之间</strong></td></tr><tr><td style="text-align:left;"><strong><code>process.nextTick</code></strong></td><td style="text-align:left;">不存在</td><td style="text-align:left;">有，且优先级<strong>最高</strong>，在所有 Promise 之前执行</td></tr><tr><td style="text-align:left;"><strong><code>setImmediate</code></strong></td><td style="text-align:left;">非标准，只有 IE/Edge 支持</td><td style="text-align:left;">有，在 <strong>check</strong> 阶段执行</td></tr><tr><td style="text-align:left;"><strong>与 I/O 的协作</strong></td><td style="text-align:left;">I/O（如 <code>fetch</code>）由 Web API 处理，回调作为宏任务</td><td style="text-align:left;">I/O 由 libuv 处理，回调在 <strong>poll</strong> 阶段执行</td></tr></tbody></table><p><strong>关键差异示例：</strong></p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-javascript"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 在 Node.js 中运行</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setTimeout</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;timeout&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">), </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setImmediate</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;immediate&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">));</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 输出顺序是不确定的！取决于当前循环的性能</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 因为 setTimeout 在 timers 阶段，setImmediate 在 check 阶段</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 进入事件循环时，如果 timer 已到期，则先输出 &#39;timeout&#39;，否则先输出 &#39;immediate&#39;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-javascript"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 在 I/O 回调中，顺序是确定的</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> fs</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> require</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;fs&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">fs</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">readFile</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">__filename</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, () </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">  setTimeout</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;timeout&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">), </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">  setImmediate</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;immediate&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)); </span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 总是先输出 &#39;immediate&#39;，再输出 &#39;timeout&#39;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 因为 I/O 回调在 poll 阶段，之后直接进入 check 阶段，然后才是下一轮的 timers 阶段</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">});</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="_5-node-js-新版与旧版的差异" tabindex="-1"><a class="header-anchor" href="#_5-node-js-新版与旧版的差异"><span>5. Node.js 新版与旧版的差异</span></a></h3><p>值得注意的是，新版本的 Node.js（大约 v11 之后）在行为上向浏览器靠拢。</p><ul><li><strong>Node v11 之前</strong>：在执行一个宏任务（如 <code>setTimeout</code>）后，不会清空微任务队列，而是会执行完当前阶段的所有宏任务后，才去清空微任务。</li><li><strong>Node v11 及之后</strong>：<strong>与浏览器保持一致</strong>。在执行一个宏任务（如 <code>setTimeout</code>）后，会立即清空当前产生的所有微任务，再执行下一个宏任务。</li></ul><hr><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><p><strong>浏览器事件循环（简化）：</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>[执行一个宏任务] -&gt; [清空所有微任务] -&gt; [可能渲染] -&gt; [取下一个宏任务]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><strong>Node.js 事件循环（简化）：</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>[Timers] -&gt; [Pending Callbacks] -&gt; [Idle/Prepare] -&gt; [Poll] -&gt; [Check] -&gt; [Close Callbacks]</span></span>
<span class="line"><span>      ↓          ↓                   ↓             ↓        ↓           ↓</span></span>
<span class="line"><span> [清空 nextTick 和 Microtask 队列]  [清空...]    [清空...]  [清空...]  [清空...]  [清空...]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>结论：</strong></p><ol><li><strong>架构不同</strong>：浏览器是 <strong>宏/微任务队列</strong>，Node.js 是 <strong>libuv 的多阶段</strong>。</li><li><strong>微任务执行时机</strong>：浏览器在宏任务后；Node.js 在<strong>阶段切换间</strong>。</li><li><strong>特有 API</strong>：Node.js 有 <code>process.nextTick</code>（最高优）和 <code>setImmediate</code>（在 check 阶段）。</li></ol>`,45)])])}const o=i(n,[["render",l]]),k=JSON.parse('{"path":"/guide/%E6%B5%8F%E8%A7%88%E5%99%A8_%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%92%8Cnodejs%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%8C%BA%E5%88%AB.html","title":"浏览器和nodejs事件循环的区别","lang":"zh-CN","frontmatter":{"description":"浏览器和nodejs事件循环的区别 共同基础：什么是事件循环？ 浏览器中的事件循环 Node.js 中的事件循环 核心差异对比 Node.js 新版与旧版的差异 总结与流程图对比 1. 共同基础：什么是事件循环？ 事件循环是 JavaScript 实现非阻塞 I/O 和异步编程的基石。 它的核心机制是： 单线程：JavaScript 主线程是单线程的，...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"浏览器和nodejs事件循环的区别\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-10-19T15:34:32.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"yjieyan\\",\\"url\\":\\"https://yjieyan.github.io/knowledge\\"}]}"],["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/knowledge/guide/%E6%B5%8F%E8%A7%88%E5%99%A8_%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%92%8Cnodejs%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%8C%BA%E5%88%AB.html"}],["meta",{"property":"og:site_name","content":"学习与分享"}],["meta",{"property":"og:title","content":"浏览器和nodejs事件循环的区别"}],["meta",{"property":"og:description","content":"浏览器和nodejs事件循环的区别 共同基础：什么是事件循环？ 浏览器中的事件循环 Node.js 中的事件循环 核心差异对比 Node.js 新版与旧版的差异 总结与流程图对比 1. 共同基础：什么是事件循环？ 事件循环是 JavaScript 实现非阻塞 I/O 和异步编程的基石。 它的核心机制是： 单线程：JavaScript 主线程是单线程的，..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-10-19T15:34:32.000Z"}],["meta",{"property":"article:modified_time","content":"2025-10-19T15:34:32.000Z"}]]},"git":{"createdTime":1760888072000,"updatedTime":1760888072000,"contributors":[{"name":"yjy","username":"yjy","email":"2192242196@qq.com","commits":1,"url":"https://github.com/yjy"}]},"readingTime":{"minutes":5.82,"words":1747},"filePathRelative":"guide/浏览器&服务器/服务器/浏览器和nodejs事件循环的区别.md","autoDesc":true}');export{o as comp,k as data};
