import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as t,o as e}from"./app-Bp9_QJkp.js";const n={};function l(h,i){return e(),a("div",null,[...i[0]||(i[0]=[t(`<h1 id="react-源码解析" tabindex="-1"><a class="header-anchor" href="#react-源码解析"><span>React 源码解析</span></a></h1><hr><h3 id="一、-核心架构-fiber-架构的革命" tabindex="-1"><a class="header-anchor" href="#一、-核心架构-fiber-架构的革命"><span>一、 核心架构：Fiber 架构的革命</span></a></h3><p>React 16 引入的 <strong>Fiber 架构</strong> 是理解现代 React 源码的基石。它彻底重写了 React 的协调（Reconciliation）算法。</p><h4 id="_1-为什么需要-fiber-——-解决-卡顿-问题" tabindex="-1"><a class="header-anchor" href="#_1-为什么需要-fiber-——-解决-卡顿-问题"><span>1. 为什么需要 Fiber？—— 解决“卡顿”问题</span></a></h4><p>在 Fiber 之前（React 15 的 Stack Reconciler），协调过程是<strong>同步递归</strong>的。</p><ul><li><strong>问题</strong>：一旦开始渲染，就会递归调用整个组件树，直到完全处理完毕。这个过程无法中断。如果组件树很深，执行 JavaScript 会长时间占用主线程，导致高优先级任务（如用户输入、动画）被阻塞，造成页面卡顿。</li><li><strong>目标</strong>：Fiber 的目标是实现 <strong>可中断的异步渲染</strong>，为 Concurrent Mode（并发模式）打下基础。</li></ul><h4 id="_2-fiber-是什么-——-三个层面的理解" tabindex="-1"><a class="header-anchor" href="#_2-fiber-是什么-——-三个层面的理解"><span>2. Fiber 是什么？—— 三个层面的理解</span></a></h4><ol><li><strong>一个执行单元</strong>：Fiber 将整个渲染工作<strong>拆分成多个小工作单元</strong>。</li><li><strong>一种数据结构</strong>：<strong>每个 Fiber 节点都是一个 JavaScript 对象</strong>，它对应一个 React 元素（组件、DOM 节点等），保存了该节点的类型、状态、副作用、子节点、兄弟节点、父节点等信息。</li><li><strong>一种虚拟栈帧</strong>：Fiber 实现了自己的调用栈，允许 React 在渲染过程中<strong>暂停、中止或复用</strong>工作。</li></ol><h4 id="_3-fiber-节点的关键属性-简化" tabindex="-1"><a class="header-anchor" href="#_3-fiber-节点的关键属性-简化"><span>3. Fiber 节点的关键属性（简化）</span></a></h4><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-javascript"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">function</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> FiberNode</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">tag</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">pendingProps</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">key</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 实例属性</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">  this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">tag</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> tag</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 标识 Fiber 类型，如 FunctionComponent, ClassComponent, HostComponent</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">  this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">key</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> key</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">  this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">type</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 对于函数组件，是函数本身；对于类组件，是类；对于DOM元素，是标签名 &#39;div&#39;</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">  this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">stateNode</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 对应的真实实例，如 DOM 节点 或 类组件实例</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 构成 Fiber 树的结构属性 (链表结构)</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">  this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">return</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 父 Fiber</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">  this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">child</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 第一个子 Fiber</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">  this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">sibling</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 下一个兄弟 Fiber</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">  this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">index</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 在兄弟节点中的索引</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 用于协调的属性 (用于Diff和状态计算)</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">  this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">pendingProps</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> pendingProps</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 新的 Props</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">  this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">memoizedProps</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 上一次渲染时的 Props</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">  this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">memoizedState</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 上一次渲染时的 State (Hooks 链表存储在这里!)</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">  this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">updateQueue</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 状态更新队列 (存放setState产生的更新)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 副作用相关</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">  this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">flags</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> NoFlags</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// (旧版本为 effectTag) 标记这个 Fiber 需要执行什么操作（如 Placement-插入，Update-更新，Deletion-删除）</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">  this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">subtreeFlags</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> NoFlags</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 子树中的副作用标记 (用于性能优化)</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">  this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">alternate</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// **关键**：指向 current Fiber 树 或 workInProgress Fiber 树 中的对应节点</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 用于调度</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">  this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">lanes</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> NoLanes</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 车道模型，表示更新的优先级</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">  this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">childLanes</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> NoLanes</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="二、-双缓存-fiber-树与工作循环" tabindex="-1"><a class="header-anchor" href="#二、-双缓存-fiber-树与工作循环"><span>二、 双缓存 Fiber 树与工作循环</span></a></h3><h4 id="_1-双缓存技术-double-buffering" tabindex="-1"><a class="header-anchor" href="#_1-双缓存技术-double-buffering"><span>1. 双缓存技术 (Double Buffering)</span></a></h4><p>React 在内存中同时维护两棵 Fiber 树：</p><ul><li><strong><code>current</code> 树</strong>：当前屏幕上显示内容对应的 Fiber 树。</li><li><strong><code>workInProgress</code> 树</strong>：正在内存中构建的、即将用于下一次渲染的 Fiber 树。</li></ul><p>所有更新都发生在 <code>workInProgress</code> 树上。构建完成后，<code>workInProgress</code> 树会通过交换 <code>current</code> 指针，变成新的 <code>current</code> 树。这种交换非常快速，是实现无缝更新的关键。</p><h4 id="_2-可中断的协作式工作循环" tabindex="-1"><a class="header-anchor" href="#_2-可中断的协作式工作循环"><span>2. 可中断的协作式工作循环</span></a></h4><p>React 的渲染被分为两个主要阶段，它们由 <strong>Scheduler（调度器）</strong> 协同工作：</p><p><strong>阶段一：渲染/协调阶段 (Render/Reconciliation Phase)</strong></p><ul><li><strong>特点</strong>：<strong>可中断、可恢复、异步</strong>。可以被打断去执行更高优先级的任务。</li><li><strong>过程</strong>：React 采用 <strong>深度优先遍历</strong> 的方式构建 <code>workInProgress</code> 树。 <ul><li><strong><code>beginWork</code></strong>： <ul><li>这是处理一个 Fiber 节点的入口。根据 <code>Fiber.tag</code>，调用不同的更新方法（如 <code>updateFunctionComponent</code>, <code>updateHostComponent</code>）。</li><li>在这里会执行函数组件、调和子节点（React Diff 算法发生在这里）、为子元素创建或复用 Fiber 节点，并标记副作用（<code>flags</code>）。</li></ul></li><li><strong><code>completeWork</code></strong>： <ul><li>当一个 Fiber 节点及其所有子节点都处理完毕后，会进入此阶段。</li><li>在这里，对于 <code>HostComponent</code>（DOM 节点），会创建真实的 DOM 实例（但不会挂载），并基于 <code>pendingProps</code> 设置 DOM 属性。</li><li>这个阶段也会收集副作用，并冒泡到父节点的 <code>subtreeFlags</code> 中。</li></ul></li></ul></li><li><strong>调度</strong>：Scheduler 会检查当前帧剩余的时间（通过 <code>requestIdleCallback</code> 的 polyfill）。如果时间不够，React 会暂停当前工作，将控制权交还给浏览器。</li></ul><p><strong>阶段二：提交阶段 (Commit Phase)</strong></p><ul><li><strong>特点</strong>：<strong>不可中断、同步执行</strong>。此阶段会执行所有 DOM 操作，用户会看到更新。</li><li><strong>过程</strong>： <ul><li><strong><code>beforeMutation</code></strong>：执行 <code>getSnapshotBeforeUpdate</code> 生命周期。</li><li><strong><code>mutation</code></strong>：执行所有 DOM 操作（插入、更新、删除）。此时，用户能看到 DOM 的变化。这里会执行 <code>useLayoutEffect</code> 的销毁函数。</li><li><strong><code>layout</code></strong>：执行 <code>componentDidMount</code> 或 <code>componentDidUpdate</code> 生命周期，并更新 <code>ref</code>。然后执行 <code>useLayoutEffect</code> 的回调函数。</li><li><strong><code>passive effects</code></strong>：在绘制完成后，<strong>异步</strong> 执行 <code>useEffect</code> 的回调函数。</li></ul></li></ul><hr><h3 id="三、-状态与-hooks-的实现原理" tabindex="-1"><a class="header-anchor" href="#三、-状态与-hooks-的实现原理"><span>三、 状态与 Hooks 的实现原理</span></a></h3><p>Hooks 是函数组件的灵魂，其实现与 Fiber 架构紧密相连。</p><h4 id="_1-hooks-的存储" tabindex="-1"><a class="header-anchor" href="#_1-hooks-的存储"><span>1. Hooks 的存储</span></a></h4><p>在函数组件执行时（在 <code>renderWithHooks</code> 函数中），React 知道当前正在渲染哪个 Fiber 节点。<strong>所有 Hooks 的状态都存储在 Fiber 节点的 <code>memoizedState</code> 属性上，并以一个单向链表的形式组织。</strong></p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-javascript"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 简化版 Hook 结构</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> hook</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">  memoizedState</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 当前 Hook 的状态 </span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">  baseState</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,     </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// useState: 基础状态; useEffect: effect对象</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">  baseQueue</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,     </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 被跳过的更新队列</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">  queue</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,         </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 更新队列 (对于 useState/useReducer)</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">  next</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,          </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 指向下一个 Hook</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">};</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当函数组件执行时，每调用一个 Hook（如 <code>useState</code>），React 就按顺序从这条链表中取出对应的 Hook 对象进行操作。</p><h4 id="_2-usestate-usereducer-原理" tabindex="-1"><a class="header-anchor" href="#_2-usestate-usereducer-原理"><span>2. <code>useState</code> / <code>useReducer</code> 原理</span></a></h4><ul><li><strong><code>queue</code></strong>：每个 <code>useState</code> Hook 都有一个 <code>queue</code>（一个环形链表），里面存放了所有调度好的更新（如多次 <code>setState</code>）。</li><li><strong>更新流程</strong>： <ol><li>调用 <code>setState</code> 会创建一个更新对象，并将其放入对应 Hook 的 <code>queue</code> 中。</li><li>然后调度一次新的根更新（<code>scheduleUpdateOnFiber</code>）。</li><li>在后续的渲染阶段，React 会重新执行函数组件。</li><li>再次执行 <code>useState</code> 时，React 会遍历 <code>queue</code>，根据基础状态和所有更新，计算最新的 state，并返回。</li></ol></li></ul><h4 id="_3-useeffect-原理" tabindex="-1"><a class="header-anchor" href="#_3-useeffect-原理"><span>3. <code>useEffect</code> 原理</span></a></h4><ul><li><strong>存储</strong>：<code>useEffect</code> 的依赖项和回调函数被存储在一个 <code>effect</code> 对象中，该对象被链接到 Fiber 节点的 <code>memoizedState</code> Hook 链表中，<strong>同时也会被附加到 Fiber 节点的 <code>updateQueue</code> 上</strong>。</li><li><strong>执行时机</strong>：<code>useEffect</code> 的副作用在 <strong>提交阶段后的 <code>passive effects</code> 子阶段被异步调度执行</strong>。React 会在浏览器绘制完成后，通知 Scheduler 去执行这些副作用。而 <code>useLayoutEffect</code> 会在 <strong>提交阶段的 <code>layout</code> 子阶段同步执行</strong>，所以会阻塞浏览器绘制。</li></ul><h4 id="_4-hooks-调用规则的本质" tabindex="-1"><a class="header-anchor" href="#_4-hooks-调用规则的本质"><span>4. Hooks 调用规则的本质</span></a></h4><p><strong>Hooks 必须在函数组件的顶层以相同的顺序调用。</strong> 这是因为 React 依赖于 <strong>Hook 调用顺序的稳定性</strong> 来正确地将 <code>memoizedState</code> 链表中的状态与每次渲染的 Hook 一一对应。如果放在条件语句中，顺序被打乱，状态就会“张冠李戴”，导致严重 bug。</p><hr><h3 id="四、-事件系统-syntheticevent" tabindex="-1"><a class="header-anchor" href="#四、-事件系统-syntheticevent"><span>四、 事件系统 (SyntheticEvent)</span></a></h3><p>React 实现了自己的<strong>合成事件 (SyntheticEvent)</strong> 系统。</p><ul><li><strong>事件委托</strong>：React 并不会将事件处理器直接绑定到每个 DOM 节点上。相反，它会在 <code>document</code>（v17 后改为 <code>root DOM container</code>）上为每种支持的事件类型注册一个<strong>原生事件监听器</strong>。</li><li><strong>合成事件对象</strong>：当事件触发时，React 会创建一个包装了原生事件对象的 <strong>SyntheticEvent</strong> 对象。它提供了与原生事件相同的接口，但消除了浏览器间的兼容性差异。</li><li><strong>事件池</strong>：为了提高性能，SyntheticEvent 对象会被放入一个池中复用。这意味着在事件回调执行后，事件对象的属性会被清空。这就是为什么在异步函数中访问 <code>event</code> 需要调用 <code>event.persist()</code> 的原因。</li></ul><hr><h3 id="五、-diffing-算法-协调算法" tabindex="-1"><a class="header-anchor" href="#五、-diffing-算法-协调算法"><span>五、 Diffing 算法 (协调算法)</span></a></h3><p>当 React 协调子元素时，默认采用高效的 <strong>同层比较</strong> 策略。</p><ol><li><strong>遍历比较</strong>：React 同时遍历新旧两套子元素列表。</li><li><strong>Key 的重要性</strong>： <ul><li>如果元素有 <code>key</code>，React 使用 key 来匹配新旧列表中的对应元素。这使得在列表中间插入或删除元素时，可以高效地复用 Fiber 节点，而不是进行昂贵的重新创建。</li><li>如果没有 <code>key</code>，React 默认使用索引（index）进行比较，这在列表顺序变化时会导致性能下降和状态错乱。</li></ul></li><li><strong>策略</strong>：通过一轮遍历，处理常见的操作（如节点不变、节点属性更新、节点类型改变），对于复杂的节点移动，React 会采用一种高效的算法来最小化操作次数。</li></ol><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><ol><li><strong>Fiber 架构是核心</strong>：它将同步不可中断的递归渲染，改造为<strong>基于链表结构的、可中断的异步渲染</strong>，通过<strong>双缓存树</strong>和<strong>协作式调度</strong>解决了主线程阻塞问题。</li><li><strong>分阶段渲染</strong>：<strong>可中断的协调阶段</strong>负责计算变更，<strong>同步的提交阶段</strong>负责执行变更，保证了视图更新的最终一致性。</li><li><strong>Hooks 与 Fiber 绑定</strong>：Hooks 的状态存储在 Fiber 节点的链表中，其调用顺序的稳定性是正确工作的前提。</li><li><strong>合成事件与高效 Diff</strong>：通过事件委托和智能的 Diffing 策略，提供了高性能的用户交互和视图更新体验。</li><li><strong>并发是未来</strong>：Fiber 架构为 <code>useTransition</code>、<code>Suspense</code> 等并发特性铺平了道路，使 React 能打造更响应的用户界面。</li></ol>`,46)])])}const o=s(n,[["render",l]]),p=JSON.parse('{"path":"/guide/source-code/React%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.html","title":"React 源码解析","lang":"zh-CN","frontmatter":{"description":"React 源码解析 一、 核心架构：Fiber 架构的革命 React 16 引入的 Fiber 架构 是理解现代 React 源码的基石。它彻底重写了 React 的协调（Reconciliation）算法。 1. 为什么需要 Fiber？—— 解决“卡顿”问题 在 Fiber 之前（React 15 的 Stack Reconciler），协调过...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"React 源码解析\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-10-19T15:34:32.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"yjieyan\\",\\"url\\":\\"https://yjieyan.github.io/knowledge\\"}]}"],["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/knowledge/guide/source-code/React%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.html"}],["meta",{"property":"og:site_name","content":"学习与分享"}],["meta",{"property":"og:title","content":"React 源码解析"}],["meta",{"property":"og:description","content":"React 源码解析 一、 核心架构：Fiber 架构的革命 React 16 引入的 Fiber 架构 是理解现代 React 源码的基石。它彻底重写了 React 的协调（Reconciliation）算法。 1. 为什么需要 Fiber？—— 解决“卡顿”问题 在 Fiber 之前（React 15 的 Stack Reconciler），协调过..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-10-19T15:34:32.000Z"}],["meta",{"property":"article:modified_time","content":"2025-10-19T15:34:32.000Z"}]]},"git":{"createdTime":1760704942000,"updatedTime":1760888072000,"contributors":[{"name":"yjy","username":"yjy","email":"2192242196@qq.com","commits":3,"url":"https://github.com/yjy"}]},"readingTime":{"minutes":7.81,"words":2342},"filePathRelative":"guide/source-code/React源码解析.md","autoDesc":true}');export{o as comp,p as data};
