import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,a as d,o as n}from"./app-DtG3coGW.js";const c={};function l(s,e){return n(),t("div",null,[...e[0]||(e[0]=[d('<h1 id="package-json版本号规则" tabindex="-1"><a class="header-anchor" href="#package-json版本号规则"><span>package.json版本号规则</span></a></h1><p><code>package.json</code> 中的版本号遵循 <strong>语义化版本控制（Semantic Versioning，简称 SemVer）</strong> 规范。</p><ol><li><strong>语义化版本（SemVer）的核心概念</strong></li><li><strong>版本号格式解析</strong></li><li><strong>版本范围语法（依赖声明规则）</strong></li><li><strong>Node.js 包管理器如何处理版本范围</strong></li><li><strong>特殊版本与标签</strong></li><li><strong>最佳实践总结</strong></li></ol><hr><h3 id="_1-语义化版本-semver-的核心概念" tabindex="-1"><a class="header-anchor" href="#_1-语义化版本-semver-的核心概念"><span>1. 语义化版本（SemVer）的核心概念</span></a></h3><p>SemVer 的格式为 <code>主版本号.次版本号.修订号</code>（<code>MAJOR.MINOR.PATCH</code>），其变更有明确的含义：</p><ul><li><strong>主版本号（MAJOR）</strong>：当你做了<strong>不兼容的 API 修改</strong>。 <ul><li>例如：从 <code>1.x.x</code> 升级到 <code>2.0.0</code>，可能意味着原有的 API 被移除或重写，升级时需要仔细检查代码。</li></ul></li><li><strong>次版本号（MINOR）</strong>：当你做了<strong>向下兼容的功能性新增</strong>。 <ul><li>例如：从 <code>1.1.0</code> 升级到 <code>1.2.0</code>，表示新增了功能，但原有的 API 没有被破坏。你可以安全地升级。</li></ul></li><li><strong>修订号（PATCH）</strong>：当你做了<strong>向下兼容的问题修正</strong>。 <ul><li>例如：从 <code>1.2.0</code> 升级到 <code>1.2.1</code>，表示修复了 bug，没有新增任何功能。你应该尽快升级以保证稳定性。</li></ul></li></ul><p><strong>预发布版本</strong>和<strong>构建元数据</strong>可以作为附加标签，格式为：<code>主版本号.次版本号.修订号-预发布标签+构建数据</code>，例如 <code>1.2.3-beta.1+20240527</code>。</p><hr><h3 id="_2-版本号格式解析" tabindex="-1"><a class="header-anchor" href="#_2-版本号格式解析"><span>2. 版本号格式解析</span></a></h3><table><thead><tr><th style="text-align:left;">版本号</th><th style="text-align:left;">说明</th><th style="text-align:left;">稳定性</th></tr></thead><tbody><tr><td style="text-align:left;"><code>1.0.0</code></td><td style="text-align:left;">标准的正式版</td><td style="text-align:left;">稳定</td></tr><tr><td style="text-align:left;"><code>1.2.3</code></td><td style="text-align:left;">明确的、具体的版本</td><td style="text-align:left;">非常稳定</td></tr><tr><td style="text-align:left;"><code>0.1.0</code></td><td style="text-align:left;"><strong>初始开发版本</strong>。此阶段任何更新都可能包含不兼容的变更。</td><td style="text-align:left;">极不稳定</td></tr><tr><td style="text-align:left;"><code>1.2.3-beta.0</code></td><td style="text-align:left;"><strong>预发布版本</strong>。用于测试，稳定性低于正式版。</td><td style="text-align:left;">不稳定</td></tr><tr><td style="text-align:left;"><code>1.2.3-alpha</code></td><td style="text-align:left;">比 <code>beta</code> 更早的预发布版本。</td><td style="text-align:left;">非常不稳定</td></tr></tbody></table><hr><h3 id="_3-版本范围语法-依赖声明规则" tabindex="-1"><a class="header-anchor" href="#_3-版本范围语法-依赖声明规则"><span>3. 版本范围语法（依赖声明规则）</span></a></h3><p>这是 <code>package.json</code> 中 <code>dependencies</code> 和 <code>devDependencies</code> 里最核心的部分。它定义了你的项目<strong>可以接受</strong>的依赖版本范围。</p><h4 id="精确版本" tabindex="-1"><a class="header-anchor" href="#精确版本"><span><strong>精确版本</strong></span></a></h4><ul><li><code>&quot;1.2.3&quot;</code>：<strong>只</strong>安装版本 <code>1.2.3</code>。</li><li><strong>优点</strong>：确定性最高，所有环境安装的版本完全一致。</li><li><strong>缺点</strong>：无法自动获取重要的安全补丁和 bug 修复。</li></ul><h4 id="比较运算符" tabindex="-1"><a class="header-anchor" href="#比较运算符"><span><strong>比较运算符</strong></span></a></h4><ul><li><code>&gt;1.2.3</code>：大于 <code>1.2.3</code></li><li><code>&gt;=1.2.3</code>：大于等于 <code>1.2.3</code></li><li><code>&lt;1.2.3</code>：小于 <code>1.2.3</code></li><li><code>&lt;=1.2.3</code>：小于等于 <code>1.2.3</code></li></ul><h4 id="连字符范围" tabindex="-1"><a class="header-anchor" href="#连字符范围"><span><strong>连字符范围（-）</strong></span></a></h4><ul><li><code>&quot;1.2.3 - 2.3.4&quot;</code>：等同于 <code>&gt;=1.2.3 &lt;=2.3.4</code>。</li></ul><h4 id="通配符-x-range" tabindex="-1"><a class="header-anchor" href="#通配符-x-range"><span><strong>通配符 / X-Range</strong></span></a></h4><ul><li><code>*</code> 或 <code>&quot;&quot;</code>：匹配任何版本。</li><li><code>1.x</code> 或 <code>1.*</code> 或 <code>1</code>：匹配主版本为 1 的任何版本，即 <code>&gt;=1.0.0 &lt;2.0.0</code>。</li><li><code>1.2.x</code> 或 <code>1.2.*</code>：匹配主版本为 1，次版本为 2 的任何版本，即 <code>&gt;=1.2.0 &lt;1.3.0</code>。</li></ul><h4 id="波浪符范围-——-保持修订号级别" tabindex="-1"><a class="header-anchor" href="#波浪符范围-——-保持修订号级别"><span><strong>波浪符范围（~）—— 保持修订号级别</strong></span></a></h4><p><strong>“允许修订号变更”</strong>。它允许<strong>修订号</strong>（最后一位）递增，但会锁定<strong>主版本</strong>和<strong>次版本</strong>。</p><ul><li><code>~1.2.3</code>：<code>&gt;=1.2.3 &lt;1.3.0</code></li><li><code>~1.2</code>：<code>&gt;=1.2.0 &lt;1.3.0</code> (等同于 <code>1.2.x</code>)</li><li><code>~1</code>：<code>&gt;=1.0.0 &lt;2.0.0</code> (等同于 <code>1.x</code>)</li><li><code>~0.2.3</code>：<code>&gt;=0.2.3 &lt;0.3.0</code> (对于 <code>0.x.x</code> 版本要特别注意)</li><li><code>~0.2</code>：<code>&gt;=0.2.0 &lt;0.3.0</code></li><li><code>~0</code>：<code>&gt;=0.0.0 &lt;1.0.0</code></li></ul><p><strong>使用场景</strong>：当你想要自动获取 bug 修复和安全补丁，但又不想冒引入不兼容变更的风险时使用。这是<strong>最常用、最安全</strong>的策略之一。</p><h4 id="插入符范围-——-保持主版本级别" tabindex="-1"><a class="header-anchor" href="#插入符范围-——-保持主版本级别"><span><strong>插入符范围（^）—— 保持主版本级别</strong></span></a></h4><p><strong>“允许不破坏兼容的更新”</strong>。它允许<strong>次版本</strong>和<strong>修订号</strong>（后两位）递增，但会锁定<strong>主版本</strong>。</p><ul><li><code>^1.2.3</code>：<code>&gt;=1.2.3 &lt;2.0.0</code></li><li><code>^0.2.3</code>：<code>&gt;=0.2.3 &lt;0.3.0</code> (对于 <code>0.x.x</code> 版本，因为它被认为是初始开发阶段，所以行为类似 <code>~</code>)</li><li><code>^0.0.3</code>：<code>&gt;=0.0.3 &lt;0.0.4</code> (对于 <code>0.0.x</code>，它被锁定得非常严格)</li><li><code>^1.2.x</code>：<code>&gt;=1.2.0 &lt;2.0.0</code></li><li><code>^0.0.x</code>：<code>&gt;=0.0.0 &lt;0.1.0</code></li></ul><p><strong>使用场景</strong>：当你想要自动获取新功能和 bug 修复，且相信依赖库会严格遵守 SemVer 规范（即次版本更新不会破坏兼容性）时使用。这是 <strong><code>npm install --save</code> 的默认行为</strong>。</p><hr><h3 id="_4-node-js-包管理器如何处理版本范围" tabindex="-1"><a class="header-anchor" href="#_4-node-js-包管理器如何处理版本范围"><span>4. Node.js 包管理器如何处理版本范围</span></a></h3><p>当你运行 <code>npm install</code> 时，包管理器（npm、yarn、pnpm）会执行以下操作：</p><ol><li>解析 <code>package.json</code> 中所有的依赖声明。</li><li>对于每个依赖，根据其版本范围描述，查找 <strong>registry（如 <a href="http://npmjs.com" target="_blank" rel="noopener noreferrer">npmjs.com</a>）</strong> 上满足条件的<strong>最高版本</strong>。</li><li>下载并安装该版本，同时将<strong>确切的版本号</strong>写入 <code>package-lock.json</code>、<code>yarn.lock</code> 或 <code>pnpm-lock.yaml</code> 文件中。</li></ol><p><strong><code>package-lock.json</code> 的作用</strong>：它记录了当前状态下所有依赖的<strong>确切版本</strong>，确保了团队成员和部署环境之间安装完全一致的依赖树，从而实现了“确定性安装”。<strong>这个文件应该被提交到版本控制系统中。</strong></p><hr><h3 id="_5-特殊版本与标签" tabindex="-1"><a class="header-anchor" href="#_5-特殊版本与标签"><span>5. 特殊版本与标签</span></a></h3><ul><li><strong><code>latest</code></strong>：默认标签，指向当前最新的稳定版。</li><li><strong><code>next</code></strong>：预发布版本的常用标签。</li></ul><hr><h3 id="_6-最佳实践总结" tabindex="-1"><a class="header-anchor" href="#_6-最佳实践总结"><span>6. 最佳实践总结</span></a></h3><ol><li><strong>理解 <code>^</code> 和 <code>~</code></strong>： <ul><li>对<strong>应用项目</strong>，通常使用默认的 <code>^</code>，以自动获取新功能和修复。</li><li>对<strong>库项目</strong>，可以考虑使用 <code>~</code> 或将依赖锁定为精确版本，以给使用者带来更稳定的体验。</li></ul></li><li><strong>始终提交锁文件</strong>：确保 <code>package-lock.json</code> 等锁文件被提交，这是保证一致性的关键。</li><li><strong>定期更新依赖</strong>：使用 <code>npm outdated</code> 查看过时的包，并使用 <code>npm update</code> 或 <code>npm install package@latest</code> 进行更新。定期处理安全漏洞（<code>npm audit</code>）。</li><li><strong>谨慎对待 <code>0.x.x</code> 版本</strong>：<code>0.x.x</code> 版本的库被视为不稳定，它们的 <code>^</code> 和 <code>~</code> 行为可能不符合预期。</li><li><strong>生产环境部署</strong>：始终使用 <code>npm ci</code> 命令（而不是 <code>npm install</code>）在CI/CD和生产环境中安装依赖，因为它会严格依据锁文件安装，速度更快、更可靠。</li></ol>',41)])])}const i=o(c,[["render",l]]),g=JSON.parse('{"path":"/guide/%E6%B5%8F%E8%A7%88%E5%99%A8_%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8/package.json%E7%89%88%E6%9C%AC%E5%8F%B7%E8%A7%84%E5%88%99.html","title":"package.json版本号规则","lang":"zh-CN","frontmatter":{"description":"package.json版本号规则 package.json 中的版本号遵循 语义化版本控制（Semantic Versioning，简称 SemVer） 规范。 语义化版本（SemVer）的核心概念 版本号格式解析 版本范围语法（依赖声明规则） Node.js 包管理器如何处理版本范围 特殊版本与标签 最佳实践总结 1. 语义化版本（SemVer）的...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"package.json版本号规则\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-10-19T15:34:32.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"yjieyan\\",\\"url\\":\\"https://yjieyan.github.io/knowledge\\"}]}"],["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/knowledge/guide/%E6%B5%8F%E8%A7%88%E5%99%A8_%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8/package.json%E7%89%88%E6%9C%AC%E5%8F%B7%E8%A7%84%E5%88%99.html"}],["meta",{"property":"og:site_name","content":"学习与分享"}],["meta",{"property":"og:title","content":"package.json版本号规则"}],["meta",{"property":"og:description","content":"package.json版本号规则 package.json 中的版本号遵循 语义化版本控制（Semantic Versioning，简称 SemVer） 规范。 语义化版本（SemVer）的核心概念 版本号格式解析 版本范围语法（依赖声明规则） Node.js 包管理器如何处理版本范围 特殊版本与标签 最佳实践总结 1. 语义化版本（SemVer）的..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-10-19T15:34:32.000Z"}],["meta",{"property":"article:modified_time","content":"2025-10-19T15:34:32.000Z"}]]},"git":{"createdTime":1760888072000,"updatedTime":1760888072000,"contributors":[{"name":"yjy","username":"yjy","email":"2192242196@qq.com","commits":1,"url":"https://github.com/yjy"}]},"readingTime":{"minutes":4.49,"words":1347},"filePathRelative":"guide/浏览器&服务器/服务器/package.json版本号规则.md","autoDesc":true}');export{i as comp,g as data};
