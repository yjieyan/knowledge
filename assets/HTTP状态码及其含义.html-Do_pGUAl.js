import{_ as l}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as g,f as r,a as o,b as n,d as i,w as e,r as a,o as p}from"./app-D1Bmfn99.js";const u={};function d(x,t){const s=a("RouteLink");return p(),g("div",null,[t[6]||(t[6]=r('<h1 id="http状态码及其含义" tabindex="-1"><a class="header-anchor" href="#http状态码及其含义"><span>HTTP状态码及其含义</span></a></h1><hr><h3 id="总览" tabindex="-1"><a class="header-anchor" href="#总览"><span>总览</span></a></h3><p>HTTP状态码由三位数字组成，第一位数字定义了响应的类别，后两位没有分类作用。共有5大类：</p><ul><li><strong>1xx: 信息性状态码</strong> - 请求已被接收，继续处理。</li><li><strong>2xx: 成功状态码</strong> - 请求已成功被服务器接收、理解、并接受。</li><li><strong>3xx: 重定向状态码</strong> - 需要客户端采取进一步的操作才能完成请求。</li><li><strong>4xx: 客户端错误状态码</strong> - 请求含有语法错误或者无法被执行。</li><li><strong>5xx: 服务器错误状态码</strong> - 服务器在处理某个正确请求时发生错误。</li></ul><hr><h3 id="_1xx-信息性状态码" tabindex="-1"><a class="header-anchor" href="#_1xx-信息性状态码"><span>1xx - 信息性状态码</span></a></h3><p>这类状态码在常规Web开发中较少见到，主要用于低层级通信。</p><ul><li><strong>100 Continue：</strong><ul><li><strong>含义：</strong> 客户端发送的请求体中包含较大的数据时，会先发送一个带有 <code>Expect: 100-continue</code> 头的请求。服务器如果愿意接受这个请求体，就返回100。客户端收到后，再继续发送请求体。</li><li><strong>场景：</strong> 文件上传等大数据量POST请求，用于避免客户端在服务器拒绝时浪费带宽。</li></ul></li><li><strong>101 Switching Protocols：</strong><ul><li><strong>含义：</strong> 客户端请求升级协议（如从HTTP升级到WebSocket），服务器同意升级。</li><li><strong>场景：</strong> 建立WebSocket连接时，在握手阶段会看到这个状态码。</li></ul></li><li><strong>102 Processing：</strong><ul><li><strong>含义：</strong> 服务器已收到并正在处理请求，但尚无响应。</li><li><strong>场景：</strong> 用于处理耗时很长的请求，避免客户端因超时而断开连接。</li></ul></li></ul><hr><h3 id="_2xx-成功状态码" tabindex="-1"><a class="header-anchor" href="#_2xx-成功状态码"><span>2xx - 成功状态码</span></a></h3><ul><li><p><strong>200 OK：</strong></p><ul><li><strong>含义：</strong> <strong>请求成功。</strong> 这是最常见的状态码。响应体中包含了所请求的数据。</li><li><strong>细节：</strong> 对于GET请求，资源在响应体中返回；对于POST请求，结果是操作成功的描述或资源本身。</li></ul></li><li><p><strong>201 Created：</strong></p><ul><li><strong>含义：</strong> <strong>请求已成功，并因此创建了一个新的资源。</strong> 这通常是在POST或PUT请求之后发送的响应。</li><li><strong>最佳实践：</strong> 响应中应该通过 <code>Location</code> 头指明新创建资源的URI。</li><li><strong>场景：</strong> 用户注册成功、创建新文章。</li></ul></li><li><p><strong>202 Accepted：</strong></p><ul><li><strong>含义：</strong> <strong>服务器已接受请求，但尚未处理完成。</strong> 请求可能会被处理，也可能不会被处理。</li><li><strong>场景：</strong> 异步任务、需要排队处理的任务。例如，提交一个视频转码请求，服务器立即返回202，表示请求合法已接受，但转码在后台进行。</li></ul></li><li><p><strong>204 No Content：</strong></p><ul><li><strong>含义：</strong> <strong>服务器成功处理了请求，但不需要返回任何实体内容。</strong></li><li><strong>场景：</strong> DELETE请求成功（已删除，无内容可返回）；前端向后台发送一个“已读”状态更新的请求，后台只需确认成功，无需返回数据。</li></ul></li><li><p><strong>206 Partial Content：</strong></p><ul><li><strong>含义：</strong> <strong>客户端进行了范围请求，而服务器成功执行了这部分的GET请求。</strong></li><li><strong>场景：</strong> 视频/音频文件的断点续传、大文件分片下载。响应头中会包含 <code>Content-Range</code> 字段，指明返回内容的范围。</li></ul></li></ul><hr><h3 id="_3xx-重定向状态码" tabindex="-1"><a class="header-anchor" href="#_3xx-重定向状态码"><span>3xx - 重定向状态码</span></a></h3><ul><li><p><strong>301 Moved Permanently：</strong></p><ul><li><strong>含义：</strong> <strong>永久重定向。</strong> 请求的资源已被<strong>永久地</strong>移动到新的URI。</li><li><strong>浏览器/搜索引擎行为：</strong> 浏览器会缓存这个重定向关系，下次访问原地址时会直接跳转到新地址，而不再请求原地址。搜索引擎会将权重和排名转移到新的URL。</li><li><strong>场景：</strong> 网站改版，更换域名。</li></ul></li><li><p><strong>302 Found：</strong></p><ul><li><strong>含义：</strong> <strong>临时重定向。</strong> 请求的资源<strong>临时地</strong>从不同的URI响应请求。</li><li><strong>浏览器/搜索引擎行为：</strong> 浏览器不会缓存这个关系，下次访问原地址时还会先请求原地址。搜索引擎会继续抓取原地址。</li><li><strong>一个重要的问题（历史包袱）：</strong> 302的原始规范要求重定向后的请求方法<strong>必须不变</strong>（例如POST重定向后还应是POST）。但几乎所有浏览器和客户端都将其实现为<strong>GET</strong>方法。这导致了...</li><li><strong>场景：</strong> 未登录用户访问个人中心，临时重定向到登录页。</li></ul></li><li><p><strong>303 See Other：</strong></p><ul><li><strong>含义：</strong> 对应当前请求的响应可以在另一个URI上被找到，而且客户端应当采用<strong>GET</strong>方式访问那个资源。</li><li><strong>作用：</strong> 它明确了302的歧义，<strong>强制</strong>将后续请求变为GET。</li><li><strong>场景：</strong> 在POST请求（如表单提交）后，返回303并重定向到一个“操作成功”的页面，防止用户刷新页面导致表单重复提交。</li></ul></li><li><p><strong>304 Not Modified：</strong></p><ul><li><strong>含义：</strong> <strong>资源未改变。</strong> 这是一个用于<strong>缓存</strong>的重定向。客户端发送条件请求（例如带有 <code>If-Modified-Since</code> 或 <code>If-None-Match</code> 头），如果资源未变更，服务器会返回304，告诉客户端可以直接使用缓存的版本。</li><li><strong>注意：</strong> 它不是一个真正的重定向，因为响应体为空，节省了带宽。</li><li><strong>场景：</strong> 浏览器缓存验证。</li></ul></li><li><p><strong>307 Temporary Redirect：</strong></p><ul><li><strong>含义：</strong> <strong>临时重定向。</strong> 与302类似，但<strong>严格要求</strong>重定向后的请求方法和实体不能改变（例如，POST必须仍是POST）。</li><li><strong>场景：</strong> 在需要保证请求方法不变的临时重定向场景下使用，比302更安全、更符合预期。</li></ul></li><li><p><strong>308 Permanent Redirect：</strong></p><ul><li><strong>含义：</strong> <strong>永久重定向。</strong> 与301类似，但<strong>严格要求</strong>重定向后的请求方法和实体不能改变。</li><li><strong>场景：</strong> 在需要保证请求方法不变的永久重定向场景下使用。</li></ul></li></ul><p><strong>小结：</strong></p><ul><li><strong>永久：</strong> 301 (不保方法) vs 308 (保方法)</li><li><strong>临时：</strong> 302 (不保方法，事实标准) vs 307 (保方法)</li><li><strong>特殊：</strong> 303 (明确转GET) , 304 (缓存)</li></ul><hr><h3 id="_4xx-客户端错误状态码" tabindex="-1"><a class="header-anchor" href="#_4xx-客户端错误状态码"><span>4xx - 客户端错误状态码</span></a></h3><ul><li><p><strong>400 Bad Request：</strong></p><ul><li><strong>含义：</strong> <strong>请求报文存在语法错误。</strong> 这是一个笼统的错误码。</li><li><strong>场景：</strong> 请求体格式错误（如JSON缺少逗号）、参数类型错误。</li></ul></li><li><p><strong>401 Unauthorized：</strong></p><ul><li><strong>含义：</strong> <strong>未经授权。</strong> 请求需要用户的身份认证。</li><li><strong>注意：</strong> 这个名字容易引起误解，它实际指的是“认证”失败，而不是“授权”。更准确的叫法应该是 <code>Unauthenticated</code>。</li><li><strong>场景：</strong> 用户未登录，尝试访问需要登录的API；登录时用户名或密码错误。</li></ul></li><li><p><strong>403 Forbidden：</strong></p><ul><li><strong>含义：</strong> <strong>服务器理解请求，但拒绝执行。</strong> 与401不同，服务器知道你的身份，但你的身份没有权限访问该资源。</li><li><strong>场景：</strong> 普通用户尝试访问管理员后台。</li></ul></li><li><p><strong>404 Not Found：</strong></p><ul><li><strong>含义：</strong> <strong>服务器找不到请求的资源。</strong> 最著名的状态码。</li><li><strong>场景：</strong> 请求了不存在的URL、访问已被删除的文章。</li></ul></li><li><p><strong>405 Method Not Allowed：</strong></p><ul><li><strong>含义：</strong> 请求行中指定的请求方法不能被用于请求相应的资源。</li><li><strong>响应头：</strong> 服务器必须返回 <code>Allow</code> 头，列出该资源所支持的请求方法（如 <code>Allow: GET, POST</code>）。</li><li><strong>场景：</strong> 向一个只接受GET请求的API端点发送了POST请求。</li></ul></li><li><p><strong>408 Request Timeout：</strong></p><ul><li><strong>含义：</strong> <strong>请求超时。</strong> 服务器等待客户端发送请求的时间过长。</li><li><strong>场景：</strong> 网络连接慢，客户端未在服务器规定的时间内发送完整个请求。</li></ul></li><li><p><strong>409 Conflict：</strong></p><ul><li><strong>含义：</strong> <strong>请求与服务器的当前状态冲突。</strong></li><li><strong>场景：</strong> 最经典的场景是<strong>版本冲突</strong>。例如，基于文件的版本控制（如Git），两个人同时修改同一个文件；或者使用PUT更新资源时，资源的版本号与服务器上的不匹配。</li></ul></li><li><p><strong>429 Too Many Requests：</strong></p><ul><li><strong>含义：</strong> <strong>用户在给定的时间内发送了太多的请求。</strong> 即“限流”或“速率限制”。</li><li><strong>场景：</strong> 防止爬虫、防止暴力破解。响应头中常带有 <code>Retry-After</code>，告诉客户端多久后可以重试。</li></ul></li></ul><hr><h3 id="_5xx-服务器错误状态码" tabindex="-1"><a class="header-anchor" href="#_5xx-服务器错误状态码"><span>5xx - 服务器错误状态码</span></a></h3><p>这类错误<strong>责任在服务器端</strong>，需要客户端妥善处理。</p><ul><li><p><strong>500 Internal Server Error：</strong></p><ul><li><strong>含义：</strong> <strong>服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。</strong> 一个笼统的“万能”错误码。</li><li><strong>场景：</strong> 服务器端代码有Bug（如空指针异常）、数据库连接突然断开。</li></ul></li><li><p><strong>501 Not Implemented：</strong></p><ul><li><strong>含义：</strong> <strong>服务器不支持当前请求所需要的某个功能。</strong></li><li><strong>场景：</strong> 客户端请求了服务器尚未实现的HTTP方法。</li></ul></li><li><p><strong>502 Bad Gateway：</strong></p><ul><li><strong>含义：</strong> <strong>作为网关或代理的服务器，从上游服务器收到了一个无效的响应。</strong></li><li><strong>场景：</strong> 当我们的应用服务器（如Nginx）反向代理到后端的应用服务（如Node.js, Java）时，如果后端服务崩溃、无响应或返回无法理解的内容，Nginx就会返回502。</li></ul></li><li><p><strong>503 Service Unavailable：</strong></p><ul><li><strong>含义：</strong> <strong>服务器目前无法使用（由于超载或停机维护）。</strong> 这通常是一个<strong>临时</strong>的状态。</li><li><strong>场景：</strong> 服务器因流量激增而过载；系统正在进行停机维护。响应头中同样可能包含 <code>Retry-After</code>。</li></ul></li><li><p><strong>504 Gateway Timeout：</strong></p><ul><li><strong>含义：</strong> <strong>作为网关或代理的服务器，未能及时从上游服务器收到响应。</strong></li><li><strong>场景：</strong> 与502类似，但问题出在<strong>超时</strong>。上游服务器处理时间过长，网关等不及了。</li></ul></li></ul><p><strong>区分502、503、504：</strong></p><ul><li><strong>502：</strong> 上游服务器返回了“错误的东西”（无效响应）。</li><li><strong>503：</strong> 上游服务器明确表示“我现在忙，过会儿再来”。</li><li><strong>504：</strong> 上游服务器“太慢了”，网关等不及了。</li></ul><hr><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3>',28)),o("ol",null,[t[5]||(t[5]=r("<li><strong>成功类 (2xx)：</strong> 正常处理响应数据。</li><li><strong>重定向类 (3xx)：</strong> 浏览器会自动处理，但要知道301对SEO的影响。在AJAX/Fetch中，默认不自动跟随重定向，需要手动设置 <code>redirect</code> 选项。</li><li><strong>客户端错误 (4xx)：</strong><ul><li><strong>400/422:</strong> 通常需要将服务器返回的错误信息展示给用户，告知其如何修正请求。</li><li><strong>401:</strong> 清除本地Token，跳转到登录页。</li><li><strong>403:</strong> 向用户展示“权限不足”的提示。</li><li><strong>404:</strong> 展示友好的“页面未找到”界面。</li><li><strong>429:</strong> 提示用户操作过于频繁，稍后再试。</li></ul></li>",3)),o("li",null,[t[4]||(t[4]=o("strong",null,"服务器错误 (5xx)：",-1)),o("ul",null,[t[3]||(t[3]=o("li",null,"展示友好的“服务器开小差”错误页面。",-1)),o("li",null,[t[1]||(t[1]=n("对于500/503等错误，可以实现",-1)),i(s,{to:"/guide/computer/%E7%BD%91%E7%BB%9C/%E6%8C%87%E6%95%B0%E9%80%80%E9%81%BF%E7%AE%97%E6%B3%95%E7%9A%84%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6.html"},{default:e(()=>[...t[0]||(t[0]=[n("指数退避算法的重试机制",-1)])]),_:1}),t[2]||(t[2]=n("。",-1))])])])])])}const T=l(u,[["render",d]]),m=JSON.parse('{"path":"/guide/computer/%E7%BD%91%E7%BB%9C/HTTP%E7%8A%B6%E6%80%81%E7%A0%81%E5%8F%8A%E5%85%B6%E5%90%AB%E4%B9%89.html","title":"HTTP状态码及其含义","lang":"zh-CN","frontmatter":{"description":"HTTP状态码及其含义 总览 HTTP状态码由三位数字组成，第一位数字定义了响应的类别，后两位没有分类作用。共有5大类： 1xx: 信息性状态码 - 请求已被接收，继续处理。 2xx: 成功状态码 - 请求已成功被服务器接收、理解、并接受。 3xx: 重定向状态码 - 需要客户端采取进一步的操作才能完成请求。 4xx: 客户端错误状态码 - 请求含有语...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"HTTP状态码及其含义\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-10-19T15:34:32.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"yjieyan\\",\\"url\\":\\"https://yjieyan.github.io/knowledge\\"}]}"],["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/knowledge/guide/computer/%E7%BD%91%E7%BB%9C/HTTP%E7%8A%B6%E6%80%81%E7%A0%81%E5%8F%8A%E5%85%B6%E5%90%AB%E4%B9%89.html"}],["meta",{"property":"og:site_name","content":"学习与分享"}],["meta",{"property":"og:title","content":"HTTP状态码及其含义"}],["meta",{"property":"og:description","content":"HTTP状态码及其含义 总览 HTTP状态码由三位数字组成，第一位数字定义了响应的类别，后两位没有分类作用。共有5大类： 1xx: 信息性状态码 - 请求已被接收，继续处理。 2xx: 成功状态码 - 请求已成功被服务器接收、理解、并接受。 3xx: 重定向状态码 - 需要客户端采取进一步的操作才能完成请求。 4xx: 客户端错误状态码 - 请求含有语..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-10-19T15:34:32.000Z"}],["meta",{"property":"article:modified_time","content":"2025-10-19T15:34:32.000Z"}]]},"git":{"createdTime":1760888072000,"updatedTime":1760888072000,"contributors":[{"name":"yjy","username":"yjy","email":"2192242196@qq.com","commits":1,"url":"https://github.com/yjy"}]},"readingTime":{"minutes":8.58,"words":2575},"filePathRelative":"guide/computer/网络/HTTP状态码及其含义.md","autoDesc":true}');export{T as comp,m as data};
