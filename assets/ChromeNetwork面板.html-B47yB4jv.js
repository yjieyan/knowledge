import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,a as r,o as l}from"./app-Bp9_QJkp.js";const n={};function i(s,o){return l(),e("div",null,[...o[0]||(o[0]=[r('<p>Chrome DevTools 的 Network 面板是我们前端工程师进行性能分析和调试的“瑞士军刀”。理解 <code>Timing</code>、<code>Waterfall</code> 和 <code>Initiator</code> 是掌握这把军刀的关键。</p><hr><h3 id="一、-waterfall-瀑布流" tabindex="-1"><a class="header-anchor" href="#一、-waterfall-瀑布流"><span>一、 Waterfall（瀑布流）</span></a></h3><p><strong>Waterfall 是 Network 面板最核心的可视化图表</strong>，它直观地展示了页面中所有资源在<strong>时间轴上的加载顺序和生命周期</strong>。</p><p><strong>如何阅读 Waterfall：</strong><br> 瀑布图中的每一行代表一个资源请求，其长度代表了该资源从发起请求到接收完成的总耗时。图表由多种颜色的横条组成，每种颜色代表请求生命周期中的一个特定阶段。</p><p><strong>核心价值：</strong></p><ol><li><strong>发现性能瓶颈</strong>：一眼就能看出哪个资源加载最慢，阻塞了后续资源。</li><li><strong>理解资源依赖关系</strong>：可以看到资源之间的先后顺序，例如是否有一个 JS 文件的下载阻塞了其他资源的请求。</li><li><strong>分析加载模式</strong>：可以看到请求是并行发起还是串行发起，这有助于判断是否存在 HTTP/1.1 队头阻塞等问题。</li></ol><hr><h3 id="二、-timing-计时详情" tabindex="-1"><a class="header-anchor" href="#二、-timing-计时详情"><span>二、 Timing（计时详情）</span></a></h3><p><strong>Timing 是 Waterfall 图表中每个颜色阶段的精确量化数据</strong>。点击一个资源，在底部面板的 <code>Timing</code> 标签页中，可以看到该资源请求全生命周期的详细耗时分解。</p><p>下面我们来拆解一个 HTTP(S) 请求在 Timing 中的关键阶段：</p><h4 id="_1-请求发起前阶段" tabindex="-1"><a class="header-anchor" href="#_1-请求发起前阶段"><span>1. 请求发起前阶段</span></a></h4><ul><li><strong>Queueing（排队）</strong><ul><li><strong>原因</strong>：请求被浏览器推迟的原因有多种： <ul><li><strong>资源优先级</strong>：浏览器会为不同资源（如 HTML、CSS、JS、图片）分配优先级，低优先级资源可能会被高优先级资源阻塞。</li><li><strong>TCP Socket 不可用</strong>：浏览器对同一域名有 TCP 连接数限制（HTTP/1.1 通常是6个）。超过限制的请求需要排队等待空闲连接。</li><li><strong>渲染阻塞</strong>：在浏览器解析 HTML 到 <code>&lt;body&gt;</code> 标签之前，非关键 CSS/JS 可能会被排队。</li></ul></li></ul></li></ul><h4 id="_2-连接建立阶段-如果是一个新的-tcp-连接" tabindex="-1"><a class="header-anchor" href="#_2-连接建立阶段-如果是一个新的-tcp-连接"><span>2. 连接建立阶段（如果是一个新的 TCP 连接）</span></a></h4><ul><li><strong>Stalled（阻塞）</strong><ul><li>包含了排队和其他任何浏览器内部准备请求的时间（如代理协商、缓存检查）。如果已经建立了连接，这个时间通常很短。</li></ul></li><li><strong>DNS Lookup（DNS 查询）</strong><ul><li>解析域名到 IP 地址的时间。对于新的域名，这是一个完整的查询过程；对于有缓存的域名，可能显示 <code>0ms</code>。</li></ul></li><li><strong>Initial connection（初始连接） / Connecting（连接中）</strong><ul><li>建立 TCP 连接的时间，即 <strong>TCP 三次握手</strong> 的耗时。</li></ul></li><li><strong>SSL（TLS 握手）</strong><ul><li>如果使用 HTTPS，这是完成 <strong>TLS 握手</strong> 的耗时。在 HTTP/1.1 和 HTTP/2 中，这通常需要 1-2 个 RTT。</li></ul></li></ul><h4 id="_3-请求发送与响应阶段" tabindex="-1"><a class="header-anchor" href="#_3-请求发送与响应阶段"><span>3. 请求发送与响应阶段</span></a></h4><ul><li><strong>Request sent（发送请求）</strong><ul><li>发送 HTTP 请求报文（头信息+主体）到网络的时间。通常非常快。</li></ul></li><li><strong>Waiting (TTFB) - 核心指标</strong><ul><li><strong>TTFB（Time to First Byte）</strong>：从发送请求到接收到服务器返回的<strong>第一个字节</strong>的时间。</li><li><strong>组成</strong>：<code>网络延迟（RTT） + 服务器处理时间</code>。</li><li><strong>意义</strong>：TTFB 过高，说明服务器响应慢或网络链路差。是优化的关键指标。</li></ul></li><li><strong>Content Download（内容下载）</strong><ul><li>从接收到第一个字节开始，到下载完整个响应体的时间。</li><li><strong>计算公式</strong>：<code>响应体大小 / 网络带宽</code>。要优化这个时间，要么减小资源体积（压缩、优化），要么提升带宽。</li></ul></li></ul><hr><h3 id="三、-initiator-发起者" tabindex="-1"><a class="header-anchor" href="#三、-initiator-发起者"><span>三、 Initiator（发起者）</span></a></h3><p><strong>Initiator 揭示了请求的“因果关系”</strong>，即 <strong>谁发起了这个网络请求</strong>。这对于理解复杂的应用逻辑和调试不必要的请求至关重要。</p><p><strong>Initiator 列通常显示以下几种类型：</strong></p><ol><li><p><strong>Parser（解析器）</strong></p><ul><li><strong>含义</strong>：请求是由浏览器解析 HTML 文档时发现的。例如：<code>&lt;img&gt;</code>, <code>&lt;script&gt;</code>, <code>&lt;link&gt;</code>, <code>&lt;iframe&gt;</code> 等标签。</li><li><strong>显示</strong>：通常会链接到发现该资源的 HTML 行号。</li><li><strong>示例</strong>：<code>example.com:1</code> 表示这个资源是在 <code>example.com</code> 这个 HTML 文档的第 1 行被发现的。</li></ul></li><li><p><strong>Script（脚本）</strong></p><ul><li><strong>含义</strong>：请求是由 JavaScript 代码发起的。例如：<code>fetch()</code>, <code>XMLHttpRequest</code>, <code>new Image()</code> 等。</li><li><strong>显示</strong>：会链接到发起请求的 JavaScript 文件和具体行号。</li><li><strong>示例</strong>：<code>main.js:125</code> 表示这个请求是由 <code>main.js</code> 文件的第 125 行代码触发的。<strong>点击这个链接可以直接跳转到源码</strong>，是调试的利器。</li></ul></li><li><p><strong>Other（其他）</strong></p><ul><li><strong>含义</strong>：请求是由其他原因触发的，例如： <ul><li>CSS 中的 <code>@font-face</code> 规则引用的字体文件。</li><li>URL 重定向。</li><li><code>navigation</code>：页面导航本身，即对 HTML 文档的请求。</li></ul></li></ul></li></ol><hr><h3 id="实战分析-如何利用这三者进行性能调优" tabindex="-1"><a class="header-anchor" href="#实战分析-如何利用这三者进行性能调优"><span>实战分析：如何利用这三者进行性能调优</span></a></h3><p>假设我们发现页面中有一个 <code>chart.js</code> 文件加载很慢。</p><ol><li><p><strong>看 <code>Waterfall</code></strong>：</p><ul><li>我们发现 <code>chart.js</code> 前面有一个很长的 <code>vendor.js</code> 文件，并且 <code>chart.js</code> 是在 <code>vendor.js</code> 下载完成后才开始的。这暗示了可能的阻塞。</li></ul></li><li><p><strong>看 <code>Initiator</code></strong>：</p><ul><li>我们看到 <code>chart.js</code> 的 Initiator 是 <code>Parser</code>，并且链接到 HTML 的第 20 行。我们检查代码，发现它是一个普通的 <code>&lt;script src=&quot;chart.js&quot;&gt;</code> 标签。</li></ul></li><li><p><strong>看 <code>Timing</code></strong>：</p><ul><li>我们点击 <code>chart.js</code>，查看它的 Timing 详情。我们发现： <ul><li><strong>Queueing</strong> 时间非常长（比如 500ms）。</li><li><strong>Content Download</strong> 时间正常。</li></ul></li><li><strong>结论</strong>：<code>chart.js</code> 加载慢的主要原因不是它自身大小或服务器问题，而是它被<strong>阻塞和排队</strong>了。</li></ul></li><li><p><strong>深入分析与解决</strong>：</p><ul><li>结合 <code>Waterfall</code>，我们推断是因为 <code>vendor.js</code> 这个同步的 <code>&lt;script&gt;</code> 标签阻塞了解析器，导致后面的 <code>chart.js</code> 无法被及时发现和下载。</li><li><strong>解决方案</strong>： <ul><li>给 <code>chart.js</code> 加上 <code>async</code> 或 <code>defer</code> 属性，使其异步加载，不阻塞解析。</li><li>或者，如果 <code>vendor.js</code> 不是渲染所必须的，也可以给它加上 <code>async</code>/<code>defer</code>。</li></ul></li></ul></li></ol><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><ul><li><strong><code>Waterfall</code></strong> 是 <strong>宏观视图</strong>，提供了所有资源加载时序的全局概览，用于快速定位瓶颈。</li><li><strong><code>Timing</code></strong> 是 <strong>微观诊断</strong>，它将一个请求分解为精细的阶段，让我们能精确量化时间消耗在哪个环节（是网络延迟？服务器处理？还是下载？）。</li><li><strong><code>Initiator</code></strong> 是 <strong>因果链分析</strong>，它揭示了请求的来源，帮助我们理解应用的执行逻辑，并追踪到产生请求的源代码。</li></ul><p><strong>三者结合使用，构成了从“发现问题”到“定位根源”再到“量化分析”的完整性能调优工作流。</strong></p>',29)])])}const d=t(n,[["render",i]]),g=JSON.parse('{"path":"/guide/computer/%E7%BD%91%E7%BB%9C/ChromeNetwork%E9%9D%A2%E6%9D%BF.html","title":"","lang":"zh-CN","frontmatter":{"description":"Chrome DevTools 的 Network 面板是我们前端工程师进行性能分析和调试的“瑞士军刀”。理解 Timing、Waterfall 和 Initiator 是掌握这把军刀的关键。 一、 Waterfall（瀑布流） Waterfall 是 Network 面板最核心的可视化图表，它直观地展示了页面中所有资源在时间轴上的加载顺序和生命周期。...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-10-19T15:34:32.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"yjieyan\\",\\"url\\":\\"https://yjieyan.github.io/knowledge\\"}]}"],["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/knowledge/guide/computer/%E7%BD%91%E7%BB%9C/ChromeNetwork%E9%9D%A2%E6%9D%BF.html"}],["meta",{"property":"og:site_name","content":"学习与分享"}],["meta",{"property":"og:description","content":"Chrome DevTools 的 Network 面板是我们前端工程师进行性能分析和调试的“瑞士军刀”。理解 Timing、Waterfall 和 Initiator 是掌握这把军刀的关键。 一、 Waterfall（瀑布流） Waterfall 是 Network 面板最核心的可视化图表，它直观地展示了页面中所有资源在时间轴上的加载顺序和生命周期。..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-10-19T15:34:32.000Z"}],["meta",{"property":"article:modified_time","content":"2025-10-19T15:34:32.000Z"}]]},"git":{"createdTime":1760716761000,"updatedTime":1760888072000,"contributors":[{"name":"yjy","username":"yjy","email":"2192242196@qq.com","commits":3,"url":"https://github.com/yjy"}]},"readingTime":{"minutes":5.3,"words":1590},"filePathRelative":"guide/computer/网络/ChromeNetwork面板.md","autoDesc":true}');export{d as comp,g as data};
