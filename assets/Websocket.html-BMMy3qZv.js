import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,a,o as t}from"./app-DMoYDUrc.js";const e={};function l(h,s){return t(),n("div",null,[...s[0]||(s[0]=[a(`<h1 id="websocket" tabindex="-1"><a class="header-anchor" href="#websocket"><span>Websocket</span></a></h1><hr><h3 id="_1-核心定义与要解决的问题" tabindex="-1"><a class="header-anchor" href="#_1-核心定义与要解决的问题"><span>1. 核心定义与要解决的问题</span></a></h3><p><strong>WebSocket</strong> 是一种在单个TCP连接上进行<strong>全双工通信</strong>的网络协议。</p><p><strong>它要解决的核心问题是HTTP协议在实时性方面的不足：</strong></p><ol><li><strong>半双工与请求-响应模型：</strong> HTTP是半双工的，并且遵循严格的请求-响应模式。客户端必须主动发起请求，服务器才能返回响应。服务器无法主动向客户端“推送”数据。</li><li><strong>头部冗余与高开销：</strong> 每个HTTP请求和响应都携带完整的头部信息（如Cookie、User-Agent等），对于频繁的实时通信，这些冗余数据会带来巨大的带宽和性能开销。</li><li><strong>实时性差：</strong> 为了实现“服务器推送”的假象，前端只能使用低效的<strong>轮询</strong> 或 <strong>长轮询</strong>。 <ul><li><strong>轮询：</strong> 客户端定时向服务器发送HTTP请求（例如每秒一次）。这会导致大量无效请求，延迟高，服务器压力大。</li><li><strong>长轮询：</strong> 客户端发送请求，服务器hold住连接，直到有数据更新或超时才返回响应。客户端收到响应后立即再次发起请求。这比短轮询稍好，但每次请求仍然包含完整的HTTP头部，并且连接频繁建立和断开。</li></ul></li></ol><hr><h3 id="_2-websocket-的工作原理-握手与通信" tabindex="-1"><a class="header-anchor" href="#_2-websocket-的工作原理-握手与通信"><span>2. WebSocket 的工作原理：握手与通信</span></a></h3><p>WebSocket连接分为两个阶段：<strong>HTTP握手</strong> 和 <strong>数据传输</strong>。</p><h4 id="阶段一-http握手-opening-handshake" tabindex="-1"><a class="header-anchor" href="#阶段一-http握手-opening-handshake"><span>阶段一：HTTP握手 (Opening Handshake)</span></a></h4><p>WebSocket连接始于一个特殊的HTTP请求，目的是让客户端和服务器协商升级到WebSocket协议。</p><p><strong>客户端请求头（关键字段）：</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>GET /chat HTTP/1.1</span></span>
<span class="line"><span>Host: server.example.com</span></span>
<span class="line"><span>Upgrade: websocket          # 表示客户端希望升级协议</span></span>
<span class="line"><span>Connection: Upgrade         # 表示客户端希望升级连接</span></span>
<span class="line"><span>Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ== # 一个16位的随机Base64编码值，用于安全验证</span></span>
<span class="line"><span>Sec-WebSocket-Version: 13   # WebSocket协议版本（13是当前标准）</span></span>
<span class="line"><span>Origin: http://example.com  # 用于安全校验，防止跨站攻击</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>服务器响应头（成功情况）：</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>HTTP/1.1 101 Switching Protocols</span></span>
<span class="line"><span>Upgrade: websocket          # 同意升级协议</span></span>
<span class="line"><span>Connection: Upgrade         # 同意升级连接</span></span>
<span class="line"><span>Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo= # 对客户端Key计算后的响应值</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong><code>Sec-WebSocket-Accept</code> 的计算过程：</strong><br> 这是为了防止误操作。服务器会取客户端发送的 <code>Sec-WebSocket-Key</code>，加上一个固定的GUID <code>&quot;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&quot;</code>，然后计算其SHA-1哈希值，最后进行Base64编码。</p><p>如果服务器不支持WebSocket，它会返回一个普通的HTTP响应（如200 OK），那么WebSocket连接就建立失败了。</p><p><strong>握手完成后，状态码为101，表示协议切换成功。此时，底层的TCP连接保持不变，但通信协议已经从HTTP完全转变为了WebSocket协议。</strong></p><h4 id="阶段二-数据传输" tabindex="-1"><a class="header-anchor" href="#阶段二-数据传输"><span>阶段二：数据传输</span></a></h4><p>握手成功后，连接不再遵循HTTP协议，而是使用轻量级的WebSocket数据帧进行通信。</p><p><strong>WebSocket数据帧的特点：</strong></p><ul><li><strong>二进制帧结构：</strong> 数据被封装在二进制帧中传输，格式非常精简。</li><li><strong>极低的头部开销：</strong> 每个帧的头部只有2-14字节，与HTTP头部相比可以忽略不计。</li><li><strong>全双工：</strong> 客户端和服务器可以随时、独立地向对方发送消息。</li><li><strong>基于消息：</strong> 可以传输文本数据，也可以直接传输二进制数据（如ArrayBuffer、Blob），无需像HTTP那样进行编码/解码。</li></ul><hr><h3 id="_3-websocket-的特点与优势" tabindex="-1"><a class="header-anchor" href="#_3-websocket-的特点与优势"><span>3. WebSocket 的特点与优势</span></a></h3><table><thead><tr><th style="text-align:left;">特性</th><th style="text-align:left;">描述</th><th style="text-align:left;">优势</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>全双工通信</strong></td><td style="text-align:left;">客户端和服务器可以同时发送和接收数据。</td><td style="text-align:left;">实现真正的实时双向通信。</td></tr><tr><td style="text-align:left;"><strong>低延迟</strong></td><td style="text-align:left;">建立连接后，数据可以立即推送，无需等待客户端请求。</td><td style="text-align:left;">极佳的实时体验。</td></tr><tr><td style="text-align:left;"><strong>低开销</strong></td><td style="text-align:left;">数据传输阶段头部极小，没有HTTP那样的冗余头部。</td><td style="text-align:left;">节省带宽，适合高频、小数据量的场景。</td></tr><tr><td style="text-align:left;"><strong>持久连接</strong></td><td style="text-align:left;">一个连接在整个会话期间保持打开。</td><td style="text-align:left;">避免了HTTP频繁建立/断开连接的开销。</td></tr></tbody></table><hr><h3 id="_4-前端-api-使用示例" tabindex="-1"><a class="header-anchor" href="#_4-前端-api-使用示例"><span>4. 前端 API 使用示例</span></a></h3><p>Web API <code>WebSocket</code> 提供了非常简洁的接口。</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-javascript"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 1. 创建 WebSocket 连接，协议是 ws:// 或 wss:// (加密，相当于HTTPS)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> socket</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> WebSocket</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;wss://echo.websocket.org&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 2. 监听连接打开事件</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">socket</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">onopen</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> function</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">event</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">  console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;Connection established.&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 连接成功后，发送一条消息</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">  socket</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">send</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;Hello Server!&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 3. 监听消息接收事件</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">socket</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">onmessage</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> function</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">event</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">  console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;Message from server:&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">event</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">data</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 数据可能是文本 (event.data) 或二进制数据 (event.data 作为 ArrayBuffer/Blob)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 4. 监听错误事件</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">socket</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">onerror</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> function</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">error</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">  console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">error</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;WebSocket error:&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">error</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 5. 监听连接关闭事件</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">socket</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">onclose</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> function</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">event</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">  console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;Connection closed.&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">event</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">code</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">event</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">reason</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 发送不同类型的消息</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// socket.send(JSON.stringify({ type: &#39;message&#39;, content: &#39;Hello&#39; })); // 发送JSON</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// socket.send(new ArrayBuffer(...)); // 发送二进制数据</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 主动关闭连接</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// socket.close(1000, &quot;Work complete&quot;); // 1000是正常关闭的状态码</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="_5-适用场景" tabindex="-1"><a class="header-anchor" href="#_5-适用场景"><span>5. 适用场景</span></a></h3><p>WebSocket并非用来取代HTTP，而是用于特定的实时性要求高的场景。</p><ul><li><strong>即时通讯：</strong> 聊天应用（微信、钉钉）。</li><li><strong>实时数据流：</strong> 股票行情、实时报价、体育赛事直播。</li><li><strong>多人在线协作：</strong> 在线文档（Google Docs）、多人在线游戏。</li><li><strong>实时通知与推送：</strong> 社交媒体的点赞、评论通知。</li><li><strong>物联网：</strong> 设备状态的实时监控与控制。</li></ul><hr><h3 id="_6-注意事项与局限性" tabindex="-1"><a class="header-anchor" href="#_6-注意事项与局限性"><span>6. 注意事项与局限性</span></a></h3><ol><li><strong>连接保持与心跳：</strong> 由于是持久连接，可能会被中间节点（代理、防火墙）因超时而断开。通常需要实现<strong>心跳机制</strong>（定期发送小数据包/ping/pong）来保活。</li><li><strong>代理兼容性：</strong> 某些旧的代理服务器可能无法正确理解WebSocket的HTTP升级请求，导致连接失败。</li><li><strong>浏览器支持：</strong> 现代浏览器支持良好，但对于老旧浏览器需要降级方案（如回退到长轮询）。</li><li><strong>复杂性：</strong> 相比简单的HTTP API，你需要自己管理连接状态、重连逻辑、消息序列化/反序列化等。通常会使用成熟的库（如 <code>Socket.IO</code>），它提供了自动重连、房间、广播等高级功能，并兼容不支持WebSocket的浏览器。</li><li><strong>可扩展性：</strong> 服务器需要维持大量并发长连接，对服务器的架构设计（如使用集群、Pub/Sub系统）提出了更高要求。</li></ol>`,36)])])}const r=i(e,[["render",l]]),d=JSON.parse('{"path":"/guide/computer/%E7%BD%91%E7%BB%9C/Websocket.html","title":"Websocket","lang":"zh-CN","frontmatter":{"description":"Websocket 1. 核心定义与要解决的问题 WebSocket 是一种在单个TCP连接上进行全双工通信的网络协议。 它要解决的核心问题是HTTP协议在实时性方面的不足： 半双工与请求-响应模型： HTTP是半双工的，并且遵循严格的请求-响应模式。客户端必须主动发起请求，服务器才能返回响应。服务器无法主动向客户端“推送”数据。 头部冗余与高开销： ...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Websocket\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-10-19T15:34:32.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"yjieyan\\",\\"url\\":\\"https://yjieyan.github.io/knowledge\\"}]}"],["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/knowledge/guide/computer/%E7%BD%91%E7%BB%9C/Websocket.html"}],["meta",{"property":"og:site_name","content":"开卷有益"}],["meta",{"property":"og:title","content":"Websocket"}],["meta",{"property":"og:description","content":"Websocket 1. 核心定义与要解决的问题 WebSocket 是一种在单个TCP连接上进行全双工通信的网络协议。 它要解决的核心问题是HTTP协议在实时性方面的不足： 半双工与请求-响应模型： HTTP是半双工的，并且遵循严格的请求-响应模式。客户端必须主动发起请求，服务器才能返回响应。服务器无法主动向客户端“推送”数据。 头部冗余与高开销： ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-10-19T15:34:32.000Z"}],["meta",{"property":"article:modified_time","content":"2025-10-19T15:34:32.000Z"}]]},"git":{"createdTime":1760888072000,"updatedTime":1760888072000,"contributors":[{"name":"yjy","username":"yjy","email":"2192242196@qq.com","commits":1,"url":"https://github.com/yjy"}]},"readingTime":{"minutes":5.27,"words":1580},"filePathRelative":"guide/computer/网络/Websocket.md","autoDesc":true}');export{r as comp,d as data};
