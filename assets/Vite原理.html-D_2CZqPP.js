import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,a as t,o as n}from"./app-DMoYDUrc.js";const o={};function a(r,e){return n(),i("div",null,[...e[0]||(e[0]=[t(`<h1 id="vite-原理" tabindex="-1"><a class="header-anchor" href="#vite-原理"><span>Vite 原理</span></a></h1><hr><h3 id="vite-的核心原理-一种全新的前端开发范式" tabindex="-1"><a class="header-anchor" href="#vite-的核心原理-一种全新的前端开发范式"><span><strong>Vite 的核心原理：一种全新的前端开发范式</strong></span></a></h3><p>Vite 的核心原理可以概括为一句话：<strong>利用浏览器原生 ES 模块（ESM）的能力，将构建工作“按需”进行，从而实现极致的开发服务器启动速度。</strong></p><h4 id="_1-传统打包器-如-webpack-的瓶颈" tabindex="-1"><a class="header-anchor" href="#_1-传统打包器-如-webpack-的瓶颈"><span><strong>1. 传统打包器（如 Webpack）的瓶颈</strong></span></a></h4><p>以 Webpack 为代表的传统工具，其工作模式是“<strong>先打包，后启动服务器</strong>”。</p><ul><li><p><strong>工作流程</strong>：</p><ol><li><strong>依赖收集</strong>：从入口文件（如 <code>main.js</code>）开始，递归地遍历整个项目的 <code>import</code>/<code>require</code> 语句，构建一个完整的依赖图谱。</li><li><strong>打包构建</strong>：将所有模块（无论是你的源代码还是 <code>node_modules</code> 里的依赖）打包、转换（如将 TS 转 JS，JSX 转 JS）、合并成一个或少数几个 <code>bundle.js</code> 文件。</li><li><strong>启动服务器</strong>：启动一个开发服务器，服务于这个打包好的 <code>bundle.js</code>。</li></ol></li><li><p><strong>瓶颈所在</strong>：</p><ul><li><strong>冷启动速度慢</strong>：在项目规模变大、模块数量激增后，第 1 步和第 2 步会变得非常耗时。你每次执行 <code>npm run dev</code> 都可能需要等待几十秒甚至更长时间，才能看到页面。</li><li><strong>HMR 速度慢</strong>：即使只修改了一个小文件，Webpack 也需要重新计算依赖关系，并对受影响的部分进行重新打包。虽然比冷启动快，但在大项目中仍然有明显的延迟。</li></ul></li></ul><h4 id="_2-vite-的革命性思路-按需服务" tabindex="-1"><a class="header-anchor" href="#_2-vite-的革命性思路-按需服务"><span><strong>2. Vite 的革命性思路：按需服务</strong></span></a></h4><p>Vite 彻底颠覆了这个流程。</p><p>它分为两个清晰的阶段：<strong>开发阶段</strong>和<strong>生产构建阶段</strong>。其巧妙之处在于，它针对这两个阶段使用了不同的策略。</p><hr><h3 id="深入原理-开发阶段" tabindex="-1"><a class="header-anchor" href="#深入原理-开发阶段"><span><strong>深入原理：开发阶段</strong></span></a></h3><p>这是 Vite 魔法发生的地方。</p><h4 id="核心思想-native-esm" tabindex="-1"><a class="header-anchor" href="#核心思想-native-esm"><span><strong>核心思想：Native ESM</strong></span></a></h4><p>现代浏览器已经普遍支持了 ES 模块。这意味着你可以直接在 HTML 中写：</p><div class="language-html line-numbers-mode" data-highlighter="shiki" data-ext="html" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-html"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">script</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> type</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;module&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  import</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> { </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">someFunction</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;./my-module.js&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">  someFunction</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">script</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>浏览器会自行解析这个 <code>import</code> 语句，并向服务器发起对 <code>./my-module.js</code> 的请求。</p><p>Vite 正是利用了这一特性。<strong>它的开发服务器根本不会提前打包你的代码！</strong></p><h4 id="工作流程详解" tabindex="-1"><a class="header-anchor" href="#工作流程详解"><span><strong>工作流程详解：</strong></span></a></h4><ol><li><p><strong>启动服务器（瞬间完成）</strong><br> 当你运行 <code>vite</code> 时，它几乎是在瞬间就启动了一个服务器。因为它什么都不用做，不需要构建依赖图谱，也不需要打包。</p></li><li><p><strong>浏览器请求入口文件</strong><br> 你访问 <code>http://localhost:3000</code>，服务器返回 <code>index.html</code>。这个 HTML 中包含了一个类似这样的脚本标签：</p><div class="language-html line-numbers-mode" data-highlighter="shiki" data-ext="html" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-html"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">script</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> type</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;module&quot;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> src</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;/src/main.js&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">script</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p><strong>Vite 的“中间件魔法”与“路径解析”</strong><br> 浏览器看到这个标签，就会向服务器请求 <code>/src/main.js</code>。</p><ul><li><strong>关键点来了</strong>：Vite 的开发服务器在收到这个请求后，并不会直接返回磁盘上的原始文件。它会用一个“中间件”（Middleware）对请求的文件进行<strong>实时转换</strong>。</li><li><strong>转换内容包括</strong>： <ul><li><strong>裸模块路径重写</strong>：这是 Vite 最精妙的设计之一。你的源码中可能写了 <code>import vue from &#39;vue&#39;</code>。这是一个“裸模块”（Bare Module），浏览器无法理解，它只能处理像 <code>&#39;./vue.js&#39;</code> 这样的相对或绝对路径。Vite 的中间件会检测到这种导入，并将其重写为 <strong><code>/@modules/vue.js</code></strong>。这个 <code>/@modules/</code> 是一个 Vite 内部约定的虚拟路径。</li><li><strong>语法转换</strong>：如果请求的是 <code>.ts</code>、<code>.jsx</code>、<code>.vue</code>、<code>.scss</code> 文件，Vite 会调用相应的编译器（如 Esbuild、PostCSS）进行<strong>实时编译</strong>，最终转换成浏览器可以识别的纯 <code>.js</code> 和 <code>.css</code>。</li></ul></li></ul></li><li><p><strong>浏览器处理转换后的代码</strong><br> 浏览器收到转换后的 <code>main.js</code>，发现里面又有新的 <code>import</code> 语句，比如 <code>import App from &#39;./App.vue&#39;</code> 和 <code>import /@modules/vue.js</code>。它会继续向服务器发起这些新的请求。</p></li><li><p><strong>循环往复，按需加载</strong><br> 服务器对每一个新的请求，都重复第 3 步的“拦截 -&gt; 转换 -&gt; 返回”的过程。</p><ul><li>对于 <code>./App.vue</code>，Vite 会调用 <code>vue</code> 编译器，将其拆成 <code>script</code>、<code>template</code>、<code>style</code> 三部分，分别处理后再组合成一个新的 JS 模块。</li><li>对于 <code>/@modules/vue.js</code>，Vite 会去 <code>node_modules</code> 中找到 <code>vue</code> 的实际 ES 模块构建版本，并返回它。</li></ul></li></ol><p><strong>总结开发阶段优势：</strong></p><ul><li><strong>极速启动</strong>：服务器启动时间与项目规模无关，只和你启动一个 HTTP 服务器的速度有关。</li><li><strong>按需编译</strong>：你访问哪个页面，浏览器才请求哪个模块，Vite 才编译哪个模块。完全没有浪费的计算。</li><li><strong>高效的缓存</strong>：被请求过的文件会被浏览器和 Vite 强力缓存。依赖（<code>node_modules</code> 中的内容）通常会被预构建并强缓存，几乎不会再变动。</li></ul><hr><h3 id="深入原理-生产构建阶段" tabindex="-1"><a class="header-anchor" href="#深入原理-生产构建阶段"><span><strong>深入原理：生产构建阶段</strong></span></a></h3><p>你可能会问，开发环境不打包，那生产环境怎么办？</p><p><strong>在生产构建阶段，Vite 会“退化”到使用 Rollup（默认）进行打包。</strong></p><p><strong>为什么？</strong></p><ol><li><strong>性能考量</strong>：浏览器加载大量小文件会产生 HTTP 请求瓶颈，合并文件（Tree-shaking、Code Splitting）对生产环境性能至关重要。</li><li><strong>兼容性</strong>：并非所有浏览器都完美支持 ESM，而且你的代码可能使用了需要被编译到更低版本 JS 的特性。</li></ol><p><strong>Vite 的聪明之处在于：</strong><br> 它将开发环境和生产环境清晰地分开了。开发环境追求<strong>速度</strong>，利用 ESM 和按需编译；生产环境追求<strong>优化</strong>，使用最成熟的打包工具（Rollup）来保证最佳的线上性能。这种“各司其职”的设计，是 Vite 成功的关键。</p><hr><h3 id="核心特性原理解析" tabindex="-1"><a class="header-anchor" href="#核心特性原理解析"><span><strong>核心特性原理解析</strong></span></a></h3><h4 id="_1-依赖预构建-dependency-pre-bundling" tabindex="-1"><a class="header-anchor" href="#_1-依赖预构建-dependency-pre-bundling"><span><strong>1. 依赖预构建（Dependency Pre-bundling）</strong></span></a></h4><p>这是 Vite 开发阶段唯一一个“打包”行为，但它是在后台静默、一次性完成的。</p><ul><li><strong>目的 1：兼容 CommonJS</strong><br> 很多老的 <code>node_modules</code> 包仍然是 CommonJS 格式。浏览器无法直接运行 CJS。预构建会将它们转换成 ESM。</li><li><strong>目的 2：性能优化</strong><br> 一些包（如 <code>lodash-es</code>）由数百个小文件组成。如果直接让浏览器按需加载，会产生数百个 HTTP 请求，导致浏览器卡顿。预构建会将它们打包成一个单一文件，将请求数量从数百个减少到一两个。</li><li><strong>目的 3：缓存优化</strong><br> 预构建后的依赖几乎不会改变，Vite 会设置一个超长的缓存时间（<code>Cache-Control: max-age=31536000,immutable</code>），让浏览器永久缓存它们。</li></ul><p><strong>工具</strong>：Vite 使用 <strong>Esbuild</strong> 进行依赖预构建，因为 Esbuild 用 Go 编写，其打包速度比用 JavaScript 编写的打包器快 10-100 倍。</p><h4 id="_2-热模块替换-hmr" tabindex="-1"><a class="header-anchor" href="#_2-热模块替换-hmr"><span><strong>2. 热模块替换（HMR）</strong></span></a></h4><p>Vite 提供了一套原生 ESM 的 HMR API。</p><ul><li><strong>原理</strong>：当你修改一个文件时，Vite 只需要精确地让这个已修改的模块“失效”，并与其最近的 HMR 边界（通常是 <code>accept</code> 方法）进行交互。由于不需要重建整个依赖图，只需要重新请求这一个文件，HMR 的速度非常快，通常在 50ms 内完成。</li><li><strong>实现</strong>：Vite 通过 WebSocket 在服务器和浏览器之间建立连接。文件变化时，服务器推送一条更新消息，浏览器收到后，动态 <code>import</code> 新的模块代码。</li></ul><hr><h3 id="扩展-与-snowpack-的对比" tabindex="-1"><a class="header-anchor" href="#扩展-与-snowpack-的对比"><span><strong>扩展：与 Snowpack 的对比</strong></span></a></h3><p>Snowpack 是第一个提出“无打包开发”（Unbundled Development）概念的工具。Vite 的理念深受其影响。</p><p><strong>相同点</strong>：都基于 Native ESM，开发阶段都不打包。</p><p><strong>不同点</strong>：</p><ul><li><strong>生产构建</strong>：Snowpack 默认不提供生产构建，需要你手动集成 Webpack/Rollup 等。而 Vite 直接集成了 Rollup，提供了开箱即用的、高度优化的生产构建，体验更统一。</li><li><strong>框架支持</strong>：Vite 对主流框架（尤其是 Vue）的支持是<strong>一等公民</strong>，提供了更深度的集成（如 Vue 文件的解析）。Snowpack 更偏向于通用和可配置。</li><li><strong>生态和社区</strong>：Vite 凭借其优秀的体验和 Vue 的背景，迅速获得了更大的社区和生态。</li></ul><p>可以说，Vite 站在了 Snowpack 的肩膀上，并做出了更完善、更一体化的产品。</p><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span><strong>总结</strong></span></a></h3><p><strong>核心价值</strong>：<br> Vite 通过拥抱现代 Web 标准（ESM），将开发环境的复杂度从“构建时”转移到了“服务器运行时”，用空间（按需编译）换取了时间（极速启动与 HMR），为开发者带来了质的飞跃的开发体验。</p>`,47)])])}const p=s(o,[["render",a]]),h=JSON.parse('{"path":"/guide/source-code/Vite%E5%8E%9F%E7%90%86.html","title":"Vite 原理","lang":"zh-CN","frontmatter":{"description":"Vite 原理 Vite 的核心原理：一种全新的前端开发范式 Vite 的核心原理可以概括为一句话：利用浏览器原生 ES 模块（ESM）的能力，将构建工作“按需”进行，从而实现极致的开发服务器启动速度。 1. 传统打包器（如 Webpack）的瓶颈 以 Webpack 为代表的传统工具，其工作模式是“先打包，后启动服务器”。 工作流程： 依赖收集：从入...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Vite 原理\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-11-06T01:35:29.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"yjieyan\\",\\"url\\":\\"https://yjieyan.github.io/knowledge\\"}]}"],["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/knowledge/guide/source-code/Vite%E5%8E%9F%E7%90%86.html"}],["meta",{"property":"og:site_name","content":"开卷有益"}],["meta",{"property":"og:title","content":"Vite 原理"}],["meta",{"property":"og:description","content":"Vite 原理 Vite 的核心原理：一种全新的前端开发范式 Vite 的核心原理可以概括为一句话：利用浏览器原生 ES 模块（ESM）的能力，将构建工作“按需”进行，从而实现极致的开发服务器启动速度。 1. 传统打包器（如 Webpack）的瓶颈 以 Webpack 为代表的传统工具，其工作模式是“先打包，后启动服务器”。 工作流程： 依赖收集：从入..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-11-06T01:35:29.000Z"}],["meta",{"property":"article:modified_time","content":"2025-11-06T01:35:29.000Z"}]]},"git":{"createdTime":1762392929000,"updatedTime":1762392929000,"contributors":[{"name":"yjieyan","username":"yjieyan","email":"2192242196@qq.com","commits":1,"url":"https://github.com/yjieyan"}]},"readingTime":{"minutes":7,"words":2101},"filePathRelative":"guide/source-code/Vite原理.md","autoDesc":true}');export{p as comp,h as data};
