import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,f as e,o as s}from"./app-cefFWyo2.js";const r={};function l(i,t){return s(),n("div",null,[...t[0]||(t[0]=[e('<p>这是一个非常核心的网络问题，考察对 TCP 可靠性传输机制的理解。流量控制和拥塞控制是 TCP 保证可靠、高效传输的两大基石，它们目标不同，但协同工作。</p><hr><h3 id="核心概念辨析" tabindex="-1"><a class="header-anchor" href="#核心概念辨析"><span>核心概念辨析</span></a></h3><ul><li><p><strong>流量控制 (Flow Control)</strong>：</p><ul><li><strong>目标</strong>：解决 <strong>“发送方” 和 “接收方”</strong> 之间速度不匹配的问题。防止发送方发送得太快，导致接收方的缓冲区溢出。</li><li><strong>视角</strong>：是 <strong>端到端</strong> 的、点对点的问题。</li><li><strong>机制</strong>：<strong>滑动窗口协议</strong>。</li></ul></li><li><p><strong>拥塞控制 (Congestion Control)</strong>：</p><ul><li><strong>目标</strong>：解决 <strong>“发送方” 和 “网络”</strong> 之间承载能力不匹配的问题。防止发送方向网络注入过多数据，导致整个网络路径（如路由器）过载和拥塞。</li><li><strong>视角</strong>：是 <strong>全局性</strong> 的，关乎整个网络的健康。</li><li><strong>机制</strong>：<strong>慢启动、拥塞避免、快重传、快恢复</strong>。</li></ul></li></ul><p>简单比喻：</p><ul><li><strong>流量控制</strong>：就像两个人对话，A（发送方）说太快，B（接收方）脑子（缓冲区）记不住，B 对 A 说：“你慢点说，我跟不上了。”</li><li><strong>拥塞控制</strong>：就像一条高速公路（网络），车（数据包）太多导致堵车。交管局（TCP）要求所有入口控制发车速率，避免大家都堵死。</li></ul><hr><h3 id="一、-流量控制与滑动窗口" tabindex="-1"><a class="header-anchor" href="#一、-流量控制与滑动窗口"><span>一、 流量控制与滑动窗口</span></a></h3><h4 id="_1-核心机制-滑动窗口" tabindex="-1"><a class="header-anchor" href="#_1-核心机制-滑动窗口"><span>1. 核心机制：滑动窗口</span></a></h4><p>TCP 在发送端和接收端各自维护一个 <strong>窗口</strong>，这个窗口定义了在当前情况下，发送方可以一次性发送多少数据而不需要等待确认。</p><ul><li><strong>接收窗口</strong>：由 <strong>接收方</strong> 通过 TCP 首部中的 <code>window</code> 字段告知发送方。它代表了接收方<strong>剩余缓冲区的大小</strong>。这是流量控制的<strong>根本依据</strong>。</li><li><strong>发送窗口</strong>：<strong>发送方</strong> 根据收到的 <code>window</code> 值，结合自身的发送情况，维护的一个窗口。它决定了哪些数据可以立即发送。</li></ul><p><strong>窗口的滑动过程：</strong><br> 发送窗口通常由四个指针界定：</p><ol><li><code>SendBase</code>：已发送且已被确认的最后一个字节的序列号+1。</li><li><code>NextSeqNum</code>：下一个要发送的字节的序列号。</li><li>窗口左边界：<code>SendBase</code></li><li>窗口右边界：<code>SendBase + min(拥塞窗口, 接收窗口)</code> （这里引入了拥塞控制）</li></ol><p>随着确认报文（ACK）的到达，窗口从左向右“滑动”，新的数据可以被发送。</p><h4 id="_2-零窗口与持续计时器" tabindex="-1"><a class="header-anchor" href="#_2-零窗口与持续计时器"><span>2. 零窗口与持续计时器</span></a></h4><p>如果接收方的缓冲区满了，它会通过 ACK 报文告知发送方一个 <strong>窗口大小为 0</strong>。发送方收到后必须停止发送。</p><p>问题：如果之后接收方缓冲区有空闲，发送了新的非零窗口的 ACK，但这个 ACK 丢失了，双方就会陷入死锁。</p><p><strong>解决方案</strong>：<strong>持续计时器</strong>。当发送方收到零窗口通知后，会启动一个持续计时器。计时器超时后，发送方会发送一个 <strong>窗口探测报文</strong>（1 字节的数据），以触发接收方重新告知当前窗口大小。</p><hr><h3 id="二、-拥塞控制" tabindex="-1"><a class="header-anchor" href="#二、-拥塞控制"><span>二、 拥塞控制</span></a></h3><p>TCP 的拥塞控制是一个动态调整发送速率的过程，它通过维护一个 <strong>拥塞窗口</strong> 来实现。发送方的实际可用窗口是：<code>min(接收窗口, 拥塞窗口)</code>。</p><p>拥塞控制包含四个核心算法：</p><h4 id="_1-慢启动" tabindex="-1"><a class="header-anchor" href="#_1-慢启动"><span>1. 慢启动</span></a></h4><ul><li><strong>目的</strong>：在连接刚开始或检测到拥塞后，<strong>试探性地</strong>找到网络的承载能力。</li><li><strong>过程</strong>： <ol><li>初始时，设置拥塞窗口 <code>cwnd = 1 MSS</code>（一个最大报文段长度）。</li><li>每收到一个 <strong>ACK</strong>，<code>cwnd</code> 就 <strong>增加一个 MSS</strong>（即翻倍）。</li><li>结果是 <code>cwnd</code> 呈 <strong>指数级增长</strong>（1, 2, 4, 8...）。</li></ol></li><li><strong>结束条件</strong>： <ul><li>当 <code>cwnd</code> 增长到超过 <strong>慢启动阈值</strong> 时，转为拥塞避免算法。</li><li>发生超时重传（认为网络拥塞严重），则 <code>ssthresh = cwnd / 2</code>，<code>cwnd = 1</code>，重新开始慢启动。</li></ul></li></ul><h4 id="_2-拥塞避免" tabindex="-1"><a class="header-anchor" href="#_2-拥塞避免"><span>2. 拥塞避免</span></a></h4><ul><li><strong>目的</strong>：当拥塞窗口较大时，从激进增长转为线性增长，避免很快再次引发拥塞。</li><li><strong>过程</strong>： <ol><li>当 <code>cwnd &gt;= ssthresh</code> 时，进入拥塞避免。</li><li>每收到一个 <strong>ACK</strong>，<code>cwnd</code> 增加 <code>1/cwnd</code> 个 MSS。</li><li>结果是 <strong>每个 RTT</strong>（往返时间），<code>cwnd</code> 大约 <strong>增加 1 个 MSS</strong>（线性增长）。</li></ol></li></ul><h4 id="_3-快重传" tabindex="-1"><a class="header-anchor" href="#_3-快重传"><span>3. 快重传</span></a></h4><ul><li><strong>目的</strong>：在定时器超时之前，更早地检测到单个报文段的丢失。</li><li><strong>机制</strong>：如果发送方连续收到 <strong>3 个重复的 ACK</strong>（即总共收到 4 个对同一个序号的 ACK），则推断这个序号的报文段已经丢失，<strong>立即重传</strong>该报文，而不必等待重传计时器超时。</li></ul><h4 id="_4-快恢复" tabindex="-1"><a class="header-anchor" href="#_4-快恢复"><span>4. 快恢复</span></a></h4><ul><li><strong>目的</strong>：与快重传配合使用，在发生快重传后，不粗暴地退回到慢启动，而是采用更温和的策略。</li><li><strong>过程</strong>（这是改进后的标准算法）： <ol><li>当收到 3 个重复 ACK 时，执行： <ul><li><code>ssthresh = cwnd / 2</code></li><li><code>cwnd = ssthresh + 3</code> （加 3 是因为有 3 个报文已经离开网络到达了接收方）</li></ul></li><li>之后，进入 <strong>拥塞避免</strong> 阶段（线性增长），而不是慢启动。</li><li>如果重传报文后，依然收到重复 ACK，则 <code>cwnd</code> 线性增加。</li><li>如果收到了新的数据的 ACK，表明重传成功，网络恢复了，则将 <code>cwnd</code> 设为 <code>ssthresh</code>，然后进入拥塞避免。</li></ol></li></ul><p><strong>注意</strong>：在早期的 TCP Tahoe 版本中，快重传后会直接进入慢启动。现代 TCP（如 Reno, NewReno）都采用了快恢复。</p><hr><h3 id="三、-两者关系与协同工作" tabindex="-1"><a class="header-anchor" href="#三、-两者关系与协同工作"><span>三、 两者关系与协同工作</span></a></h3><p>流量控制和拥塞控制共同决定了发送方的实际发送速率。</p><p><strong>最终发送窗口 = min(接收窗口, 拥塞窗口)</strong></p><p>这个公式完美地体现了两者的关系：</p><ul><li><strong>接收窗口</strong> 是 <strong>上游的硬限制</strong>，由接收方的处理能力决定。</li><li><strong>拥塞窗口</strong> 是 <strong>下游的软限制</strong>，由网络的承载能力决定。</li></ul><p>发送方必须同时遵守这两条规则。即使接收方有巨大的缓冲区（接收窗口很大），如果网络发生拥塞（拥塞窗口很小），发送方也必须降低速率。反之，即使网络非常通畅，如果接收方处理不过来，发送方也不能猛发数据。</p><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><table><thead><tr><th style="text-align:left;">特性</th><th style="text-align:left;">流量控制</th><th style="text-align:left;">拥塞控制</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>目标</strong></td><td style="text-align:left;">保护接收方，防止其缓冲区溢出</td><td style="text-align:left;">保护网络，防止全局性拥塞</td></tr><tr><td style="text-align:left;"><strong>控制信号</strong></td><td style="text-align:left;">接收方通告的 <strong>接收窗口</strong></td><td style="text-align:left;">通过 <strong>报文丢失</strong>（超时或3个重复ACK）推断</td></tr><tr><td style="text-align:left;"><strong>核心机制</strong></td><td style="text-align:left;"><strong>滑动窗口协议</strong></td><td style="text-align:left;"><strong>慢启动、拥塞避免、快重传、快恢复</strong></td></tr><tr><td style="text-align:left;"><strong>视角</strong></td><td style="text-align:left;">端到端，<strong>微观</strong></td><td style="text-align:left;">全局性，<strong>宏观</strong></td></tr><tr><td style="text-align:left;"><strong>协同</strong></td><td style="text-align:left;"><code>实际发送窗口 = min(接收窗口, 拥塞窗口)</code></td><td style="text-align:left;"></td></tr></tbody></table><p>理解这两者的区别与联系，是掌握 TCP 可靠传输精髓的关键。它们像汽车的刹车和方向盘，一个控制与前方车辆的距离，一个控制在整个道路上的行驶轨迹，共同保证了行车（数据传输）的安全与高效。</p>',41)])])}const a=o(r,[["render",l]]),c=JSON.parse('{"path":"/guide/computer/%E7%BD%91%E7%BB%9C/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6vs%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6.html","title":"","lang":"zh-CN","frontmatter":{"description":"这是一个非常核心的网络问题，考察对 TCP 可靠性传输机制的理解。流量控制和拥塞控制是 TCP 保证可靠、高效传输的两大基石，它们目标不同，但协同工作。 核心概念辨析 流量控制 (Flow Control)： 目标：解决 “发送方” 和 “接收方” 之间速度不匹配的问题。防止发送方发送得太快，导致接收方的缓冲区溢出。 视角：是 端到端 的、点对点的问题...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-10-18T03:59:38.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"yjieyan\\",\\"url\\":\\"https://yjieyan.github.io/knowledge\\"}]}"],["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/knowledge/guide/computer/%E7%BD%91%E7%BB%9C/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6vs%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6.html"}],["meta",{"property":"og:site_name","content":"博客"}],["meta",{"property":"og:description","content":"这是一个非常核心的网络问题，考察对 TCP 可靠性传输机制的理解。流量控制和拥塞控制是 TCP 保证可靠、高效传输的两大基石，它们目标不同，但协同工作。 核心概念辨析 流量控制 (Flow Control)： 目标：解决 “发送方” 和 “接收方” 之间速度不匹配的问题。防止发送方发送得太快，导致接收方的缓冲区溢出。 视角：是 端到端 的、点对点的问题..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-10-18T03:59:38.000Z"}],["meta",{"property":"article:modified_time","content":"2025-10-18T03:59:38.000Z"}]]},"git":{"createdTime":1760716761000,"updatedTime":1760759978000,"contributors":[{"name":"yjy","username":"yjy","email":"2192242196@qq.com","commits":2,"url":"https://github.com/yjy"}]},"readingTime":{"minutes":5.87,"words":1761},"filePathRelative":"guide/computer/网络/流量控制vs拥塞控制.md","autoDesc":true}');export{a as comp,c as data};
