import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,a as e,o as n}from"./app-C1nt9b-F.js";const a={};function r(l,i){return n(),s("div",null,[...i[0]||(i[0]=[e('<h1 id="uniapp相关问题" tabindex="-1"><a class="header-anchor" href="#uniapp相关问题"><span>UniApp相关问题</span></a></h1><h4 id="uniapp调用支付" tabindex="-1"><a class="header-anchor" href="#uniapp调用支付"><span>uniapp调⽤⽀付</span></a></h4><table><thead><tr><th style="text-align:left;">环节</th><th style="text-align:left;">核心任务</th><th style="text-align:left;">关键点</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>🛠️ 前置配置</strong></td><td style="text-align:left;">获取商户资质、配置AppID等</td><td style="text-align:left;">微信/支付宝商户平台申请；在 <code>manifest.json</code> 中配置 AppID</td></tr><tr><td style="text-align:left;"><strong>⚙️ 服务端工作</strong></td><td style="text-align:left;">创建订单、生成支付参数</td><td style="text-align:left;">调用支付平台API（如微信统一下单）；返回 <code>timeStamp</code>, <code>nonceStr</code>, <code>package</code>, <code>signType</code>, <code>paySign</code> 等参数</td></tr><tr><td style="text-align:left;"><strong>📱 前端调用</strong></td><td style="text-align:left;">调用 <code>uni.requestPayment</code></td><td style="text-align:left;">注意：<strong>所有支付参数应由服务端生成并返回，前端仅负责调用</strong>，严禁硬编码</td></tr><tr><td style="text-align:left;"><strong>✅ 结果处理</strong></td><td style="text-align:left;">验证支付结果、处理业务</td><td style="text-align:left;">依赖服务端异步通知 (<code>notify_url</code>) 进行最终结果确认</td></tr></tbody></table><p><strong>多端适配说明</strong>：</p><ul><li><strong>支付宝小程序</strong>：将 <code>provider</code> 设置为 <code>&#39;alipay&#39;</code>，并且支付参数通常统一放在 <code>orderInfo</code> 字段中（字符串形式）。</li><li><strong>App端</strong>：无论是微信还是支付宝支付，都必须在调用 <code>uni.requestPayment</code> 时通过 <code>provider</code> 参数指定支付提供商 。此外，App端还需要进行额外的SDK配置，例如iOS需要配置Universal Links 。</li></ul><ol><li><strong>参数格式与大小写</strong>：支付参数（如 <code>timeStamp</code>, <code>nonceStr</code>, <code>package</code>）的<strong>键名和大小写必须严格遵循平台要求</strong>，否则会导致签名失败 。</li><li><strong>金额单位</strong>：在传递给服务端和支付平台时，所有金额均以<strong>分</strong>为单位，这是为了避免浮点数运算可能带来的精度问题 。</li><li><strong>签名验证</strong>：签名是支付安全的核心。<strong>签名操作必须放在服务端完成</strong>，绝对不要在前端暴露商户密钥或进行签名计算 。</li><li><strong>支付结果验证</strong>：前端 <code>success</code> 回调仅表示支付界面顺利调起并完成操作，<strong>支付是否成功的最终判断必须依据服务端收到的异步通知</strong> 。</li></ol><h4 id="uni-app跨端原理" tabindex="-1"><a class="header-anchor" href="#uni-app跨端原理"><span>uni-app跨端原理</span></a></h4><p><strong>在统一的Vue.js语法规范下，通过编译时的代码转换和运行时的环境适配，将一套代码巧妙地映射到多个平台</strong></p><table><thead><tr><th style="text-align:left;">核心层面</th><th style="text-align:left;">核心任务</th><th style="text-align:left;">关键实现方式</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>🔤 语法规范统一</strong></td><td style="text-align:left;">统一开发语言与接口</td><td style="text-align:left;">采用Vue.js作为开发规范；封装<strong>跨端组件</strong>与<strong><a href="http://uni.xxx" target="_blank" rel="noopener noreferrer">uni.xxx</a> API</strong>。</td></tr><tr><td style="text-align:left;"><strong>🛠️ 编译时转换</strong></td><td style="text-align:left;">将统一代码转换为各平台特定代码</td><td style="text-align:left;">通过<strong>条件编译</strong>处理平台差异；将Vue组件拆解为各平台所需的文件。</td></tr><tr><td style="text-align:left;"><strong>⚙️ 运行时适配</strong></td><td style="text-align:left;">在不同平台环境中执行与渲染</td><td style="text-align:left;">小程序端使用<strong>小程序版的Vue runtime</strong>；App端通过<strong>Webview渲染或原生(NVUE)渲染</strong>；H5端直接运行于浏览器。</td></tr></tbody></table><ul><li><p>语法规范统一</p><p><strong>Vue.js开发规范</strong>：每个页面都是一个标准的<code>.vue</code>文件，数据绑定与事件处理也完全遵循Vue.js的规范。<br><strong>跨端组件与API</strong>：uni-app提供了一系列内置组件（如<code>&lt;view&gt;</code>, <code>&lt;text&gt;</code>）和以<code>uni.</code>为前缀的API（如<code>uni.request</code>）。这些组件和API在不同平台会被转换为对应平台的原生组件和API，无需关心底层的差异。</p></li><li><p>编译时转换</p><p><strong>核心转换机制</strong>：编译器会将你的Vue组件拆解并转换成目标平台所需的格式。<br><strong>条件编译</strong>：为了解决不同平台间的特色功能或细微差异，uni-app提供了<strong>条件编译</strong>。<br> 通过特殊的注释语法（如<code>#ifdef MP-WEIXIN</code>）实现平台的个性化定制。</p></li><li><p>运行时适配<br><strong>小程序端</strong>：uni-app的Runtime主要是一个小程序版的<strong>Vue runtime</strong>。它将Vue的数据响应式、生命周期、组件系统等映射到小程序的环境中，使得Vue的语法能够在小程序中正确运行。<br><strong>App端</strong>：App端的Runtime相对复杂，提供了两种渲染引擎：</p><ul><li><strong>Webview渲染</strong>：默认的渲染方式，适用于大多数常规页面。它的原理与小程序类似，渲染速度快，且支持完整的Vue语法。</li><li><strong>原生渲染（NVUE）</strong>：对于性能要求极高的场景（如长列表、复杂动画），可以使用NVUE页面。NVUE的编译产物基于Weex引擎，能够直接调用原生组件进行渲染，从而带来接近原生的流畅体验。<br> uni-app支持在同一个项目中混合使用Vue页面和NVUE页面。</li></ul><p><strong>H5端</strong>：H5端的Runtime可以理解为在标准Vue项目的基础上，补充了uni-app的组件库、路由框架和<code>uni</code>对象。它直接运行在浏览器环境中，因此可以使用绝大部分浏览器特性。</p></li><li><p>架构特点与注意事项</p><p><strong>逻辑层与渲染层分离</strong>：在<strong>小程序和App端</strong>，uni-app的架构是逻辑层（JavaScript）与渲染层（视图）分离的。<br> 这种设计的好处是JavaScript运算不会阻塞视图渲染，使得页面动画更加流畅。<br> 但代价是两层之间通信会有一定的损耗，在需要高频交互（如连续滚动、跟手操作）的场景下，可能会感到不跟手。<br> 为此，uni-app提供了<strong>WXS</strong>（微信小程序）和<strong>RenderJS</strong>（App端）等技术，允许在视图层直接执行一些逻辑，以规避通信损耗。<br><strong>数据更新差异</strong>：在<strong>App-vue页面和小程序</strong>中，数据更新是<strong>页面级别</strong>的。<br> 这意味着如果页面中某个局部数据变化，可能会引起整个页面数据的比较和更新。<br> 因此，<strong>将频繁更新的复杂区域封装成组件</strong>是非常重要的优化手段，这样可以实现组件级别的差量更新。<br> 而App-nvue和H5则无此限制。</p></li></ul><h4 id="uni-app分包策略" tabindex="-1"><a class="header-anchor" href="#uni-app分包策略"><span>Uni-app分包策略</span></a></h4><ul><li>背景<br> 微信小程序之所以需要分包，主要是为了解决小程序官方限制了主包体积和总体积大小，整个小程序所有分包大小不能超过20M，单个分包体积不能超过2M。</li><li>核心思路<br> 将代码划分成不同的包，打开⼀个包中的某个 ⻚⾯，才加载这个包的代码。优化⼩程序⾸次启动的下载时间。<br> 主包：默认启动⻚⾯/TabBar(标签)⻚⾯，以及⼀些所有分包需要⽤到的公共资源/JS脚本<br> 分包：根据开发者的配置进⾏划分<br> a. 使⽤ subpackages 进⾏分包路径声明 ，subpackages 配置路径外的⽬录会被打包到主包中<br> b. tabBar ⾥配置的路径必须放在主包⾥<br> c. 不同的分包之间的资源不能相互引⽤，但都可引⽤主包中的资源</li><li>分包的好处 <ul><li>提⾼⾸⻚加载速度</li><li>优化性能</li><li>分包预下载</li></ul></li><li>制定合理的分包策略<br> ⼩程序包拆分为主包和⼦包，其中主包包含了⼩程序的⾸⻚和⼀些常⽤基础功能模块，⽽⼦包则包含了其他功能模块和⻚⾯。<br> 主包在⽤⼾第⼀次打开⼩程序时会被下载和加载，⽽⼦包则根据需要来动态下载和加载。 <ul><li>根据功能模块拆分 ：将⼩程序的功能模块拆分成不同的⼦包。⽐如：tabbar 模块、⽤⼾模块、推送模块等等。</li><li>根据资源引⽤拆分 ：⾃定义组件、JS ⽂件、静态资源仅被⼀个分包使⽤时则把它划为同⼀个分包中，如果是公共的资源被各个分包使⽤，则将其划为主包</li><li>分包预下载配置 ：通过分包预下载机制，在⽤⼾需要时能够快速加载，配置 preloadRule 后，在进⼊⼩程序某个⻚⾯时，由框架⾃动预下载可能需要的分包，提升进⼊后续分包⻚⾯时的启动速度，减少⽤⼾等待时间，提升⽤⼾体验</li></ul></li></ul><h4 id="谈谈你对uni-app的理解" tabindex="-1"><a class="header-anchor" href="#谈谈你对uni-app的理解"><span>谈谈你对uni-app的理解</span></a></h4><p>uni-app是⼀个使⽤Vue.js开发所有前端应⽤的框架，开发者编写⼀套代码，可以发布到IOS、Android、Web（响应式）、以及各种⼩程序、快应⽤等多个平台。<br> uniapp真正做到⼀套代码多端发⾏，⽀持原⽣代码混写和原⽣sdk集成。<br> 运⾏体验更好。<br> 组件、api与微信⼩程序⼀致，兼容 Weex 原⽣渲染。<br> 通⽤技术栈，学习成本更低。<br> Vue的语法，微信⼩程序的api，对于前端开发⼈员来说更容易上⼿。<br> 开放⽣态，组件更丰富。<br> ⽀持通过npm安装第三⽅包；⽀持微信⼩程序⾃定义组件及sdk；<br> 兼容mpvue 组件及项⽬；<br> app端⽀持与原⽣混合编码；</p><ul><li>uni中如何为不同的平台设置不同的代码？<br> 通过条件注释来为不同平台设置不同的代码：<br> 条件注释的作⽤：实现跨端兼容<br> 使⽤⽅法：以 #ifdef 或 #ifndef 加平台代值开头，以 #endif 结尾<br> #ifdef：if defined 如果是xx平台则运⾏代码块 #ifndef：if not defined 如果不是xx平台才运⾏代码块</li></ul><ul><li>H5 H5</li><li>MP-WEIXIN 微信⼩程序</li><li>APP-PLUS app</li><li>MP 所有⼩程序</li></ul><h4 id="uniapp中封装接口请求相较于微信小程序有什么要注意的" tabindex="-1"><a class="header-anchor" href="#uniapp中封装接口请求相较于微信小程序有什么要注意的"><span>uniapp中封装接⼝请求相较于微信⼩程序有什么要注意的</span></a></h4><p>uniapp和微信⼩程序都提供了⽹络请求API（uni.request() 和 wx.request()），但 uniapp 为了实现跨端兼容，需要注意⽹络请求跨域问题，微信⼩程序不⽤考虑多端兼容，也不会出现跨域问题。<br> uniapp中的跨域问题依然可以通过在 vue.config.js 中配置Proxy代理解决；</p><div class="language-json line-numbers-mode" data-highlighter="shiki" data-ext="json" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-json"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">devServer⸺&gt; proxy⸺&gt; changeOrigin: </span><span style="--shiki-light:#0184BC;--shiki-dark:#D19A66;">true</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//是否跨域</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h4 id="uni-app-在非h5端上运行为什么要在架构上分为逻辑层和视图层" tabindex="-1"><a class="header-anchor" href="#uni-app-在非h5端上运行为什么要在架构上分为逻辑层和视图层"><span>uni-app 在⾮h5端上运⾏为什么要在架构上分为逻辑层和视图层？</span></a></h4><ol><li><strong>安全性 🔒</strong><br> 这是<strong>首要原因</strong>。<br> 在传统的Web开发中，JavaScript可以直接操作DOM，这带来了巨大的安全风险（如XSS攻击、恶意跳转、获取敏感信息等）。<br> 小程序/uni-app作为平台，承载了大量第三方应用，必须保证宿主环境（如微信）的安全。通过：</li></ol><ul><li><p><strong>禁止逻辑层直接操作DOM</strong>，从根本上切断了恶意脚本修改页面、盗取用户信息的途径。</p></li><li><p><strong>提供一套可控的API</strong>（如<code>uni.navigateTo</code>, <code>uni.request</code>），所有对系统能力的调用都必须经过官方API的审核和管控。</p><ol start="2"><li><strong>性能与体验 ⚡</strong></li></ol></li><li><p><strong>避免JS执行阻塞渲染</strong>：在复杂Web应用中，大量的JS计算（如数据处理）会阻塞UI线程，导致页面卡顿。<br> 将两者分离到不同的线程，即使逻辑层在进行复杂计算，视图层依然可以保持流畅的滚动和动画。</p></li><li><p><strong>提升页面切换体验</strong>：可以<strong>预先初始化多个Webview作为视图层</strong>。<br> 当切换页面时，实际上是在不同的Webview之间切换，这比单页应用（SPA）的DOM切换要快得多，体验更接近原生App。</p><ol><li><strong>管控与规范性 📋</strong></li></ol></li><li><p><strong>数据驱动视图</strong>：强制开发者使用数据驱动的方式开发（类似于Vue/React的思维方式）。<br> 你只需要关心数据的变更，由框架负责将数据同步到视图层并更新。这使得代码更规范、更易于维护。</p></li><li><p><strong>技术栈统一</strong>：平台可以强制统一开发规范和技术栈，保证了应用的质量和一致性，也降低了开发者的学习成本。</p></li></ul><h4 id="从云端加载插件时-插件版本无法锁定-可能导致项目在不同基座版本中表现不一致" tabindex="-1"><a class="header-anchor" href="#从云端加载插件时-插件版本无法锁定-可能导致项目在不同基座版本中表现不一致"><span>从云端加载插件时，插件版本无法锁定，可能导致项目在不同基座版本中表现不一致</span></a></h4><p>将插件下载到本地并从本地加载。</p><h4 id="scroll-view-的横向滚动在-android-上无效" tabindex="-1"><a class="header-anchor" href="#scroll-view-的横向滚动在-android-上无效"><span>scroll-view 的横向滚动在 Android 上无效</span></a></h4><p>为子元素添加样式 display: inline-block，并为容器添加 white-space: nowrap</p><h4 id="ios-输入框聚焦后底部留白" tabindex="-1"><a class="header-anchor" href="#ios-输入框聚焦后底部留白"><span>iOS 输入框聚焦后底部留白</span></a></h4><p>监听键盘弹出事件并动态调整页面布局</p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-js"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">window</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">visualViewport</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">addEventListener</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;resize&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, (</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">e</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> keyboardHeight</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> window</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">innerHeight</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> -</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> e</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">target</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">height</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> document</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">body</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">style</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">paddingBottom</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> `</span><span style="--shiki-light:#CA1243;--shiki-dark:#C678DD;">${</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">keyboardHeight</span><span style="--shiki-light:#CA1243;--shiki-dark:#C678DD;">}</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">px`</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">});</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="通过-url-传递过多参数时-页面重新编译可能会出现白屏错误" tabindex="-1"><a class="header-anchor" href="#通过-url-传递过多参数时-页面重新编译可能会出现白屏错误"><span>通过 URL 传递过多参数时，页面重新编译可能会出现白屏错误</span></a></h4><p>使用 uni.setStorageSync 存储数据，避免直接通过 URL 传递</p>',31)])])}const d=t(a,[["render",r]]),h=JSON.parse(`{"path":"/guide/%E9%9D%A2%E8%AF%95/2025%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E4%B9%8BUniApp.html","title":"UniApp相关问题","lang":"zh-CN","frontmatter":{"description":"UniApp相关问题 uniapp调⽤⽀付 多端适配说明： 支付宝小程序：将 provider 设置为 'alipay'，并且支付参数通常统一放在 orderInfo 字段中（字符串形式）。 App端：无论是微信还是支付宝支付，都必须在调用 uni.requestPayment 时通过 provider 参数指定支付提供商 。此外，App端还需要进行额...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"UniApp相关问题\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-11-06T01:35:29.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"yjieyan\\",\\"url\\":\\"https://yjieyan.github.io/knowledge\\"}]}"],["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/knowledge/guide/%E9%9D%A2%E8%AF%95/2025%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E4%B9%8BUniApp.html"}],["meta",{"property":"og:site_name","content":"开卷有益"}],["meta",{"property":"og:title","content":"UniApp相关问题"}],["meta",{"property":"og:description","content":"UniApp相关问题 uniapp调⽤⽀付 多端适配说明： 支付宝小程序：将 provider 设置为 'alipay'，并且支付参数通常统一放在 orderInfo 字段中（字符串形式）。 App端：无论是微信还是支付宝支付，都必须在调用 uni.requestPayment 时通过 provider 参数指定支付提供商 。此外，App端还需要进行额..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-11-06T01:35:29.000Z"}],["meta",{"property":"article:modified_time","content":"2025-11-06T01:35:29.000Z"}]]},"git":{"createdTime":1762392929000,"updatedTime":1762392929000,"contributors":[{"name":"yjieyan","username":"yjieyan","email":"2192242196@qq.com","commits":1,"url":"https://github.com/yjieyan"}]},"readingTime":{"minutes":9.68,"words":2903},"filePathRelative":"guide/面试/2025面试题/面试之UniApp.md","autoDesc":true}`);export{d as comp,h as data};
