import{_ as d}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as o,a as n,o as t}from"./app-CkYRVb8S.js";const i={};function s(a,e){return t(),o("div",null,[...e[0]||(e[0]=[n(`<h1 id="vue-的-diff-原理" tabindex="-1"><a class="header-anchor" href="#vue-的-diff-原理"><span>Vue 的 diff 原理</span></a></h1><p>Vue 的 diff 算法，准确来说是 Virtual DOM 的 diff 算法，是 Vue 实现高效视图更新的核心。</p><p>它的核心思想是：<strong>在数据变化后，生成一个新的 VNode 树，然后与旧的 VNode 树进行比较，找出两者之间的差异，然后只将差异部分应用到真实的 DOM 上，从而避免整体重新渲染，提升性能。</strong></p><h3 id="_1-为什么需要-diff-算法" tabindex="-1"><a class="header-anchor" href="#_1-为什么需要-diff-算法"><span>1. 为什么需要 Diff 算法？</span></a></h3><p>直接操作 DOM（例如 <code>innerHTML</code>）的代价是昂贵的。<br> 一个复杂的页面可能对应着成千上万的 DOM 节点，全量更新会导致渲染性能急剧下降。Virtual DOM 是一个轻量的 JavaScript 对象，它描述了真实 DOM 的结构。操作 JS 对象的成本远低于操作 DOM。</p><p>Diff 算法就是连接新旧 Virtual DOM 的桥梁，它负责找出最少的、必要的 DOM 操作，这是一种“用 JS 的计算成本换取 DOM 的操作成本”的策略，而 JS 的计算速度远快于 DOM。</p><h3 id="_2-diff-的-同层比较-策略" tabindex="-1"><a class="header-anchor" href="#_2-diff-的-同层比较-策略"><span>2. Diff 的“同层比较”策略</span></a></h3><p>这是一个非常重要的前提。Vue 的 diff 算法只会对<strong>同一层级</strong>的 VNode 进行比较，而不会跨层级比较。</p><p><strong>为什么？</strong><br> 因为在实际应用中，跨层级的 DOM 移动操作是极少的。<br> 将比较限制在同一层级，可以将时间复杂度从 O(n³) 大幅降低到 O(n)。这是一种在准确性和性能之间做的权衡，牺牲了极少见的跨层级移动场景，换来了大部分场景下的高性能。</p><p><strong>例子：</strong></p><div class="language-html line-numbers-mode" data-highlighter="shiki" data-ext="html" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-html"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">&lt;!-- 旧 VNode --&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">div</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  &lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">p</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;Old Paragraph&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">p</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">div</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">&lt;!-- 新 VNode --&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">div</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  &lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">span</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;New Span&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">span</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">div</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>算法会比较 <code>div</code> 和 <code>div</code>，然后比较 <code>p</code> 和 <code>span</code>。它不会尝试把旧的 <code>p</code> 移动到别的层级下。</p><h3 id="_3-diff-的核心过程-patch-函数" tabindex="-1"><a class="header-anchor" href="#_3-diff-的核心过程-patch-函数"><span>3. Diff 的核心过程：patch 函数</span></a></h3><p>整个比较过程始于 <code>patch</code> 函数。它接收 <code>oldVnode</code> 和 <code>newVnode</code>。</p><ol><li><p><strong>判断是否为相同节点</strong>：<br> 首先会通过 <code>sameVnode</code> 函数判断两个 VNode 是否是“相同的”，判断条件主要是：</p><ul><li><code>key</code> 相同</li><li><code>tag</code>（标签名）相同</li><li><code>isComment</code>（是否为注释节点）相同</li><li><code>data</code> 定义是否相同（包括事件、属性等）</li><li>对于 input 元素，<code>type</code> 必须相同</li></ul></li><li><p><strong>如果不是相同节点</strong>：<br> 直接销毁旧节点，创建新节点并插入。这是一个“暴力”替换。</p></li><li><p><strong>如果是相同节点</strong>：<br> 进入关键的 <code>patchVnode</code> 过程，这里才是精细比较的开始。</p></li></ol><h3 id="_4-patchvnode-精细化比较" tabindex="-1"><a class="header-anchor" href="#_4-patchvnode-精细化比较"><span>4. <code>patchVnode</code>：精细化比较</span></a></h3><p>当确认两个 VNode 是同类节点后，<code>patchVnode</code> 会执行以下逻辑：</p><ol><li><p><strong>如果新旧 VNode 全等（<code>oldVnode === newVnode</code>）</strong>：直接返回，无事可做。</p></li><li><p><strong>更新真实 DOM 节点（elm）的属性</strong>：<br> 比较 <code>newVnode.data</code> 和 <code>oldVnode.data</code> 的差异（如 <code>class</code>, <code>style</code>, <code>attrs</code>, <code>on</code> 事件监听器等），并更新到真实的 DOM 元素上。这是通过一系列的 <code>update</code> 钩子函数完成的。</p></li><li><p><strong>更新子节点</strong>：这是 diff 算法最复杂、最核心的部分。分为几种情况：</p><ul><li><strong>新节点有文本子节点，且与旧节点的文本不同</strong>：<br> 直接使用 <code>setTextContent</code> 更新 DOM 元素的文本内容。无论旧节点原来有什么子节点，都会被文本替换。</li><li><strong>新节点有子节点，而旧节点没有</strong>：<br> 清空旧 DOM 节点的内容，然后批量将新的子节点创建为真实 DOM 并添加进去。</li><li><strong>旧节点有子节点，而新节点没有</strong>：<br> 直接移除旧 DOM 节点下的所有子节点。</li><li><strong>新旧节点都有子节点</strong>：！！！<strong>重点来了</strong>！！！这就是著名的 <code>updateChildren</code> 逻辑。</li></ul></li></ol><h3 id="_5-updatechildren-双端比较算法" tabindex="-1"><a class="header-anchor" href="#_5-updatechildren-双端比较算法"><span>5. <code>updateChildren</code>：双端比较算法</span></a></h3><p>这是 diff 算法的精髓所在。Vue 采用了一种高效的双端比较算法，同时从新旧子节点数组的<strong>头尾</strong>开始进行比对。</p><p>它定义了四个指针：</p><ul><li><code>oldStartIdx</code> / <code>newStartIdx</code>：指向旧/新子节点列表的<strong>头</strong>。</li><li><code>oldEndIdx</code> / <code>newEndIdx</code>：指向旧/新子节点列表的<strong>尾</strong>。</li></ul><p>以及它们对应的 VNode：</p><ul><li><code>oldStartVnode</code> / <code>newStartVnode</code></li><li><code>oldEndVnode</code> / <code>newEndVnode</code></li></ul><p>然后，算法会进入一个循环，在循环中依次进行以下<strong>四种比较</strong>：</p><ol><li><p><strong><code>oldStartVnode</code> vs <code>newStartVnode</code> (头头比较)</strong>：<br> 如果相同，直接 <code>patchVnode</code>，然后 <code>oldStartIdx</code> 和 <code>newStartIdx</code> 都向右移动一位。</p></li><li><p><strong><code>oldEndVnode</code> vs <code>newEndVnode</code> (尾尾比较)</strong>：<br> 如果相同，直接 <code>patchVnode</code>，然后 <code>oldEndIdx</code> 和 <code>newEndIdx</code> 都向左移动一位。</p></li><li><p><strong><code>oldStartVnode</code> vs <code>newEndVnode</code> (头尾比较)</strong>：<br> 如果相同，说明这个旧节点被移到了右边。在 <code>patchVnode</code> 之后，需要将 <code>oldStartVnode</code> 对应的真实 DOM 节点<strong>移动</strong>到 <code>oldEndVnode</code> 对应的节点的<strong>后面</strong>。然后 <code>oldStartIdx</code> 右移，<code>newEndIdx</code> 左移。</p></li><li><p><strong><code>oldEndVnode</code> vs <code>newStartVnode</code> (尾头比较)</strong>：<br> 如果相同，说明这个旧节点被移到了左边。在 <code>patchVnode</code> 之后，需要将 <code>oldEndVnode</code> 对应的真实 DOM 节点<strong>移动</strong>到 <code>oldStartVnode</code> 对应的节点的<strong>前面</strong>。然后 <code>oldEndIdx</code> 左移，<code>newStartIdx</code> 右移。</p></li><li><p><strong>如果以上四种情况都不匹配</strong>：<br> 这是最不理想的情况。Vue 会尝试在<strong>旧的子节点数组</strong>中，寻找一个与 <code>newStartVnode</code> 拥有相同 key 的节点。</p><ul><li><strong>如果找到了</strong>：则将该旧节点拿来与 <code>newStartVnode</code> 进行 <code>patchVnode</code>，并将它对应的真实 DOM 移动到 <code>oldStartVnode</code> 对应的 DOM 之前。同时，将这个旧节点在数组中的位置标记为 <code>undefined</code>（因为此节点已被复用，避免后续重复使用）。</li><li><strong>如果没找到</strong>：说明 <code>newStartVnode</code> 是一个全新的节点，需要创建它对应的真实 DOM 并插入到 <code>oldStartVnode</code> 对应的 DOM 之前。</li></ul></li></ol><p><strong>循环结束条件</strong>：<br> 当 <code>oldStartIdx &gt; oldEndIdx</code> 或 <code>newStartIdx &gt; newEndIdx</code> 时，循环停止。</p><p><strong>循环结束后的处理</strong>：</p><ul><li><strong>如果 <code>oldStartIdx &gt; oldEndIdx</code></strong>：说明旧节点先遍历完了。那么剩下的新节点都是需要<strong>新增</strong>的。将它们批量创建并插入到 <code>newEndIdx</code> 对应的节点之后。</li><li><strong>如果 <code>newStartIdx &gt; newEndIdx</code></strong>：说明新节点先遍历完了。那么 <code>oldStartIdx</code> 到 <code>oldEndIdx</code> 之间的旧节点都是需要<strong>移除</strong>的。将它们批量删除。</li></ul><h3 id="_6-为什么需要-key" tabindex="-1"><a class="header-anchor" href="#_6-为什么需要-key"><span>6. 为什么需要 <code>key</code>？</span></a></h3><p>从 <code>updateChildren</code> 的第五步可以看出，<code>key</code> 的作用至关重要。它是一个节点的唯一标识。</p><ul><li><strong>有 key</strong>：在双端比较都不匹配时，Vue 可以凭借 key 快速地在旧节点映射表中找到可复用的节点。这样可以最大程度地避免不必要的 DOM 创建/销毁，直接移动节点即可，极大地提升了性能。<strong>在列表渲染中，key 是必须的</strong>。</li><li><strong>无 key</strong>：如果节点没有 key，Vue 只能认为“相同索引位置”的节点是同一个节点。这在列表顺序发生变化时（如排序、插入），会导致大量的节点被错误地复用，从而引发状态错乱和性能低下（因为可能创建了本可复用的新节点）。</li></ul><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3>`,33)])])}const r=d(i,[["render",s]]),p=JSON.parse('{"path":"/guide/source-code/VueDiff%E5%8E%9F%E7%90%86.html","title":"Vue 的 diff 原理","lang":"zh-CN","frontmatter":{"description":"Vue 的 diff 原理 Vue 的 diff 算法，准确来说是 Virtual DOM 的 diff 算法，是 Vue 实现高效视图更新的核心。 它的核心思想是：在数据变化后，生成一个新的 VNode 树，然后与旧的 VNode 树进行比较，找出两者之间的差异，然后只将差异部分应用到真实的 DOM 上，从而避免整体重新渲染，提升性能。 1. 为什么...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Vue 的 diff 原理\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-10-19T15:34:32.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"yjieyan\\",\\"url\\":\\"https://yjieyan.github.io/knowledge\\"}]}"],["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/knowledge/guide/source-code/VueDiff%E5%8E%9F%E7%90%86.html"}],["meta",{"property":"og:site_name","content":"开卷有益"}],["meta",{"property":"og:title","content":"Vue 的 diff 原理"}],["meta",{"property":"og:description","content":"Vue 的 diff 原理 Vue 的 diff 算法，准确来说是 Virtual DOM 的 diff 算法，是 Vue 实现高效视图更新的核心。 它的核心思想是：在数据变化后，生成一个新的 VNode 树，然后与旧的 VNode 树进行比较，找出两者之间的差异，然后只将差异部分应用到真实的 DOM 上，从而避免整体重新渲染，提升性能。 1. 为什么..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-10-19T15:34:32.000Z"}],["meta",{"property":"article:modified_time","content":"2025-10-19T15:34:32.000Z"}]]},"git":{"createdTime":1760888072000,"updatedTime":1760888072000,"contributors":[{"name":"yjy","username":"yjy","email":"2192242196@qq.com","commits":1,"url":"https://github.com/yjy"}]},"readingTime":{"minutes":5.6,"words":1681},"filePathRelative":"guide/source-code/VueDiff原理.md","autoDesc":true}');export{r as comp,p as data};
