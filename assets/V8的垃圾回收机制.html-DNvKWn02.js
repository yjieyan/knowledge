import{_ as r}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as o,f as n,o as s}from"./app-C49dgTjO.js";const g={};function e(i,t){return s(),o("div",null,[...t[0]||(t[0]=[n('<h1 id="v8的垃圾回收机制" tabindex="-1"><a class="header-anchor" href="#v8的垃圾回收机制"><span>V8的垃圾回收机制</span></a></h1><ol><li><strong>垃圾回收的必要性</strong></li><li><strong>V8 内存分代假说</strong></li><li><strong>新生代与 Scavenger 算法</strong></li><li><strong>老生代与主垃圾回收器</strong></li><li><strong>Orinoco：并发与并行垃圾回收</strong></li><li><strong>总结与关键优化</strong></li></ol><hr><h3 id="_1-垃圾回收的必要性" tabindex="-1"><a class="header-anchor" href="#_1-垃圾回收的必要性"><span>1. 垃圾回收的必要性</span></a></h3><p>JavaScript 是一种垃圾回收语言。开发者不需要手动分配和释放内存，V8 引擎会自动管理内存生命周期。其核心任务是：</p><ul><li><strong>分配内存</strong>：当创建对象、字符串等时。</li><li><strong>识别垃圾</strong>：找到那些不再被程序使用的对象。</li><li><strong>释放内存</strong>：回收垃圾对象所占用的内存，以便再次分配。</li></ul><p>手动管理内存（如 C++）容易导致内存泄漏或野指针问题，而自动垃圾回收则解决了这个痛点。</p><hr><h3 id="_2-v8-内存分代假说" tabindex="-1"><a class="header-anchor" href="#_2-v8-内存分代假说"><span>2. V8 内存分代假说</span></a></h3><p>V8 垃圾回收策略的核心基于一个观察到的<strong>强分代假说</strong>：</p><blockquote><p><strong>绝大多数对象的生命周期都很短，通常一经创建很快就变得不可达；而那些存活时间足够长的对象，往往还能活得更久。</strong></p></blockquote><p>基于这个假说，V8 将堆内存划分为两个主要区域：<strong>新生代</strong> 和 <strong>老生代</strong>。</p><ul><li><strong>新生代</strong>：存放<strong>生存时间短</strong>的对象。通常只支持 <strong>1-8 MB</strong> 的容量。垃圾回收在此发生得非常频繁，速度也很快。</li><li><strong>老生代</strong>：存放<strong>生存时间长</strong>的对象或从新生代<strong>晋升</strong>过来的对象。容量远大于新生代。垃圾回收在此发生得较少，但耗时更长。</li></ul><p>这种分代设计允许 V8 对不同类型的对象采用不同的、最优的回收策略。</p><hr><h3 id="_3-新生代与-scavenger-算法" tabindex="-1"><a class="header-anchor" href="#_3-新生代与-scavenger-算法"><span>3. 新生代与 Scavenger 算法</span></a></h3><p>新生代使用一种叫做 <strong>Scavenge</strong> 的算法，具体实现是 <strong>Cheney 算法</strong>。它的核心是 <strong>“复制”</strong>。</p><h4 id="新生代的结构" tabindex="-1"><a class="header-anchor" href="#新生代的结构"><span><strong>新生代的结构</strong></span></a></h4><p>新生代被划分为两个相等的<strong>半空间</strong>：</p><ul><li><strong>From-Space（对象区）</strong>：新对象首先在这里被分配。</li><li><strong>To-Space（空闲区）</strong>：在垃圾回收时扮演备份区的角色。</li></ul><h4 id="scavenge-过程" tabindex="-1"><a class="header-anchor" href="#scavenge-过程"><span><strong>Scavenge 过程</strong></span></a></h4><ol><li><strong>分配</strong>：所有新对象都在 <strong>From-Space</strong> 进行分配。</li><li><strong>标记与复制</strong>：当 <strong>From-Space</strong> 快被填满时，会触发一次 <strong>Minor GC</strong>。 <ul><li>V8 会遍历 <strong>From-Space</strong> 中的对象，<strong>标记</strong>出仍然存活的对象。</li><li>将这些<strong>存活的对象</strong>复制到 <strong>To-Space</strong> 中。在复制过程中，它们会被紧凑地排列在一起，消除了内存碎片。</li><li>同时，V8 会更新所有指向这些被移动对象的指针。</li></ul></li><li><strong>角色翻转</strong>：复制完成后，<strong>To-Space</strong> 变成新的 <strong>From-Space</strong>，而原来的 <strong>From-Space</strong> 变成新的 <strong>To-Space</strong>（此时已被清空）。</li><li><strong>晋升</strong>：如果一个对象在新生代中经历过一次 GC 后仍然存活，或者 <strong>To-Space</strong> 已经被使用了 25%（为了避免过早翻转），它就会被<strong>晋升</strong>到老生代中。</li></ol><p><strong>优点</strong>：速度极快，因为它只处理存活的对象，而不关心死亡对象。<br><strong>缺点</strong>：只能使用一半的堆空间，存在空间上的浪费。</p><hr><h3 id="_4-老生代与主垃圾回收器" tabindex="-1"><a class="header-anchor" href="#_4-老生代与主垃圾回收器"><span>4. 老生代与主垃圾回收器</span></a></h3><p>老生代中存放的对象更复杂、更大，且存活率高，因此不适合使用 Scavenge 算法（复制成本太高）。老生代使用 <strong>“标记-清除-整理”</strong> 算法。</p><h4 id="回收过程分为三个阶段" tabindex="-1"><a class="header-anchor" href="#回收过程分为三个阶段"><span><strong>回收过程分为三个阶段</strong>：</span></a></h4><ol><li><p><strong>标记（Marking）</strong></p><ul><li>V8 从一组<strong>根对象</strong>开始遍历（如全局对象、当前函数作用域链、激活的上下文等）。</li><li>从根对象出发，递归地遍历所有能访问到的对象，并将它们<strong>标记为活动对象</strong>。无法从根对象访问到的对象即为<strong>垃圾</strong>。</li><li><strong>三色标记法</strong>：为了高效管理标记状态，V8 使用白（未访问）、灰（已访问但子节点未访问）、黑（已访问且子节点也已访问）三种颜色来标记对象。</li></ul></li><li><p><strong>清除（Sweeping）</strong></p><ul><li>标记阶段完成后，V8 会遍历整个老生代内存。</li><li>将所有未被标记为活动对象的内存区域添加到<strong>空闲内存列表</strong>中。这些区域现在可以被重新分配。</li><li><strong>注意</strong>：清除阶段只是将垃圾内存记录起来，并没有立即移动对象，因此会产生<strong>内存碎片</strong>。</li></ul></li><li><p><strong>整理（Compaction）</strong></p><ul><li>为了解决内存碎片问题，V8 在必要时会执行<strong>内存整理</strong>。</li><li>它将所有存活的对象<strong>移动</strong>到一起，紧密地排列在内存的一端。</li><li>这个过程会<strong>消除内存碎片</strong>，使得大块的连续内存分配成为可能，但代价是更长的停顿时间。</li></ul></li></ol><hr><h3 id="_5-orinoco-并发与并行垃圾回收" tabindex="-1"><a class="header-anchor" href="#_5-orinoco-并发与并行垃圾回收"><span>5. Orinoco：并发与并行垃圾回收</span></a></h3><p>传统的垃圾回收会 <strong>“停止世界”（Stop-The-World）</strong>，即暂停 JavaScript 的执行，直到 GC 完成。这会导致页面卡顿、应用无响应。</p><p>现代的 V8（项目代号 <strong>Orinoco</strong>）致力于通过 <strong>并行、增量、并发</strong> 技术来减少主线程的停顿时间。</p><ul><li><strong>并行</strong>：GC 任务在主线程和几个辅助线程上<strong>同时进行</strong>，但此时 JavaScript 执行仍然是暂停的。这缩短了总的停顿时间。</li><li><strong>增量</strong>：GC 任务被<strong>分解成一系列小任务</strong>，与 JavaScript 执行<strong>交替进行</strong>。而不是一次性完成一个完整的 GC。这样每次停顿的时间很短，用户几乎感知不到。</li><li><strong>并发</strong>：GC 任务在<strong>辅助线程上完全并发地执行</strong>，<strong>完全不需要停止 JavaScript 的执行</strong>。这是最理想的方式，但实现也最复杂，因为它需要处理 JavaScript 在执行时同时修改对象图的复杂情况。</li></ul><p><strong>具体应用：</strong></p><ul><li><strong>新生代 GC</strong>：通常是<strong>并行</strong>的。</li><li><strong>老生代标记</strong>：现在是<strong>并发</strong>的。标记工作主要在后台线程进行，只有很小的停顿。</li><li><strong>老生代整理</strong>：通常是<strong>并行</strong>的。</li></ul><hr><h3 id="_6-总结与关键优化" tabindex="-1"><a class="header-anchor" href="#_6-总结与关键优化"><span>6. 总结与关键优化</span></a></h3><ol><li><strong>分而治之</strong>：基于<strong>分代假说</strong>，将堆分为新生代和老生代，对不同生命周期的对象采用最优算法。</li><li><strong>空间换时间</strong>：新生代的 <strong>Scavenge</strong> 算法用一半的空间换来了极快的回收速度。</li><li><strong>权衡取舍</strong>：老生代的 <strong>标记-清除-整理</strong> 算法在速度、空间和碎片化之间取得平衡。</li><li><strong>用户体验优先</strong>：通过 <strong>并行、增量、并发</strong> 技术，最大限度地减少垃圾回收对应用程序执行的阻塞，保证页面的流畅性。</li></ol><p>虽然 V8 的 GC 非常智能，但不当的代码仍会使其低效：</p><ul><li><strong>避免全局变量</strong>：它们永远是根对象，永远不会被回收。</li><li><strong>及时解除引用</strong>：对于不再使用的大对象（如缓存、DOM 元素引用），手动设置为 <code>null</code>。</li><li><strong>避免内存泄漏</strong>：注意闭包、被遗忘的定时器和回调函数、分离的 DOM 节点等。</li></ul><p>V8 的垃圾回收是一个在<strong>空间、时间、停顿</strong>之间不断权衡和优化的复杂系统。</p><h2 id="查看-v8-的内存使用情况" tabindex="-1"><a class="header-anchor" href="#查看-v8-的内存使用情况"><span>查看 V8 的内存使用情况</span></a></h2>',42)])])}const p=r(g,[["render",e]]),c=JSON.parse('{"path":"/guide/%E6%B5%8F%E8%A7%88%E5%99%A8_%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8/V8%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.html","title":"V8的垃圾回收机制","lang":"zh-CN","frontmatter":{"description":"V8的垃圾回收机制 垃圾回收的必要性 V8 内存分代假说 新生代与 Scavenger 算法 老生代与主垃圾回收器 Orinoco：并发与并行垃圾回收 总结与关键优化 1. 垃圾回收的必要性 JavaScript 是一种垃圾回收语言。开发者不需要手动分配和释放内存，V8 引擎会自动管理内存生命周期。其核心任务是： 分配内存：当创建对象、字符串等时。 识...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"V8的垃圾回收机制\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-10-19T15:34:32.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"yjieyan\\",\\"url\\":\\"https://yjieyan.github.io/knowledge\\"}]}"],["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/knowledge/guide/%E6%B5%8F%E8%A7%88%E5%99%A8_%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8/V8%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.html"}],["meta",{"property":"og:site_name","content":"学习与分享"}],["meta",{"property":"og:title","content":"V8的垃圾回收机制"}],["meta",{"property":"og:description","content":"V8的垃圾回收机制 垃圾回收的必要性 V8 内存分代假说 新生代与 Scavenger 算法 老生代与主垃圾回收器 Orinoco：并发与并行垃圾回收 总结与关键优化 1. 垃圾回收的必要性 JavaScript 是一种垃圾回收语言。开发者不需要手动分配和释放内存，V8 引擎会自动管理内存生命周期。其核心任务是： 分配内存：当创建对象、字符串等时。 识..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-10-19T15:34:32.000Z"}],["meta",{"property":"article:modified_time","content":"2025-10-19T15:34:32.000Z"}]]},"git":{"createdTime":1760888072000,"updatedTime":1760888072000,"contributors":[{"name":"yjy","username":"yjy","email":"2192242196@qq.com","commits":1,"url":"https://github.com/yjy"}]},"readingTime":{"minutes":5.91,"words":1773},"filePathRelative":"guide/浏览器&服务器/服务器/V8的垃圾回收机制.md","autoDesc":true}');export{p as comp,c as data};
