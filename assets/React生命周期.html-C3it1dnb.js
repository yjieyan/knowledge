import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,a as n,o as a}from"./app-CkYRVb8S.js";const e="/knowledge/assets/react1-CiRPGK29.png",l={};function o(p,s){return a(),t("div",null,[...s[0]||(s[0]=[n('<h1 id="react生命周期" tabindex="-1"><a class="header-anchor" href="#react生命周期"><span>React生命周期</span></a></h1><ol><li><strong>传统类组件（Class Component）的生命周期</strong></li><li><strong>现代函数组件（Function Component）与 Hooks 的“生命周期”思维</strong></li></ol><hr><h3 id="第一部分-传统类组件-class-component-的生命周期" tabindex="-1"><a class="header-anchor" href="#第一部分-传统类组件-class-component-的生命周期"><span>第一部分：传统类组件（Class Component）的生命周期</span></a></h3><p>类组件的生命周期方法可以被划分为三个主要阶段：<strong>挂载（Mounting）</strong>、<strong>更新（Updating）</strong> 和 <strong>卸载（Unmounting）</strong>。<br><img src="'+e+`" alt="" loading="lazy"></p><h4 id="阶段一-挂载-mounting-组件被创建并插入-dom" tabindex="-1"><a class="header-anchor" href="#阶段一-挂载-mounting-组件被创建并插入-dom"><span>阶段一：挂载（Mounting） - 组件被创建并插入 DOM</span></a></h4><p>当组件实例被创建并插入 DOM 时，其生命周期调用顺序如下：</p><ol><li><p><strong><code>constructor(props)</code></strong></p><ul><li><strong>目的</strong>：初始化状态 (<code>this.state</code>)、绑定事件处理方法的 <code>this</code>。</li><li><strong>注意</strong>：在 <code>constructor()</code> 中，你必须首先调用 <code>super(props)</code>，否则 <code>this.props</code> 在构造函数中可能会出现未定义的 bug。</li><li><strong>避免副作用</strong>：不要在这里执行 <code>setState</code> 或进行 AJAX 调用。</li></ul></li><li><p><strong><code>static getDerivedStateFromProps(props, state)</code></strong> (不常用，React 16.3+)</p><ul><li><strong>目的</strong>：在 <strong>render 之前</strong>被调用，它应该返回一个对象来更新 state，如果返回 <code>null</code> 则不更新任何内容。</li><li><strong>使用场景</strong>：极其罕见，用于 state 在任何时候都取决于 props 的情况。</li></ul></li><li><p><strong><code>render()</code></strong></p><ul><li><strong>目的</strong>：这是类组件中<strong>唯一必须实现的方法</strong>。它通过返回 JSX 来描述 UI。</li><li><strong>纯函数</strong>：它应该是纯函数，不修改组件状态，不直接与浏览器交互。</li><li><strong>返回类型</strong>：可以返回 JSX、数组、Fragments、Portals、字符串、数字、布尔值或 <code>null</code>。</li></ul></li><li><p><strong><code>componentDidMount()</code></strong></p><ul><li><strong>目的</strong>：组件已经被<strong>挂载</strong>（插入 DOM 树中）后立即调用。</li><li><strong>执行副作用的最佳位置</strong>： <ul><li><strong>AJAX 请求</strong>：从服务器加载数据。</li><li><strong>DOM 操作</strong>：如果需要直接操作 DOM 元素。</li><li><strong>建立订阅</strong>：例如设置定时器、WebSocket 连接等。</li></ul></li><li><strong>可以调用 <code>setState</code></strong>：但会触发一次额外的渲染，不过此渲染会发生在浏览器更新屏幕之前，用户不会看到中间状态。</li></ul></li></ol><h4 id="阶段二-更新-updating-组件重新渲染" tabindex="-1"><a class="header-anchor" href="#阶段二-更新-updating-组件重新渲染"><span>阶段二：更新（Updating） - 组件重新渲染</span></a></h4><p>当组件的 props 或 state 发生变化时，会触发更新。调用顺序如下：</p><ol><li><p><strong><code>static getDerivedStateFromProps(props, state)</code></strong> (不常用)</p><ul><li>同上，在更新阶段也会调用。</li></ul></li><li><p><strong><code>shouldComponentUpdate(nextProps, nextState)</code></strong></p><ul><li><strong>目的</strong>：让 React 知道组件的输出是否受当前 state 或 props 变化的影响。默认行为是每次 state 变化都重新渲染。</li><li><strong>性能优化</strong>：通过对比 <code>this.props</code> 与 <code>nextProps</code> 以及 <code>this.state</code> 与 <code>nextState</code>，返回 <code>false</code> 来告知 React 可以跳过本次渲染。</li><li><strong>注意</strong>：不要在此方法中执行副作用，不建议进行深层比较，可能会影响性能。通常使用 <code>React.PureComponent</code> 替代手动实现。</li></ul></li><li><p><strong><code>render()</code></strong></p><ul><li>同上，根据新的 state 和 props 重新渲染。</li></ul></li><li><p><strong><code>getSnapshotBeforeUpdate(prevProps, prevState)</code></strong> (不常用，React 16.3+)</p><ul><li><strong>目的</strong>：在最近一次渲染输出（提交）到 DOM <strong>之前</strong>被调用。它使得组件能在 DOM 发生变化前从 DOM 中捕获一些信息（例如滚动位置）。</li><li><strong>返回值</strong>：此生命周期的任何返回值将作为参数传递给 <code>componentDidUpdate()</code>。</li></ul></li><li><p><strong><code>componentDidUpdate(prevProps, prevState, snapshot)</code></strong></p><ul><li><strong>目的</strong>：在更新完成后被立即调用。首次渲染不会执行此方法。</li><li><strong>执行副作用的常见位置</strong>：但需要<strong>比较当前 props 与上一次 props</strong>，以避免不必要的网络请求。</li><li><strong>可以调用 <code>setState</code></strong>：但必须被条件语句包裹，否则会导致无限循环。</li></ul></li></ol><h4 id="阶段三-卸载-unmounting-组件从-dom-中移除" tabindex="-1"><a class="header-anchor" href="#阶段三-卸载-unmounting-组件从-dom-中移除"><span>阶段三：卸载（Unmounting） - 组件从 DOM 中移除</span></a></h4><p>当组件从 DOM 中移除时会调用：</p><ol><li><strong><code>componentWillUnmount()</code></strong><ul><li><strong>目的</strong>：在组件卸载及销毁之前直接调用。</li><li><strong>执行必要的清理操作</strong>： <ul><li>清除定时器。</li><li>取消网络请求。</li><li>清理在 <code>componentDidMount()</code> 中创建的订阅。</li></ul></li></ul></li></ol><hr><h3 id="第二部分-现代函数组件与-hooks-的-生命周期-思维" tabindex="-1"><a class="header-anchor" href="#第二部分-现代函数组件与-hooks-的-生命周期-思维"><span>第二部分：现代函数组件与 Hooks 的“生命周期”思维</span></a></h3><p>在函数组件中，我们使用 <strong>Hooks</strong> 来模拟类组件的生命周期行为。<strong>函数组件没有生命周期方法</strong>，但我们可以通过 Hooks 在相应的时机执行代码。</p><h4 id="心智模型的转变-从-生命周期-到-副作用同步" tabindex="-1"><a class="header-anchor" href="#心智模型的转变-从-生命周期-到-副作用同步"><span>心智模型的转变：从“生命周期”到“副作用同步”</span></a></h4><p>Hooks 的核心思想是<strong>将组件渲染与副作用同步</strong>，而不是依赖于特定的生命周期时间点。</p><p><strong><code>useEffect</code> Hook：全能选手</strong></p><p><code>useEffect</code> 几乎可以覆盖所有生命周期场景。它的执行时机是<strong>在浏览器完成布局与绘制之后</strong>。</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-javascript"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">import</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> { </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">useState</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">useEffect</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;react&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">function</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> MyComponent</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  const</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> [</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;">data</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;">setData</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">] </span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> useState</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">null</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 1. 模拟 componentDidMount (挂载后)</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 依赖数组为空，表示不依赖于任何值，只在挂载后执行一次</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">  useEffect</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">    console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;组件挂载完成！&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    fetchData</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">().</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">then</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">setData</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 发起数据请求</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  }, []); </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// &lt;- 空依赖数组</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 2. 模拟 componentDidUpdate (更新后)</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 没有依赖数组，表示每次渲染后都执行（谨慎使用！）</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">  useEffect</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">    console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;每次渲染后都会执行&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  }); </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// &lt;- 没有依赖数组</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 更常见的“更新后”逻辑：在特定 state 或 prop 变化后执行</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">  useEffect</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">    console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;count 发生了变化，执行某些操作&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">    document</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">title</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> \`You clicked </span><span style="--shiki-light:#CA1243;--shiki-dark:#C678DD;">\${</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">count</span><span style="--shiki-light:#CA1243;--shiki-dark:#C678DD;">}</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> times\`</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  }, [</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">count</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">]); </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// &lt;- 依赖数组包含 count</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 3. 模拟 componentWillUnmount (卸载前)</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 通过返回一个清理函数来实现</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">  useEffect</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> timer</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> setInterval</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">      // 做一些事情</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1000</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 返回的清理函数会在组件卸载前执行</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> () </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">      clearInterval</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">timer</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">      console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;组件即将卸载，执行清理&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    };</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  }, []);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">div</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;// ... JSX ...&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">div</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>其他 Hooks 的对应关系：</strong></p><ul><li><strong><code>useState</code> / <code>useReducer</code></strong>：管理状态，相当于在 <code>constructor</code> 中初始化 <code>this.state</code>。</li><li><strong><code>useMemo</code> / <code>useCallback</code></strong>：用于性能优化，类似于 <code>shouldComponentUpdate</code> 的部分功能，防止不必要的计算和子组件重渲染。</li><li><strong><code>useLayoutEffect</code></strong>：与 <code>useEffect</code> 签名相同，但执行时机不同。它在浏览器执行<strong>绘制之前</strong>同步执行。适用于需要直接操作 DOM 并立即更新屏幕的场景，类似于 <code>getSnapshotBeforeUpdate</code> 和 <code>componentDidUpdate</code> 的组合。</li></ul><hr><h3 id="总结与对比" tabindex="-1"><a class="header-anchor" href="#总结与对比"><span>总结与对比</span></a></h3><table><thead><tr><th style="text-align:left;">类组件生命周期</th><th style="text-align:left;">函数组件等价实现</th><th style="text-align:left;">核心目的</th></tr></thead><tbody><tr><td style="text-align:left;"><code>constructor</code></td><td style="text-align:left;"><code>useState</code></td><td style="text-align:left;">初始化状态</td></tr><tr><td style="text-align:left;"><code>componentDidMount</code></td><td style="text-align:left;"><code>useEffect(fn, [])</code></td><td style="text-align:left;">挂载后执行副作用</td></tr><tr><td style="text-align:left;"><code>componentDidUpdate</code></td><td style="text-align:left;"><code>useEffect(fn, [dep])</code></td><td style="text-align:left;">依赖变化后执行副作用</td></tr><tr><td style="text-align:left;"><code>componentWillUnmount</code></td><td style="text-align:left;"><code>useEffect(() =&gt; { return fn }, [])</code></td><td style="text-align:left;">卸载前执行清理</td></tr><tr><td style="text-align:left;"><code>shouldComponentUpdate</code></td><td style="text-align:left;"><code>React.memo</code>, <code>useMemo</code></td><td style="text-align:left;">优化性能，避免不必要的渲染</td></tr><tr><td style="text-align:left;"><code>render</code></td><td style="text-align:left;">函数组件返回值</td><td style="text-align:left;">返回 JSX</td></tr></tbody></table><p><strong>现代 React 开发的心得：</strong></p><ul><li><strong>推荐使用函数组件和 Hooks</strong>：它们提供了更简洁、更组合式的代码逻辑，并且避免了类组件中 <code>this</code> 的复杂性。</li><li><strong>心智模型转变</strong>：从思考“在生命周期的这个时间点我该做什么”转变为“当这些状态或 props 变化时，我需要同步什么样的副作用”。</li><li><strong>理解执行时机</strong>：深刻理解 <code>useEffect</code> 的依赖数组和清理机制是掌握函数组件行为的关键。</li></ul>`,29)])])}const r=i(l,[["render",o]]),k=JSON.parse('{"path":"/guide/source-code/React%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html","title":"React生命周期","lang":"zh-CN","frontmatter":{"description":"React生命周期 传统类组件（Class Component）的生命周期 现代函数组件（Function Component）与 Hooks 的“生命周期”思维 第一部分：传统类组件（Class Component）的生命周期 类组件的生命周期方法可以被划分为三个主要阶段：挂载（Mounting）、更新（Updating） 和 卸载（Unmounti...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"React生命周期\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-10-19T15:34:32.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"yjieyan\\",\\"url\\":\\"https://yjieyan.github.io/knowledge\\"}]}"],["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/knowledge/guide/source-code/React%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html"}],["meta",{"property":"og:site_name","content":"开卷有益"}],["meta",{"property":"og:title","content":"React生命周期"}],["meta",{"property":"og:description","content":"React生命周期 传统类组件（Class Component）的生命周期 现代函数组件（Function Component）与 Hooks 的“生命周期”思维 第一部分：传统类组件（Class Component）的生命周期 类组件的生命周期方法可以被划分为三个主要阶段：挂载（Mounting）、更新（Updating） 和 卸载（Unmounti..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-10-19T15:34:32.000Z"}],["meta",{"property":"article:modified_time","content":"2025-10-19T15:34:32.000Z"}]]},"git":{"createdTime":1760888072000,"updatedTime":1760888072000,"contributors":[{"name":"yjy","username":"yjy","email":"2192242196@qq.com","commits":1,"url":"https://github.com/yjy"}]},"readingTime":{"minutes":5.42,"words":1627},"filePathRelative":"guide/source-code/React生命周期.md","autoDesc":true}');export{r as comp,k as data};
