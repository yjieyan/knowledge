import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,a as e,o as n}from"./app-C1nt9b-F.js";const l={};function a(o,t){return n(),i("div",null,[...t[0]||(t[0]=[e(`<h1 id="xss和csrf" tabindex="-1"><a class="header-anchor" href="#xss和csrf"><span>Xss和Csrf</span></a></h1><hr><h3 id="第一部分-xss-跨站脚本攻击" tabindex="-1"><a class="header-anchor" href="#第一部分-xss-跨站脚本攻击"><span><strong>第一部分：XSS（跨站脚本攻击）</strong></span></a></h3><h4 id="_1-核心原理" tabindex="-1"><a class="header-anchor" href="#_1-核心原理"><span><strong>1. 核心原理</strong></span></a></h4><p>XSS 的本质是：<strong>攻击者利用网站对用户输入过滤不严的漏洞，将恶意脚本注入到网页中，使其他用户在浏览该网页时执行这些脚本。</strong></p><p>简单来说，就是 <strong>“恶意脚本”</strong> 被当作 <strong>“正常数据”</strong> 混入了网页。</p><h4 id="_2-攻击类型详解" tabindex="-1"><a class="header-anchor" href="#_2-攻击类型详解"><span><strong>2. 攻击类型详解</strong></span></a></h4><p>XSS 主要分为三类，理解它们的区别对于防范至关重要。</p><table><thead><tr><th style="text-align:left;">类型</th><th style="text-align:left;">存储型（持久型）</th><th style="text-align:left;">反射型（非持久型）</th><th style="text-align:left;">DOM 型</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>恶意脚本存储位置</strong></td><td style="text-align:left;"><strong>服务器数据库</strong></td><td style="text-align:left;"><strong>URL</strong></td><td style="text-align:left;"><strong>URL</strong></td></tr><tr><td style="text-align:left;"><strong>触发方式</strong></td><td style="text-align:left;">受害者浏览<strong>正常页面</strong></td><td style="text-align:left;">受害者<strong>点击特定恶意链接</strong></td><td style="text-align:left;">受害者<strong>点击特定恶意链接</strong></td></tr><tr><td style="text-align:left;"><strong>是否经过服务器</strong></td><td style="text-align:left;"><strong>是</strong>（从数据库读出）</td><td style="text-align:left;"><strong>是</strong>（服务器返回含脚本的页面）</td><td style="text-align:left;"><strong>否</strong>（纯前端漏洞）</td></tr><tr><td style="text-align:left;"><strong>危害程度</strong></td><td style="text-align:left;">高</td><td style="text-align:left;">中</td><td style="text-align:left;">中</td></tr></tbody></table><p><strong>深入分析：</strong></p><ul><li><p><strong>存储型 XSS</strong>：</p><ol><li><strong>攻击路径</strong>：攻击者提交一条含恶意脚本的评论/昵称 -&gt; 服务器<strong>保存</strong>到数据库 -&gt; 普通用户访问查看评论的页面 -&gt; 服务器从数据库取出评论并返回给浏览器 -&gt; 浏览器<strong>执行</strong>了评论中的恶意脚本。</li><li><strong>场景</strong>：论坛发帖、用户评论、用户昵称等所有用户输入并会被其他用户看到的地方。</li></ol></li><li><p><strong>反射型 XSS</strong>：</p><ol><li><strong>攻击路径</strong>：攻击者构造一个含恶意脚本的URL（如 <code>https://victim.com/search?keyword=&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;</code>） -&gt; 诱骗用户点击 -&gt; 服务器收到请求，将 <code>keyword</code> 参数值直接拼接到HTML中返回 -&gt; 用户的浏览器执行了返回页面中的恶意脚本。</li><li><strong>场景</strong>：搜索框、错误信息页面等将用户输入直接输出到页面的地方。</li></ol></li><li><p><strong>DOM 型 XSS</strong>：</p><ol><li><strong>攻击路径</strong>：攻击者构造一个含恶意参数的URL（如 <code>https://victim.com#&lt;img src=x onerror=alert(&#39;xss&#39;)&gt;</code>） -&gt; 诱骗用户点击 -&gt; 用户的浏览器接收到响应，<strong>前端 JavaScript 代码（如 <code>location.hash</code> 或 <code>document.write</code>）直接操作 DOM，将恶意参数插入到了页面中</strong> -&gt; 导致脚本执行。</li><li><strong>关键区别</strong>：整个过程<strong>不经过服务器</strong>，是前端 JavaScript 代码的不安全操作导致的。</li></ol></li></ul><h4 id="_3-xss-的防范措施" tabindex="-1"><a class="header-anchor" href="#_3-xss-的防范措施"><span><strong>3. XSS 的防范措施</strong></span></a></h4><p>防范 XSS 的核心思想是：<strong>永远不要信任用户输入，对所有用户输入进行“消毒”。</strong></p><ol><li><p><strong>输入过滤 vs 输出转义</strong></p><ul><li><strong>输入过滤</strong>：在用户提交数据时进行过滤。这很好，但<strong>不能完全依赖</strong>，因为数据可能在多个地方使用，转义规则不同。</li><li><strong>输出转义（核心手段）</strong>：在将数据输出到不同上下文时，进行特定的转义。 <ul><li><strong>HTML 上下文</strong>：将 <code>&lt;, &gt;, &amp;, &quot;, &#39;</code> 等字符转义为 HTML 实体（如 <code>&lt;</code> -&gt; <code>&amp;lt;</code>）。这样，<code>&lt;script&gt;</code> 就会被显示为文本，而不是被当作标签解析。</li><li><strong>JavaScript 上下文</strong>：不能只用 <code>escapeHtml</code>，需要用 <code>\\</code> 对特殊字符进行转义，或者更安全地，避免将用户输入直接嵌入到 <code>&lt;script&gt;</code> 标签中。</li><li><strong>URL 上下文</strong>：使用 <code>encodeURIComponent</code> 对参数进行编码。</li><li><strong>现代前端框架（如 React, Vue, Angular）默认已经提供了 XSS 防护</strong>，它们会在渲染动态内容时自动进行转义。但要注意使用 <code>v-html</code>/<code>dangerouslySetInnerHTML</code> 等 API 时的风险。</li></ul></li></ul></li><li><p><strong>内容安全策略（CSP）</strong><br> CSP 是一个<strong>深度防御</strong>的利器。它通过 HTTP 头 <code>Content-Security-Policy</code> 告诉浏览器只允许加载和执行来自哪些源的脚本、样式、图片等。</p><ul><li><strong>示例</strong>：<code>Content-Security-Policy: default-src &#39;self&#39;; script-src &#39;self&#39; https://trusted.cdn.com;</code></li><li><strong>作用</strong>：即使网站被注入了恶意脚本，只要该脚本的来源不在白名单内，浏览器就会<strong>拒绝执行</strong>它。</li><li><strong>还能禁止内联脚本</strong>（如 <code>onclick</code> 事件），从根本上杜绝大部分 XSS。</li></ul></li><li><p><strong>使用 HttpOnly Cookie</strong><br> 为敏感的 Cookie 设置 <code>HttpOnly</code> 属性。这样，JavaScript（包括恶意脚本）就无法通过 <code>document.cookie</code> 读取到这个 Cookie，从而防止攻击者窃取用户会话。</p></li></ol><hr><h3 id="第二部分-csrf-跨站请求伪造" tabindex="-1"><a class="header-anchor" href="#第二部分-csrf-跨站请求伪造"><span><strong>第二部分：CSRF（跨站请求伪造）</strong></span></a></h3><h4 id="_1-核心原理-1" tabindex="-1"><a class="header-anchor" href="#_1-核心原理-1"><span><strong>1. 核心原理</strong></span></a></h4><p>CSRF 的本质是：<strong>攻击者利用用户已登录的身份，在用户不知情的情况下，以用户的名义执行非本意的操作。</strong></p><p>简单来说，就是 <strong>“借用”</strong> 了用户的<strong>身份和权限</strong>，但 <strong>“绕过”</strong> 了前端逻辑。</p><h4 id="_2-攻击流程详解" tabindex="-1"><a class="header-anchor" href="#_2-攻击流程详解"><span><strong>2. 攻击流程详解</strong></span></a></h4><p>假设用户已经登录了银行网站 <code>bank.com</code>，并且会话 Cookie 仍然有效。</p><ol><li>用户被诱骗访问了攻击者的网站 <code>evil.com</code>。</li><li><code>evil.com</code> 的页面上隐藏着一个自动提交的表单（或一个 <code>img</code> 标签的 <code>src</code> 请求）：<div class="language-html line-numbers-mode" data-highlighter="shiki" data-ext="html" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-html"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">&lt;!-- 表单方式 --&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">form</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> action</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;https://bank.com/transfer&quot;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> method</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;POST&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  &lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">input</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> type</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;hidden&quot;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> name</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;to&quot;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> value</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;attacker&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  &lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">input</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> type</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;hidden&quot;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> name</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;amount&quot;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> value</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;1000&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">form</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">script</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">document</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">forms</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">].</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">submit</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">script</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">&lt;!-- 图片方式 (GET请求) --&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">img</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> src</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;https://bank.com/transfer?to=attacker&amp;amount=1000&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li>浏览器在发送请求到 <code>bank.com</code> 时，会<strong>自动携带</strong>该域名下的登录 Cookie。</li><li>服务器收到请求，验证 Cookie 有效，便认为是用户本人的合法操作，于是执行了转账。</li><li>攻击完成，用户可能完全不知情。</li></ol><h4 id="_3-csrf-的防范措施" tabindex="-1"><a class="header-anchor" href="#_3-csrf-的防范措施"><span><strong>3. CSRF 的防范措施</strong></span></a></h4><p>防范 CSRF 的核心思想是：<strong>确保请求来自用户自愿操作且可信的前端页面，而不是第三方网站发起的。</strong></p><ol><li><p><strong>同源策略（SOP）的误区</strong><br> 首先要明确：<strong>同源策略（SOP）不能防范 CSRF</strong>。SOP 限制的是不同源的页面之间如何<strong>读取</strong>对方的资源，而 CSRF 是浏览器在<strong>发送</strong>请求时自动携带了 Cookie， SOP 并不禁止这种“发送”行为。</p></li><li><p><strong>Anti-CSRF Token（最有效、最主流的方法）</strong></p><ul><li><strong>原理</strong>：在表单或请求中，加入一个<strong>随机的、不可预测的 Token</strong>。这个 Token 由服务器生成，并在用户会话中存一份。当用户提交请求时，服务器会验证这个 Token 是否匹配。</li><li><strong>为何有效</strong>：攻击者的网站 <code>evil.com</code> 无法通过 JavaScript <strong>读取</strong>到用户页面中的 Token（因为 SOP 的限制），因此无法构造出合法的请求。</li></ul></li><li><p><strong>SameSite Cookie 属性</strong><br> 这是一个非常优雅的解决方案，从浏览器层面解决 CSRF。</p><ul><li><code>SameSite=Strict</code>：严格模式，完全禁止第三方 Cookie。从 <code>evil.com</code> 发起的对 <code>bank.com</code> 的请求，不会发送 Cookie。</li><li><code>SameSite=Lax</code>：（默认值）宽松模式，大多数跨站请求不发送 Cookie，但一些安全的顶级导航（如 <code>&lt;a&gt;</code> 链接）会发送。</li><li><code>SameSite=None</code>：关闭 SameSite，但必须同时设置 <code>Secure</code> 属性（仅限 HTTPS）。</li></ul></li><li><p><strong>验证 Referer/Origin 头</strong><br> 检查 HTTP 请求头中的 <code>Referer</code> 或 <code>Origin</code> 字段，看请求是否来自合法的源（自己的网站）。但这种方法可能因隐私设置或浏览器兼容性问题而不可靠，通常作为辅助手段。</p></li></ol><hr><h3 id="第三部分-xss-与-csrf-的对比与关联" tabindex="-1"><a class="header-anchor" href="#第三部分-xss-与-csrf-的对比与关联"><span><strong>第三部分：XSS 与 CSRF 的对比与关联</strong></span></a></h3><table><thead><tr><th style="text-align:left;">特性</th><th style="text-align:left;">XSS</th><th style="text-align:left;">CSRF</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>全称</strong></td><td style="text-align:left;">跨站脚本攻击</td><td style="text-align:left;">跨站请求伪造</td></tr><tr><td style="text-align:left;"><strong>核心问题</strong></td><td style="text-align:left;"><strong>内容注入</strong>与<strong>脚本执行</strong></td><td style="text-align:left;"><strong>身份借用</strong>与<strong>权限滥用</strong></td></tr><tr><td style="text-align:left;"><strong>攻击目标</strong></td><td style="text-align:left;">获取用户数据（如 Cookie）、进行恶意操作</td><td style="text-align:left;">以用户名义执行特定操作（如转账、改密码）</td></tr><tr><td style="text-align:left;"><strong>所需条件</strong></td><td style="text-align:left;">网站存在输入漏洞</td><td style="text-align:left;">用户已登录目标网站</td></tr><tr><td style="text-align:left;"><strong>依赖同源策略</strong></td><td style="text-align:left;"><strong>绕过/利用</strong> 同源策略</td><td style="text-align:left;"><strong>依赖</strong> 同源策略的“发送Cookie”行为</td></tr><tr><td style="text-align:left;"><strong>关联性</strong></td><td style="text-align:left;"><strong>XSS 可以导致更严重的 CSRF</strong>。如果网站存在 XSS，攻击者可以直接在页面内获取到 Anti-CSRF Token，从而使 CSRF 防护失效。</td><td style="text-align:left;"></td></tr></tbody></table><h3 id="总结与扩展" tabindex="-1"><a class="header-anchor" href="#总结与扩展"><span><strong>总结与扩展</strong></span></a></h3><ul><li><strong>防范 XSS</strong>：记住 <strong>“消毒”</strong>（转义）、<strong>CSP</strong> 和 <strong>HttpOnly Cookie</strong>。</li><li><strong>防范 CSRF</strong>：记住 <strong>“Token”</strong> 和 <strong>“SameSite Cookie”</strong>。</li><li><strong>安全是纵深防御</strong>：没有一种方法是万能的。应该结合多种措施，在应用的各个层面（前端、后端、网络传输、浏览器）进行防护。</li><li><strong>现代框架的帮助</strong>：React/Vue 等框架的默认转义、以及像 <code>axios</code> 这样的库自动携带 CSRF Token 的机制，都大大降低了开发者的安全负担，但理解其底层原理依然至关重要。</li></ul>`,30)])])}const d=s(l,[["render",a]]),h=JSON.parse('{"path":"/guide/computer/Xss%E5%92%8CCsrf.html","title":"Xss和Csrf","lang":"zh-CN","frontmatter":{"description":"Xss和Csrf 第一部分：XSS（跨站脚本攻击） 1. 核心原理 XSS 的本质是：攻击者利用网站对用户输入过滤不严的漏洞，将恶意脚本注入到网页中，使其他用户在浏览该网页时执行这些脚本。 简单来说，就是 “恶意脚本” 被当作 “正常数据” 混入了网页。 2. 攻击类型详解 XSS 主要分为三类，理解它们的区别对于防范至关重要。 深入分析： 存储型 X...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Xss和Csrf\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-11-06T01:35:29.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"yjieyan\\",\\"url\\":\\"https://yjieyan.github.io/knowledge\\"}]}"],["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/knowledge/guide/computer/Xss%E5%92%8CCsrf.html"}],["meta",{"property":"og:site_name","content":"开卷有益"}],["meta",{"property":"og:title","content":"Xss和Csrf"}],["meta",{"property":"og:description","content":"Xss和Csrf 第一部分：XSS（跨站脚本攻击） 1. 核心原理 XSS 的本质是：攻击者利用网站对用户输入过滤不严的漏洞，将恶意脚本注入到网页中，使其他用户在浏览该网页时执行这些脚本。 简单来说，就是 “恶意脚本” 被当作 “正常数据” 混入了网页。 2. 攻击类型详解 XSS 主要分为三类，理解它们的区别对于防范至关重要。 深入分析： 存储型 X..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-11-06T01:35:29.000Z"}],["meta",{"property":"article:modified_time","content":"2025-11-06T01:35:29.000Z"}]]},"git":{"createdTime":1762392929000,"updatedTime":1762392929000,"contributors":[{"name":"yjieyan","username":"yjieyan","email":"2192242196@qq.com","commits":1,"url":"https://github.com/yjieyan"}]},"readingTime":{"minutes":6.72,"words":2017},"filePathRelative":"guide/computer/Xss和Csrf.md","autoDesc":true}');export{d as comp,h as data};
