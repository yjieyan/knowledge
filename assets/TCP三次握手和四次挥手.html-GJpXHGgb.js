import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,f as r,o as l}from"./app-D1Bmfn99.js";const n={};function i(s,o){return l(),e("div",null,[...o[0]||(o[0]=[r('<h1 id="tcp三次握手和四次挥手" tabindex="-1"><a class="header-anchor" href="#tcp三次握手和四次挥手"><span>TCP三次握手和四次挥手</span></a></h1><hr><h3 id="第一部分-tcp三次握手-建立连接" tabindex="-1"><a class="header-anchor" href="#第一部分-tcp三次握手-建立连接"><span>第一部分：TCP三次握手 - 建立连接</span></a></h3><p>三次握手的目的是为了<strong>建立一个双向的、可靠的TCP连接</strong>。它确保了客户端和服务器都具备发送和接收数据的能力。</p><h4 id="详细过程" tabindex="-1"><a class="header-anchor" href="#详细过程"><span>详细过程</span></a></h4><p>假设客户端（Client）想要与服务器（Server）建立连接。</p><ol><li><p><strong>第一次握手：SYN</strong></p><ul><li><strong>动作：</strong> 客户端发送一个TCP报文段。</li><li><strong>标志位：</strong> 设置 <code>SYN = 1</code>。</li><li><strong>序列号：</strong> 客户端随机生成一个初始序列号 <code>seq = x</code>。</li><li><strong>目的：</strong> 客户端告诉服务器：“我想和你建立连接。我的初始序列号是 <code>x</code>。”</li><li><strong>此时客户端状态：</strong> 进入 <code>SYN-SENT</code> 状态。</li></ul></li><li><p><strong>第二次握手：SYN-ACK</strong></p><ul><li><strong>动作：</strong> 服务器收到客户端的SYN报文后，如果同意连接，则回复一个报文段。</li><li><strong>标志位：</strong> 设置 <code>SYN = 1</code>, <code>ACK = 1</code>。</li><li><strong>序列号：</strong> 服务器随机生成自己的初始序列号 <code>seq = y</code>。</li><li><strong>确认号：</strong> <code>ack = x + 1</code>。 (表示期望收到客户端的下一个序列号，同时也确认了收到了客户端的 <code>seq=x</code>)</li><li><strong>目的：</strong> 服务器告诉客户端：“我收到你的连接请求了，我同意建立连接。我的初始序列号是 <code>y</code>，请确认。”</li><li><strong>此时服务器状态：</strong> 进入 <code>SYN-RCVD</code> 状态。</li></ul></li><li><p><strong>第三次握手：ACK</strong></p><ul><li><strong>动作：</strong> 客户端收到服务器的SYN-ACK报文后，需要再次确认。</li><li><strong>标志位：</strong> 设置 <code>ACK = 1</code>。</li><li><strong>序列号：</strong> <code>seq = x + 1</code>。（因为第一次握手的SYN包消耗了一个序列号）</li><li><strong>确认号：</strong> <code>ack = y + 1</code>。（表示期望收到服务器的下一个序列号，同时也确认了收到了服务器的 <code>seq=y</code>）</li><li><strong>目的：</strong> 客户端告诉服务器：“我收到你的确认了，我们现在可以开始传输数据了。”</li><li><strong>此时连接状态：</strong> 服务器收到这个ACK报文后，也进入 <code>ESTABLISHED</code> 状态。至此，连接建立成功，双方可以开始数据传输。</li></ul></li></ol><h4 id="为什么是三次-而不是两次" tabindex="-1"><a class="header-anchor" href="#为什么是三次-而不是两次"><span>为什么是三次，而不是两次？</span></a></h4><p>核心原因是<strong>为了防止已失效的连接请求报文突然又传送到服务器，因而产生错误</strong>。</p><p><strong>场景模拟：</strong><br> 假设客户端发送了一个连接请求报文A，但这个报文在网络中滞留了（因为网络拥堵），客户端超时后重传了请求报文B，并与服务器正常完成了通信，关闭了连接。此时，那个失效的报文A终于到达了服务器。</p><ul><li><p><strong>如果是两次握手：</strong> 服务器收到失效的报文A，会误以为客户端又发起了新连接，于是回复SYN-ACK并进入 <code>ESTABLISHED</code> 状态，开始等待客户端发送数据。但客户端此时并没有意图建立新连接，不会理会这个确认，也不会发送数据。这就导致了：</p><ol><li><strong>服务器空等</strong>，浪费了服务器资源。</li><li>如果这种情况频繁发生，服务器可能因维护大量半开连接而耗尽资源，这被称为 <strong>SYN Flood攻击</strong> 的雏形。</li></ol></li><li><p><strong>三次握手如何解决：</strong> 在三次握手的机制下，服务器收到失效的报文A后，会回复SYN-ACK并进入 <code>SYN-RCVD</code> 状态，但它需要等待客户端的第三次ACK。由于客户端没有发起新连接，它不会发送这个ACK，因此服务器在等待超时后，会关闭这个半连接，回收资源。<strong>第三次握手是客户端对服务器连接意图的最终确认，避免了服务器的资源浪费。</strong></p></li></ul><hr><h3 id="第二部分-tcp四次挥手-断开连接" tabindex="-1"><a class="header-anchor" href="#第二部分-tcp四次挥手-断开连接"><span>第二部分：TCP四次挥手 - 断开连接</span></a></h3><p>四次挥手的目的是为了<strong>安全、可靠地关闭一个双向的TCP连接</strong>。由于TCP连接是全双工的，每个方向都必须单独进行关闭。</p><h4 id="详细过程-1" tabindex="-1"><a class="header-anchor" href="#详细过程-1"><span>详细过程</span></a></h4><p>假设客户端主动发起关闭连接。</p><ol><li><p><strong>第一次挥手：FIN</strong></p><ul><li><strong>动作：</strong> 客户端发送一个TCP报文段。</li><li><strong>标志位：</strong> 设置 <code>FIN = 1</code>。</li><li><strong>序列号：</strong> <code>seq = u</code>（一个特定的序列号）。</li><li><strong>目的：</strong> 客户端告诉服务器：“我这边没有数据要发送了，我想关闭从客户端到服务器这个方向上的连接。”（即客户端不再发送数据，但还可以接收数据）</li><li><strong>此时客户端状态：</strong> 进入 <code>FIN-WAIT-1</code> 状态。</li></ul></li><li><p><strong>第二次挥手：ACK</strong></p><ul><li><strong>动作：</strong> 服务器收到客户端的FIN报文后，立即回复一个确认报文。</li><li><strong>标志位：</strong> 设置 <code>ACK = 1</code>。</li><li><strong>序列号：</strong> <code>seq = v</code>。</li><li><strong>确认号：</strong> <code>ack = u + 1</code>。</li><li><strong>目的：</strong> 服务器告诉客户端：“我收到你的关闭请求了。”</li><li><strong>此时状态：</strong><ul><li>客户端进入 <code>FIN-WAIT-2</code> 状态。</li><li>服务器进入 <code>CLOSE-WAIT</code> 状态。此时，从客户端到服务器的连接已经关闭，但<strong>从服务器到客户端的连接仍然存在</strong>，服务器可能还有数据需要发送给客户端。这是一个<strong>半关闭</strong>状态。</li></ul></li></ul></li><li><p><strong>第三次挥手：FIN</strong></p><ul><li><strong>动作：</strong> 当服务器也完成了所有数据的发送后，它会发送一个FIN报文。</li><li><strong>标志位：</strong> 设置 <code>FIN = 1</code>。</li><li><strong>序列号：</strong> <code>seq = w</code>（注意，这个序列号可能与 <code>v</code> 不同，因为中间可能发送了数据）。</li><li><strong>确认号：</strong> <code>ack = u + 1</code>。（仍然确认客户端的初始FIN）</li><li><strong>目的：</strong> 服务器告诉客户端：“我这边也没有数据要发送了，我也要关闭连接了。”</li><li><strong>此时服务器状态：</strong> 进入 <code>LAST-ACK</code> 状态。</li></ul></li><li><p><strong>第四次挥手：ACK</strong></p><ul><li><strong>动作：</strong> 客户端收到服务器的FIN报文后，发送一个确认报文。</li><li><strong>标志位：</strong> 设置 <code>ACK = 1</code>。</li><li><strong>序列号：</strong> <code>seq = u + 1</code>。</li><li><strong>确认号：</strong> <code>ack = w + 1</code>。</li><li><strong>目的：</strong> 客户端告诉服务器：“我收到你的关闭请求了。”</li><li><strong>此时状态：</strong><ul><li>客户端进入 <code>TIME-WAIT</code> 状态，并等待 <strong>2MSL</strong> 的时间后，才进入 <code>CLOSED</code> 状态。</li><li>服务器收到这个ACK后，立即进入 <code>CLOSED</code> 状态。</li></ul></li></ul></li></ol><h4 id="为什么是四次挥手" tabindex="-1"><a class="header-anchor" href="#为什么是四次挥手"><span>为什么是四次挥手？</span></a></h4><p>因为TCP连接是<strong>全双工</strong>的，关闭时需要两个方向独立进行。</p><ul><li>当客户端发送FIN时，只表示它不再发送数据，但还可以接收数据。</li><li>服务器收到FIN后，可能还有数据需要处理和发送，所以它先回复一个ACK，确认客户端的关闭请求。等所有数据发送完毕后，服务器再发送自己的FIN，来关闭自己这个方向的连接。</li><li>因此，中间的两次挥手（ACK和FIN）<strong>在大多数情况下不能合并</strong>，这就导致了需要四次挥手。</li></ul><h4 id="为什么客户端需要time-wait状态-等待2msl" tabindex="-1"><a class="header-anchor" href="#为什么客户端需要time-wait状态-等待2msl"><span>为什么客户端需要TIME-WAIT状态？等待2MSL？</span></a></h4><p><code>TIME-WAIT</code> 状态有两个至关重要的目的：</p><ol><li><p><strong>可靠地终止TCP连接：</strong> 确保最后一个ACK能够到达服务器。</p><ul><li>如果客户端发送的最后一个ACK在网络中丢失，服务器会超时重传它的FIN报文。</li><li>如果客户端没有维护 <code>TIME-WAIT</code> 状态而直接关闭，那么当收到重传的FIN时，它会回复一个RST报文，这会被服务器解释为一个错误。</li><li>在 <code>TIME-WAIT</code> 状态下，客户端可以收到这个重传的FIN，并重新发送ACK，从而保证连接能正常关闭。</li></ul></li><li><p><strong>让旧的重复报文在网络中消逝：</strong> 防止之前连接的延迟报文被新连接误接收。</p><ul><li>一个连接关闭后，可能还有属于这个连接的、在网络中滞留的报文段。</li><li><code>TIME-WAIT</code> 状态等待 <strong>2MSL</strong>，可以确保在创建新的同名连接（相同IP和端口）之前，所有属于旧连接的报文都已经从网络中消逝，避免了数据混淆。</li></ul></li></ol><p><strong>MSL</strong> 是“最大报文段生存时间”，任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。<code>2MSL</code> 是报文来回的最大时间。</p><hr><h3 id="总结与类比" tabindex="-1"><a class="header-anchor" href="#总结与类比"><span>总结与类比</span></a></h3><ul><li><p><strong>三次握手：</strong> 像两个人打电话。</p><ul><li>A：“喂，听得到吗？” (SYN)</li><li>B：“听得到，你呢？” (SYN-ACK)</li><li>A：“我也听得到，我们开始说吧。” (ACK) -&gt; <strong>通话建立</strong></li></ul></li><li><p><strong>四次挥手：</strong> 像两个人结束通话。</p><ul><li>A：“我说完了，要挂电话了。” (FIN)</li><li>B：“好的，我知道你说完了。” (ACK) -&gt; <strong>A到B的通道关闭，B可能还有话说</strong></li><li>B：“我也说完了，可以挂电话了。” (FIN)</li><li>A：“好的，拜拜。” (ACK) -&gt; <strong>B到A的通道关闭，A等待一下确保B听到再见</strong></li></ul></li></ul>',27)])])}const d=t(n,[["render",i]]),a=JSON.parse('{"path":"/guide/computer/%E7%BD%91%E7%BB%9C/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.html","title":"TCP三次握手和四次挥手","lang":"zh-CN","frontmatter":{"description":"TCP三次握手和四次挥手 第一部分：TCP三次握手 - 建立连接 三次握手的目的是为了建立一个双向的、可靠的TCP连接。它确保了客户端和服务器都具备发送和接收数据的能力。 详细过程 假设客户端（Client）想要与服务器（Server）建立连接。 第一次握手：SYN 动作： 客户端发送一个TCP报文段。 标志位： 设置 SYN = 1。 序列号： 客户...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"TCP三次握手和四次挥手\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-10-19T15:34:32.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"yjieyan\\",\\"url\\":\\"https://yjieyan.github.io/knowledge\\"}]}"],["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/knowledge/guide/computer/%E7%BD%91%E7%BB%9C/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.html"}],["meta",{"property":"og:site_name","content":"学习与分享"}],["meta",{"property":"og:title","content":"TCP三次握手和四次挥手"}],["meta",{"property":"og:description","content":"TCP三次握手和四次挥手 第一部分：TCP三次握手 - 建立连接 三次握手的目的是为了建立一个双向的、可靠的TCP连接。它确保了客户端和服务器都具备发送和接收数据的能力。 详细过程 假设客户端（Client）想要与服务器（Server）建立连接。 第一次握手：SYN 动作： 客户端发送一个TCP报文段。 标志位： 设置 SYN = 1。 序列号： 客户..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-10-19T15:34:32.000Z"}],["meta",{"property":"article:modified_time","content":"2025-10-19T15:34:32.000Z"}]]},"git":{"createdTime":1760888072000,"updatedTime":1760888072000,"contributors":[{"name":"yjy","username":"yjy","email":"2192242196@qq.com","commits":1,"url":"https://github.com/yjy"}]},"readingTime":{"minutes":7.09,"words":2127},"filePathRelative":"guide/computer/网络/TCP三次握手和四次挥手.md","autoDesc":true}');export{d as comp,a as data};
