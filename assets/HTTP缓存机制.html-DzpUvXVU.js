import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as o,a,o as n}from"./app-B8OghdsB.js";const d="/knowledge/assets/http2-Cx89hbiQ.png",s={};function i(l,e){return n(),o("div",null,[...e[0]||(e[0]=[a(`<h1 id="http缓存机制" tabindex="-1"><a class="header-anchor" href="#http缓存机制"><span>HTTP缓存机制</span></a></h1><hr><h3 id="_1-核心目标" tabindex="-1"><a class="header-anchor" href="#_1-核心目标"><span>1. 核心目标</span></a></h3><p>HTTP缓存的核心目标有三个：</p><ol><li><strong>减少延迟：</strong> 从本地缓存读取资源比从远程服务器获取快得多，从而加快页面加载速度。</li><li><strong>降低带宽消耗：</strong> 重复使用缓存的资源，减少了不必要的网络请求，为用户和服务器节省流量。</li><li><strong>减轻服务器压力：</strong> 更少的请求意味着服务器需要处理的负载更小。</li></ol><hr><h3 id="_2-关键分类-强缓存与协商缓存" tabindex="-1"><a class="header-anchor" href="#_2-关键分类-强缓存与协商缓存"><span>2. 关键分类：强缓存与协商缓存</span></a></h3><p>HTTP缓存主要分为两大类，它们的行为和优先级完全不同。</p><table><thead><tr><th style="text-align:left;">类别</th><th style="text-align:left;">核心思想</th><th style="text-align:left;">行为</th><th style="text-align:left;">相关Header</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>强缓存</strong></td><td style="text-align:left;"><strong>无需询问服务器，直接使用本地副本。</strong></td><td style="text-align:left;">浏览器不会向服务器发送请求，直接从磁盘或内存缓存中读取资源。状态码：<code>200 (from disk cache)</code> 或 <code>200 (from memory cache)</code>。</td><td style="text-align:left;"><code>Cache-Control</code><br><code>Expires</code></td></tr><tr><td style="text-align:left;"><strong>协商缓存</strong></td><td style="text-align:left;"><strong>每次都需要询问服务器：“我缓存的这个版本还能用吗？”</strong></td><td style="text-align:left;">浏览器会向服务器发送请求，如果资源未变，服务器返回 <code>304 Not Modified</code>，浏览器则使用缓存；如果已变，服务器返回 <code>200 OK</code> 和新资源。</td><td style="text-align:left;"><code>Last-Modified</code> / <code>If-Modified-Since</code><br><code>ETag</code> / <code>If-None-Match</code></td></tr></tbody></table><p><strong>重要关系：浏览器会优先检查强缓存，只有在强缓存失效后，才会发起请求并进入协商缓存阶段。</strong></p><hr><h3 id="_3-强缓存详解" tabindex="-1"><a class="header-anchor" href="#_3-强缓存详解"><span>3. 强缓存详解</span></a></h3><p>强缓存通过两个HTTP头部控制，<strong><code>Cache-Control</code> 是现代Web开发中的首选和绝对主力</strong>。</p><h4 id="a-cache-control-http-1-1引入" tabindex="-1"><a class="header-anchor" href="#a-cache-control-http-1-1引入"><span>a) <code>Cache-Control</code> (HTTP/1.1引入)</span></a></h4><p>这是一个通用头，既可以被服务器在响应中设置，也可以被客户端在请求中设置。它通过一系列指令来精确控制缓存行为。</p><p><strong>常见响应指令：</strong></p><ul><li><code>public</code>： 响应可以被任何对象（客户端、代理服务器等）缓存。</li><li><code>private</code>： 响应只能被单个用户（浏览器）缓存，不能被代理服务器等共享缓存。通常用于个性化私密数据。</li><li><code>no-cache</code>： <strong>这个名字有误导性！</strong> 它的意思是：<strong>可以缓存，但在使用缓存副本前，必须先向服务器进行验证（即跳过强缓存，直接进入协商缓存）。</strong></li><li><code>no-store</code>： <strong>真正的“不缓存”</strong>。不允许存储任何关于客户端请求和服务端响应的内容。安全级别最高。</li><li><code>max-age=&lt;seconds&gt;</code>： <strong>最重要的指令</strong>。设置缓存存储的<strong>最大周期</strong>，单位为秒。相对于请求时间。例如 <code>max-age=3600</code> 表示资源可以被缓存1小时。</li><li><code>s-maxage=&lt;seconds&gt;</code>： 与 <code>max-age</code> 类似，但仅适用于共享缓存（如CDN），优先级高于 <code>max-age</code>。</li><li><code>must-revalidate</code>： 一旦缓存过期，在成功向原始服务器验证之前，不能使用旧副本。</li></ul><p><strong>示例：</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>Cache-Control: public, max-age=3600 // 公共缓存，有效期1小时</span></span>
<span class="line"><span>Cache-Control: no-cache              // 使用前必须验证</span></span>
<span class="line"><span>Cache-Control: no-store              // 绝不缓存</span></span>
<span class="line"><span>Cache-Control: private, max-age=86400 // 私有缓存，有效期1天</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="b-expires-http-1-0引入" tabindex="-1"><a class="header-anchor" href="#b-expires-http-1-0引入"><span>b) <code>Expires</code> (HTTP/1.0引入)</span></a></h4><ul><li><strong>含义：</strong> 指定一个资源的<strong>绝对过期时间</strong>（GMT格式）。</li><li><strong>问题：</strong> 依赖服务器和客户端时钟严格同步，如果不同步，会导致缓存失效不准。<strong>它是 <code>Cache-Control: max-age</code> 的备用方案，优先级更低。</strong></li></ul><hr><h3 id="_4-协商缓存详解" tabindex="-1"><a class="header-anchor" href="#_4-协商缓存详解"><span>4. 协商缓存详解</span></a></h3><p>当强缓存失效（<code>max-age</code>时间到），浏览器会携带缓存“证据”向服务器发起请求，询问资源是否变更。</p><h4 id="a-last-modified-if-modified-since" tabindex="-1"><a class="header-anchor" href="#a-last-modified-if-modified-since"><span>a) <code>Last-Modified</code> / <code>If-Modified-Since</code></span></a></h4><ul><li><p><strong>工作原理：</strong></p><ol><li><strong>首次请求：</strong> 服务器在响应头中返回 <code>Last-Modified: &lt;GMT time&gt;</code>，告知资源最后修改时间。</li><li><strong>再次请求：</strong> 浏览器在请求头中带上 <code>If-Modified-Since: &lt;Last-Modified value&gt;</code>。</li><li><strong>服务器校验：</strong> 服务器比较资源的当前最后修改时间和 <code>If-Modified-Since</code> 的值。 <ul><li>如果时间一致，返回 <code>304 Not Modified</code>，响应体为空。</li><li>如果不一致，返回 <code>200 OK</code> 和新的资源内容，并更新 <code>Last-Modified</code> 头。</li></ul></li></ol></li><li><p><strong>缺陷：</strong></p><ol><li><strong>精度到秒：</strong> 如果文件在1秒内修改多次，无法准确识别。</li><li><strong>内容未变，时间改变：</strong> 有时文件可能只是被<code>touch</code>了一下，内容没变，但修改时间变了，导致不必要的重新下载。</li></ol></li></ul><h4 id="b-etag-if-none-match-更精确、优先级更高" tabindex="-1"><a class="header-anchor" href="#b-etag-if-none-match-更精确、优先级更高"><span>b) <code>ETag</code> / <code>If-None-Match</code> (更精确、优先级更高)</span></a></h4><p>为了解决 <code>Last-Modified</code> 的缺陷，HTTP/1.1引入了 <code>ETag</code>。</p><ul><li><p><strong>工作原理：</strong></p><ol><li><strong>首次请求：</strong> 服务器在响应头中返回 <code>ETag: &quot;xyz123&quot;</code>。这个值通常是文件内容的哈希值或版本号。</li><li><strong>再次请求：</strong> 浏览器在请求头中带上 <code>If-None-Match: &quot;xyz123&quot;</code>。</li><li><strong>服务器校验：</strong> 服务器计算当前资源的ETag，并与 <code>If-None-Match</code> 的值比较。 <ul><li>如果一致，返回 <code>304 Not Modified</code>。</li><li>如果不一致，返回 <code>200 OK</code> 和新的资源内容，并更新 <code>ETag</code> 头。</li></ul></li></ol></li><li><p><strong>优势：</strong></p><ul><li>精度极高，只要内容不变，ETag就不会变。</li><li>能准确感知内容的变化。</li></ul></li></ul><p><strong>注意：</strong> 当 <code>ETag</code> 和 <code>Last-Modified</code> 同时存在时，<strong><code>ETag</code> 的优先级更高</strong>。</p><hr><h3 id="_5-完整的缓存决策流程图" tabindex="-1"><a class="header-anchor" href="#_5-完整的缓存决策流程图"><span>5. 完整的缓存决策流程图</span></a></h3><p>为了更直观地理解整个流程，我们可以想象浏览器发起一个资源请求时的决策过程：<br><img src="`+d+'" alt="" loading="lazy"></p><hr><h3 id="_6-前端实践与缓存策略" tabindex="-1"><a class="header-anchor" href="#_6-前端实践与缓存策略"><span>6. 前端实践与缓存策略</span></a></h3><p>对于不同类型的资源，我们应该采用不同的缓存策略，这被称为“缓存配方”。</p><table><thead><tr><th style="text-align:left;">资源类型</th><th style="text-align:left;">策略</th><th style="text-align:left;">示例</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>HTML文件</strong></td><td style="text-align:left;"><code>no-cache</code> 或 <code>max-age=0</code></td><td style="text-align:left;"><code>Cache-Control: no-cache</code> <br>确保用户总能获取到最新的页面结构，但通过协商缓存节省带宽。</td></tr><tr><td style="text-align:left;"><strong>CSS、JS、图片</strong></td><td style="text-align:left;"><strong>强缓存 + 文件名哈希</strong></td><td style="text-align:left;"><code>Cache-Control: public, max-age=31536000</code> <br>（一年）并设置 <code>immutable</code>。通过构建工具（Webpack/Vite）在文件名中加入哈希值，这样内容一变，文件名就变，URL就变了，强制浏览器下载新文件。这是<strong>最有效的策略</strong>。</td></tr><tr><td style="text-align:left;"><strong>API接口数据</strong></td><td style="text-align:left;"><strong>通常 <code>no-store</code> 或 <code>private, no-cache</code></strong></td><td style="text-align:left;"><code>Cache-Control: no-store</code> <br>对于个性化、实时性要求高的数据，不缓存。对于列表等数据，可酌情短时间缓存。</td></tr></tbody></table><p><strong>最佳实践：</strong></p><ul><li><strong>利用构建工具进行“文件指纹”哈希：</strong> 这是实现“永不失效”的强缓存的关键。<code>main.abc123.js</code> -&gt; 内容变更 -&gt; <code>main.def456.js</code>。</li><li><strong>CDN的重要性：</strong> CDN边缘节点本身就是巨大的公有缓存 (<code>public</code>)，能极大加速静态资源的全球分发。</li><li><strong>谨慎使用 <code>v</code> 参数：</strong> 如 <code>script.js?v=1.0.0</code>。这是一种“伪版本控制”，不如文件哈希可靠，因为它依赖于开发者手动更新版本号。</li></ul><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><p>HTTP缓存是一个由<strong>强缓存</strong>和<strong>协商缓存</strong>构成的精密系统。作为前端开发者，我们的核心任务是：</p><ol><li><strong>理解 <code>Cache-Control</code> 等关键头的含义。</strong></li><li><strong>为不同资源制定并实施合理的缓存策略。</strong></li><li><strong>利用现代构建工具，通过文件哈希实现最极致的静态资源缓存。</strong></li></ol>',42)])])}const g=t(s,[["render",i]]),h=JSON.parse('{"path":"/guide/computer/%E7%BD%91%E7%BB%9C/HTTP%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6.html","title":"HTTP缓存机制","lang":"zh-CN","frontmatter":{"description":"HTTP缓存机制 1. 核心目标 HTTP缓存的核心目标有三个： 减少延迟： 从本地缓存读取资源比从远程服务器获取快得多，从而加快页面加载速度。 降低带宽消耗： 重复使用缓存的资源，减少了不必要的网络请求，为用户和服务器节省流量。 减轻服务器压力： 更少的请求意味着服务器需要处理的负载更小。 2. 关键分类：强缓存与协商缓存 HTTP缓存主要分为两大类...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"HTTP缓存机制\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-10-19T15:34:32.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"yjieyan\\",\\"url\\":\\"https://yjieyan.github.io/knowledge\\"}]}"],["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/knowledge/guide/computer/%E7%BD%91%E7%BB%9C/HTTP%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6.html"}],["meta",{"property":"og:site_name","content":"学习与分享"}],["meta",{"property":"og:title","content":"HTTP缓存机制"}],["meta",{"property":"og:description","content":"HTTP缓存机制 1. 核心目标 HTTP缓存的核心目标有三个： 减少延迟： 从本地缓存读取资源比从远程服务器获取快得多，从而加快页面加载速度。 降低带宽消耗： 重复使用缓存的资源，减少了不必要的网络请求，为用户和服务器节省流量。 减轻服务器压力： 更少的请求意味着服务器需要处理的负载更小。 2. 关键分类：强缓存与协商缓存 HTTP缓存主要分为两大类..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-10-19T15:34:32.000Z"}],["meta",{"property":"article:modified_time","content":"2025-10-19T15:34:32.000Z"}]]},"git":{"createdTime":1760888072000,"updatedTime":1760888072000,"contributors":[{"name":"yjy","username":"yjy","email":"2192242196@qq.com","commits":1,"url":"https://github.com/yjy"}]},"readingTime":{"minutes":5.79,"words":1736},"filePathRelative":"guide/computer/网络/HTTP缓存机制.md","autoDesc":true}');export{g as comp,h as data};
